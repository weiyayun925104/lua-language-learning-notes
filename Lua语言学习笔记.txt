    01- Lua脚本学习--入门

简介

Lua的设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。

作为一门过程型动态语言，Lua有着如下的特性：

    变量名没有类型，值才有类型，变量名在运行时可与任何类型的值绑定;
    语言只提供唯一一种数据结构，称为表(table)，它混合了数组、哈希，可以用任何类型的值作为 key 和 value。提供了一致且富有表达力的表构造语法，使得 Lua 很适合描述复杂的数据;
    函数是一等类型，支持匿名函数和正则尾递归(proper tail recursion);
    支持词法定界(lexical scoping)和闭包(closure);
    提供 thread 类型和结构化的协程(coroutine)机制，在此基础上可方便实现协作式多任务;
    运行期能编译字符串形式的程序文本并载入虚拟机执行;
    通过元表(metatable)和元方法(metamethod)提供动态元机制(dynamic metamechanism)，从而允许程序运行时根据需要改变或扩充语法设施的内定语义;
    能方便地利用表和动态元机制实现基于原型(prototype-based)的面向对象模型;
    从 5.1 版开始提供了完善的模块机制，从而更好地支持开发大型的应用程序;

Lua应用场景：

    游戏开发
    独立应用脚本
    Web 应用脚本
    扩展和数据库插件如：MySQL Proxy 和 MySQL WorkBench
    安全系统，如入侵检测系统

安装

Lua最新版本是Lua 5.3.4（截止到2018-3-18）。

官网：http://www.lua.org/
Linux 系统上安装

Linux & Mac上安装 Lua 安装非常简单，只需要下载源码包并在终端解压编译即可，本文使用了5.3.0版本进行安装：

curl -R -O http://www.lua.org/ftp/lua-5.3.0.tar.gz
tar zxf lua-5.3.0.tar.gz
cd lua-5.3.0
make linux test
make install

Mac OS X 系统上安装

curl -R -O http://www.lua.org/ftp/lua-5.3.0.tar.gz
tar zxf lua-5.3.0.tar.gz
cd lua-5.3.0
make macosx test
make install

Mac 上也可以通过 homebrew 安装:

brew install lua

Window 系统上安装 Lua

window下你可以使用一个叫"SciTE"的IDE环境来执行lua程序，下载地址为： Github 下载地址：https://github.com/rjpcomputing/luaforwindows/releases Google Code下载地址 : https://code.google.com/p/luaforwindows/downloads/list 双击安装后即可在该环境下编写 Lua 程序并运行。

你也可以使用 Lua 官方推荐的方法使用 LuaDist：http://luadist.org/

安装好后查看版本：

$ lua -v
Lua 5.1.4  Copyright (C) 1994-2008 Lua.org, PUC-Rio

Lua 和 LuaJIT 的区别

Lua 非常高效，它运行得比许多其它脚本(如 Perl、Python、Ruby)都快，这点在第三方的独立测评中得到了证实。尽管如此，仍然会有人不满足，他们总觉得还不够快。LuaJIT 就是一个为了再榨出一些速度的尝试，它利用即时编译（Just-in Time）技术把 Lua 代码编译成本地机器码后交由 CPU 直接执行。

LuaJIT 2 的测评报告表明，在数值运算、循环与函数调用、协程切换、字符串操作等许多方面它的加速效果都很显著。

凭借着 FFI 特性，LuaJIT 2 在那些需要频繁地调用外部 C/C++ 代码的场景，也要比标准 Lua 解释器快很多。

目前 LuaJIT 2 已经支持包括 i386、x86_64、ARM、PowerPC 以及 MIPS 等多种不同的体系结构。

LuaJIT 是采用 C 和汇编语言编写的 Lua 解释器与即时编译器。LuaJIT 被设计成全兼容标准的 Lua 5.1 语言，同时可选地支持 Lua 5.2 和 Lua 5.3 中的一些不破坏向后兼容性的有用特性。因此，标准 Lua 语言的代码可以不加修改地运行在 LuaJIT 之上。

LuaJIT 和标准 Lua 解释器的一大区别是，LuaJIT 的执行速度，即使是其汇编编写的 Lua 解释器，也要比标准 Lua 5.1 解释器快很多，可以说是一个高效的 Lua 实现。另一个区别是，LuaJIT 支持比标准 Lua 5.1 语言更多的基本原语和特性，因此功能上也要更加强大。

LuaJIT 官网链接：http://luajit.org
OpenResty 与 Lua、LuaJIT

自从 OpenResty 1.5.8.1 版本之后，默认捆绑的 Lua 解释器就被替换成了 LuaJIT，而不再是标准 Lua。也就是，我们安装了OpenResty也会包含Lua解释器。

OpenResty 官网链接：http://openresty.org/cn/
基础语法
Hello World

我们创建一个 HelloWorld.lua 文件，代码如下:

print("Hello World!")

执行以下命令:

$ lua HelloWorld.lua

输出结果为： Hello World!

Lua也提供了交互式编程。打开命令行输入lua就会进入交互式编程模式:

$ lua
Lua 5.1.4  Copyright (C) 1994-2008 Lua.org, PUC-Rio
> print("Hello World!")
Hello World!
>

注释

两个减号是单行注释:

--

多行注释:

--[[
 多行注释
 多行注释
 --]]

标示符

Lua标示符以一个字母 A 到 Z 或 a 到 z 或下划线_开头后加上0个或多个字母，下划线，数字（0到9）。
最好不要使用下划线加大写字母的标示符，因为Lua的保留字也是这样的。
Lua 不允许使用特殊字符如 @, $, 和 % 来定义标示符。 Lua区分大小写。
关键词

以下列出了 Lua 的保留关键字。保留关键字不能作为常量或变量或其他用户自定义标示符：

and		break	do	else
elseif		end	false	for
function	if	in	local
nil		not	or	repeat
return		then	true	until
while		

一般约定，以下划线开头连接一串大写字母的名字（比如 _VERSION ）被保留用于 Lua 内部全局变量。
变量定义

变量在使用前，必须在代码中进行声明，即创建该变量。

Lua是动态类型语言，变量不要类型定义,只需要为变量赋值：

name = "yjc"
year = 2018
a = true
score = 98.01

变量的默认值均为 nil。访问一个没有初始化的全局变量不会出错，只不过返回结果是：nil。当然如果你想删除一个全局变量，只需要将变量赋值为nil即可：

score = 98.01
score = nil

Lua 变量作用域:

a = 10	--全局变量
local b = 10 	--局部变量

Lua 中的局部变量要用local关键字来显式定义，不使用 local 显式定义的变量就是全局变量。就算在if等语句块中，只要没使用local关键字来显式定义，也是全局变量，这一点和别的语言不同。

实际编程中尽量使用局部变量。

    02- Lua脚本学习--数据类型

Lua中有8个基本类型分别为：nil、boolean、number、string、table、function、userdata、thread。

函数 type 能够返回一个值或一个变量所属的类型：

print(type("hello world")) -->output:string
print(type(print)) -->output:function
print(type(true)) -->output:boolean
print(type(360.0)) -->output:number
print(type(nil)) -->output:nil

nil

只有值nil属于该类，表示一个无效值（在条件表达式中相当于false）。一个变量在第一次赋值前的默认值是 nil，将 nil 赋予给一个全局变量就等同于删除它。

local num
print(num) -->output:nil

num = 100
print(num) -->output:100

boolean

boolean 类型只有两个可选值：true和false，Lua 把 false 和 nil 看作是"假"，其他的都为"真"，比如 0 和空字符串就是"真"，这和C、PHP等语言不一样。

local a = true
local b = 0
local c = nil

if a then
	print("a") -->output:a
else
	print("not a") --这个没有执行
end

if b then
	print("b") -->output:b
else
	print("not b") --这个没有执行
end

if c then
	print("c") --这个没有执行
else
	print("not c") -->output:not c
end

输出：

a
b
not c

number

Lua 默认只有一种 number 类型: double（双精度）类型，以下几种写法都被看作是 number 类型：

print(type(2))
print(type(2.2))
print(type(0.2))
print(type(2e+1))
print(type(0.2e-1))
print(type(7.8263692594256e-06))

string

字符串由一对双引号或单引号来表示:

string1 = "this is string1\n"
string2 = 'this is string2\n'
print(string1)
print(string2)

输出：

this is string1

this is string2

可以看出单引号里面转义字符也生效。说明Lua不区分单引号、双引号。

也可以用 2 个方括号 "[[]]" 来表示"一块"字符串。我们把两个正的方括号（即[[）间插入 n 个等号定义为第 n 级正长括号:

string3 = [[this is string3\n]] -- 0 级正的长括号
string4 = [=[this is string4\n]=] -- 1 级正的长括号
string5 = [==[this is string5\n]==] -- 2 级正的长括号
string6 = [====[ this is string6\n[===[]===] ]====] -- 4 级正的长括号，可以包含除了本级别的反长括号外的所有内容
print(string3)
print(string4)
print(string5)
print(string6)

输出：

this is string3\n
this is string4\n
this is string5\n
 this is string6\n[===[]===]

注意：由方括号包含的字符串，整个词法分析过程将不受分行限制，不处理任何转义符，并且忽略掉任何不同级别的长括号。

另外，需要注意的就是：Lua的字符串是不可改变的值，不能像在 c 语言中那样直接修改字符串的某个字符，而是根据修改要求来创建一个新的字符串。Lua 也不能通过下标来访问字符串的某个字符。

字符串使用..拼接：

string7 = string3..string4
print(string7)

输出：

this is string3\nthis is string4\n

在对一个数字字符串上进行算术操作时，Lua 会尝试将这个数字字符串转成一个数字:

> print("2" + 6)
8.0

使用 # 来计算字符串的长度，放在字符串前面，如下实例：

local string8 = "this is string8"
print(#string8) -- 输出：15

table

Table 类型实现了一种抽象的“关联数组”。“关联数组”是一种具有特殊索引方式的数组，索引通常是string或者number类型，但也可以是除 nil 以外的任意类型的值。

PHP程序员对此会很熟悉，因为PHP里的数组(array)和Table非常类似。示例：

local tmp = {
	name = "lua",
	-- "name2" = "lua2", -- 错误的表示
	["name3"] = "lua",
	year = 2018,
	pi = 3.14159,
	lang = {"c", "java", "lua"},
	100,  -- 相当于[1] = 100，此时索引为数字。lua里数字索引是从1开始的，不是0
	-- 10 = 11, -- 错误的表示
	[10] = 11, -- 相当于[10] = 11，此时索引为数字
}

print(tmp.name)  -- 等同于 print(tmp["name"])
print(tmp["name3"])  -- 等同于 print(tmp.name3)
print(tmp.year)
print(tmp.pi)
print(tmp.lang[1])
print(tmp[1])
print(tmp[10])

输出：

lua
lua
2018
3.14159
c
100
11

在 Lua 里表的默认初始索引一般以 1 开始，而不是0，这点需要注意。

也可以先创建一个空表，再添加数据：

a = {}
a.key = "value"

在内部实现上，table 通常实现为一个哈希表、一个数组、或者两者的混合。具体的实现为何种形式，动态依赖于具体的 table 的键分布特点。
function

在 Lua 中，函数 也是一种数据类型，函数可以存储在变量中，可以通过参数传递给其他函数，还可以作为其他函数的返回值。

function maxNumber(a, b)
	if a > b then
		return a
	else
		return b
	end
end

local testFunc = maxNumber

print(testFunc(10,100));

输出：

100  

有名函数的定义本质上是匿名函数对变量的赋值：

function foo()
end

等价于：

foo = function ()
end

userdata

userdata 是一种用户自定义数据，用于表示一种由应用程序或 C/C++ 语言库所创建的类型，可以将任意 C/C++ 数据类型的数据（通常是 struct 和 指针）存储到 Lua 变量中调用。
thread

在 Lua 里，最主要的线程是协同程序（coroutine）。它跟线程（thread）差不多，拥有自己独立的栈、局部变量和指令指针，可以跟其他协同程序共享全局变量和其他大部分东西。 
线程跟协程的区别：线程可以同时多个运行，而协程任意时刻只能运行一个，并且处于运行状态的协程只有被挂起（suspend）时才会暂停。

    03- Lua脚本学习--运算符

Lua支持下列主要的运算符：

    算术运算符
    关系运算符
    逻辑运算符
    赋值运算符

还支持..、#特殊运算符。其中赋值运算符仅支持=，不支持C语言的+=、++等运算符。
算术运算符

+ 加法
- 减法或者负号
* 乘法
/ 除法
^ 指数
% 取模

print(1 + 2) -->打印 3
print(5 / 10) -->打印 0.5。 这是Lua不同于c语言的
print(5.0 / 10) -->打印 0.5。 浮点数相除的结果是浮点数
-- print(10 / 0) -->注意除数不能为0，计算的结果会出错
print(2 ^ 10) -->打印 1024。 求2的10次方

关系运算符

< 小于
> 大于
<= 小于等于
>= 大于等于
== 等于
~= 不等于

注意：Lua 语言中“不等于”运算符的写法为：~=。

由于 Lua 字符串总是会被“内化”，即相同内容的字符串只会被保存一份，因此 Lua 字符串之间的相等性比较可以简化为其内部存储地址的比较。其它语言一般需要逐个字节（或按 若干个连续字节）进行比较。
逻辑运算符

and 逻辑与
or 逻辑或
not 逻辑非

Lua 中的 and 和 or 是不同于 c 语言的。在 c 语言中，and 和 or 只得到两个值 1 和 0，其中 1 表示真，0 表示假。而 Lua 中 and 的执行过程是这样的：

    a and b 如果 a 为 nil，则返回 a，否则返回 b;
    a or b 如果 a 为 nil，则返回 b，否则返回 a。

a = 10
b = nil

print(a and b)
print(b and a)
print(a or b)
print(b or a)

输出：

nil
nil
10
10

赋值运算符

= 简单的赋值运算符，把右边操作数的值赋给左边操作数

其它运算符

..	连接两个字符串
#	一元运算符，返回字符串或表的长度。

print("hello".." world") -- 输出：hello world
print(#"hello") -- 输出：5

    04- Lua脚本学习--控制语句

Lua 语言提供的控制结构有 if-else，while，repeat，for，并提供 break、return 关键字来满足更丰富的需求。不支持switch、continue。

Lua 提供的控制语句部分特征类似Shell和Python：

    语句都以end结束
    if后面都有then
    没有花括号{}
    循环结构while、for表达式后面都有关键字do; python里是用的:

if-else

单个 if 分支 型:

a = 10
if a > 0 then
	print(a)
end

两个分支 if-else 型：

a = 10
b = 11
if a > b then
	print(a)
else
	print(b)
end

多个分支 if-elseif-else 型：

a = 10
b = 11
if a > b then
	print(a)
elseif a < b then
	print(b)
else
	print(a)
end

与 C 语言的不同之处是 else 与 if 是连在一起的，若将 else 与 if 写成 else if 则相当于在else 里嵌套另一个 if语句。
while

Lua 跟其他常见语言一样，提供了 while 控制结构，语法上也没有什么特别的。但是没有提供 do-while 型的控制结构，但是提供了功能相当的 repeat。

sum = 0
i = 0
while i<=100 do
	sum = sum + i
	i = i + 1;
end
print(sum) -- 5050

    注意：Lua 并没有像许多其他语言那样提供类似 continue 这样的控制语句用来跳过当前循环。

再看看 repeat 的用法：

sum = 0
i = 0
repeat
	sum = sum + i
	i = i + 1;
until i>100
print(sum) -- 5050

for

for有两种结构：数字 for（numeric for） 和范型 for（generic for）。

数字 for 类似C语言的用法；范型 for 类似Python里的for...in用法。
for 数字型

数字型 for 的语法如下：

for var = begin, finish, step do
	--body
end

需要关注以下几点：

    var 从 begin 变化到 finish，每次变化都以 step 作为步长递增 var
    begin、finish、step 三个表达式只会在循环开始时执行一次
    第三个表达式 step是可选的，默认为 1
    控制变量 var 的作用域仅在 for 循环内，需要在外面控制，则需将值赋给一个新的变量
    循环过程中不要改变控制变量的值，那样会带来不可预知的影响

示例：

sum = 0
for i=0,100,1 do
	sum = sum + i
end
print(sum) -- 5050

for 泛型

Lua 编程语言中泛型for循环语法格式:

-- 打印数组a的所有值  
for i,v in ipairs(a) do 
	print(v) 
end  

i是数组索引值，v是对应索引的数组元素值。ipairs是Lua提供的一个迭代器函数，用来迭代数组。

示例：

days = {
	"Monday",
	"Tuesday",
	"Wednesday",
	"Thursday",
	"Friday",
}

for k,v in ipairs(days) do
	print(k,v)
end

输出：

1       Monday
2       Tuesday
3       Wednesday
4       Thursday
5       Friday

    ipairs以及pairs 的不同: pairs可以遍历表中所有的key，并且除了迭代器本身以及遍历表本身还可以返回nil; 但是ipairs则不能返回nil，只能返回数字0，如果值遇到nil则直接跳出循环退出。

示例：

local tabFiles = {  
	[1] = "test1",  
	[6] = "test2",  
	[4] = "test3"  
}  

for k,v in ipairs(tabFiles) do
	print(k,v)
end

输出：

1       test1

ipairs遍历时，当key=2时候value就是nil，所以直接跳出循环。

如果换成pairs，则全部输出:

1       test1
6       test2
4       test3

    值得一提的是，在 LuaJIT 2.1 中， ipairs() 内建函数是可以被 JIT 编译的，而 pairs() 则只能被解释执行。

break

语句 break 用来终止 while 、 repeat 和 for 三种循环的执行，并跳出当前循环体， 继续执行当前循环之后的语句。
return

return 主要用于从函数中返回结果，或者用于简单的结束一个函数的执行。

需要注意的是： return 只能写在语句块的最后，一旦执行了 return 语句，该语句之后的所有语句都不会再执行。

若要写在函数中间，则只能写在一个显式的语句块内，否则会报错：

function test1(x, y)
	return x+y;
	-- print(x+y)
	-- 后面的print如果不注释，会报错
end

function test2(x, y)
	if x > y then
		return x
	else
		return y
	end
	print("end") -- 此处的print不注释不会报错，因为return只出现在前面显式的语句块
end

function test3(x, y)
	print(x+y)
	do return end
	print(x) -- 此处的print不注释不会报错，因为return由do...end语句块包含。这一行语句永远不会执行到
end

test1(10,11)
test2(10,11)
test3(10,11)

所以，有时候为了调试方便，我们可以想在某个函数的中间提前 return ，以进行控制流的短路，此时我们可以将 return 放在一个 do...end 代码块中。

    05- Lua脚本学习--函数

在 Lua 中，函数 也是一种数据类型，函数可以存储在变量中，可以通过参数传递给其他函数，还可以作为其他函数的返回值。
函数定义

函数定义格式：

function function_name (arc) -- arc 表示参数列表，函数的参数列表可以为空
	-- body
end

支持使用local定义为局部作用域的函数。

    由于函数定义本质上就是变量赋值，而变量的定义总是应放置在变量使用之前，所以函数的定义也需要放置在函数调用之前。

由于函数定义等价于变量赋值，我们也可以把函数名替换为某个 Lua 表的某个字段，例如：

function foo.bar(a, b, c)
	-- body ...
end

对于此种形式的函数定义，不能再使用 local 修饰符了，因为不存在定义新的局部变量了。
函数参数

支持固定参数和变长参数。固定参数很好理解，变长参数则是使用...定义的：

function function_name (...)
	local args = {...} or {} 
end

注意：在调用函数的时候，如果实参和形参个数不一样的时候：

    实参缺少，则使用nil代替
    实参大于形参，则忽略

    LuaJIT 2 尚不能 JIT 编译这种变长参数的用法，只能解释执行。

Lua函数的参数大部分是按值传递的。值传递就是调用函数时，实参把它的值通过赋值运算传递给形参，然后形参的改变和实参就没有关系了。

当函数参数是 table 类型时，传递进来的是实际参数的引用，此时在函数内部对该 table 所做的修改，会直接对调用者所传递的实际参数生效。
函数返回值

Lua可以返回多个值，这点和Python、Go类似，不同于C、PHP等语言。返回多个值时，值之间用“,”隔开。

local function swap(a, b) 
	return b, a -- 按相反顺序返回变量的值
end
print(swap(1,2))

输出：

2	1

注意：在调用函数的时候，如果返回值的个数和接收返回值的变量的个数不一致时：

    返回值缺少，则使用nil代替
    返回值个数大于接收变量的个数，则忽略

当一个方法返回多个值时，有些返回值有时候用不到，要是声明很多变量来一一接收，显然不太合适 。Lua 提供了一个虚变量(dummy variable)，以单个下划线（“_”） 来命名，用它来丢弃不需要的数值，仅仅起到占位的作用。这点和Go用法一致。

local function test_var()
	return 1,2,3
end

local x,_,y = test_var()
print(x,y) -- 1	3

函数动态调用

函数动态调用是指：调用回调函数，并把一个数组参数作为回调函数的参数。

主要用到了unpack函数和可变参数。

示例：

function do_action(func, ...)
	local args = {...} or {} -- 防止为nil
	func(unpack(args, 1, table.maxn(args))) -- 如果实参中确定没有nil空洞（nil值被夹在非空值之间），可以只写第一个参数 
end

local function add(x, y)
	print(x+y)
end

local function add2(x, y, z)
	print(x+y+z)
end

do_action(add, 1, 1)
do_action(add2, 1, 1, 1)

输出：

2
3

    unpack 内建函数还不能为 LuaJIT 所 JIT 编译，因此这种用法总是会被解释执行。

    06- Lua脚本学习--模块

模块

从Lua5.1开始，Lua添加了对模块和包的支持。

Lua 的模块是由变量、函数等已知元素组成的 table，因此创建一个模块很简单，就是创建一个table，然后把需要导出的常量、函数放入其中，最后返回这个 table 就行。

示例：

mymodule.lua

local _M = {}

_M.VERSION = "1.0"

_M.getName = function()
	return "get"
end

return _M

使用require即可引入模块：

local m = require "mymodule"
print(m.VERSION)
print(m.getName())

输出：

1.0
get

点号与冒号操作符的区别

看下面示例代码：

local str = "abcde"
print("case 1:", str:sub(1, 2))
print("case 2:", str.sub(str, 1, 2))

输出：

case 1: ab
case 2: ab

冒号操作会带入一个 self 参数，用来代表 自己 。而点号操作，只是内容的展开，需要手动传入self 参数。

在函数定义时，使用冒号将默认接收一个 self 参数，而使用点号则需要显式传入 self 参数。

示例：

mytable = {}
mytable.func1 = function(self, name)
	self.name = name
end

mytable:func2 = function(name)
	self.name = name
end

这里的func1和func2是等价的。

    07- Lua脚本学习--常用库介绍

String 库

    .. 链接两个字符串
    string.upper(argument) 字符串全部转为大写字母。
    string.lower(argument) 字符串全部转为小写字母。
    string.len(arg) 计算字符串长度
    string.reverse(arg) 字符串反转
    string.format(...) 返回一个类似printf的格式化字符串
    string.byte(s [, i [, j ]]) 转换字符为整数值(可以指定某个字符，默认第一个字符)
    string.char(arg) 将整型数字转成字符并连接
    string.rep(string, n) 返回字符串string的n个拷贝
    string.gsub(mainString, findString, replaceString, num) 在字符串中替换,mainString为要替换的字符串， findString 为被替换的字符，replaceString 要替换的字符，num 替换次数（可以忽略，则全部替换）
    string.find (str, substr, [init, [end]]) 在一个指定的目标字符串中搜索指定的内容(第三个参数为索引),返回其具体位置。不存在则返回 nil。
    string.gmatch(str, pattern) 返回一个迭代器函数，每一次调用这个函数，返回一个在字符串 str 找到的下一个符合 pattern 描述的子串。如果参数 pattern 描述的字符串没有找到，迭代函数返回nil。
    string.match(str, pattern, init) 寻找源字串str中的第一个配对. 参数init可选, 指定搜寻过程的起点, 默认为1。 在成功配对时, 函数将返回配对表达式中的所有捕获结果; 如果没有设置捕获标记, 则返回整个配对字符串. 当没有成功的配对时, 返回nil。

字符串格式化

string.format()类似c里的printf()。示例：

print(string.format("name %s, age %s", "yjc", 20)) -- name yjc, age 20
print(string.format("%.4f",1/3)) -- 0.3333

格式字符串可能包含以下的转义码:

    %c - 接受一个数字, 并将其转化为ASCII码表中对应的字符
    %d, %i - 接受一个数字并将其转化为有符号的整数格式
    %o - 接受一个数字并将其转化为八进制数格式
    %u - 接受一个数字并将其转化为无符号整数格式
    %x - 接受一个数字并将其转化为十六进制数格式, 使用小写字母
    %X - 接受一个数字并将其转化为十六进制数格式, 使用大写字母
    %e - 接受一个数字并将其转化为科学记数法格式, 使用小写字母e
    %E - 接受一个数字并将其转化为科学记数法格式, 使用大写字母E
    %f - 接受一个数字并将其转化为浮点数格式
    %g(%G) - 接受一个数字并将其转化为%e(%E, 对应%G)及%f中较短的一种格式
    %q - 接受一个字符串并将其转化为可安全被Lua编译器读入的格式
    %s - 接受一个字符串并按照给定的参数格式化该字符串

为进一步细化格式, 可以在%号后添加参数. 参数将以如下的顺序读入:

    符号: 一个+号表示其后的数字转义符将让正数显示正号. 默认情况下只有负数显示符号.
    占位符: 一个0, 在后面指定了字串宽度时占位用. 不填时的默认占位符是空格.
    对齐标识: 在指定了字串宽度时, 默认为右对齐, 增加-号可以改为左对齐.
    宽度数值
    小数位数/字串裁切: 在宽度数值后增加的小数部分n, 若后接f(浮点数转义符, 如%6.3f)则设定该浮点数的小数只保留n位, 若后接s(字符串转义符, 如%5.3s)则设定该字符串只显示前n位.

    注：string.match()、string.gmatch() 目前并不能被 JIT 编译，OpenResty 里应尽量使用 ngx_lua 模块提供的 ngx.re.match 等API。

Table 库

    table.concat (table [, sep [, start [, end]]]) concat是concatenate(连锁, 连接)的缩写. table.concat()函数列出参数中指定table的数组部分从start位置到end位置的所有元素, 元素间以指定的分隔符(sep)隔开。
    table.insert (table, [pos,] value) 在table的数组部分指定位置(pos)插入值为value的一个元素. pos参数可选, 默认为数组部分末尾.
    table.maxn (table) 指定table中所有正数key值中最大的key值. 如果不存在key值为正数的元素, 则返回0。(Lua5.2之后该方法已经不存在了,本文使用了自定义函数实现)
    table.remove (table [, pos]) 返回table数组部分位于pos位置的元素. 其后的元素会被前移. pos参数可选, 默认为table长度, 即从最后一个元素删起。
    table.sort (table [, comp]) 对给定的table进行升序排序。

日期时间库

    os.time ([table]) 如果不使用参数 table 调用 time 函数，它会返回当前的时间和日期（它表示从某一时刻到现在的秒数）。如果用 table 参数，它会返回一个数字，表示该 table 中 所描述的日期和时间（它表示从某一时刻到 table 中描述日期和时间的秒数）。
    os.difftime (t2, t1) 返回 t1 到 t2 的时间差，单位为秒。
    os.date ([format [, time]]) 把一个表示日期和时间的数值，转换成更高级的表现形式。其第一个参数 format 是一个格式化字符串，描述了要返回的时间形式。第二个参数 time 就是日期和时间的数字表示，缺省时默认为当前的时间。

    如果使用OpenResty，不建议使用Lua的标准时间函数，因为这些函数通常会引发不止一个昂贵的系统调用，同时无法为 LuaJIT JIT 编译，对性能造成较大影响。推荐使用 ngx_lua 模块提供的带缓存的时间接口，如 ngx.today, ngx.time, ngx.utctime, ngx.localtime, ngx.now, ngx.http_time，以及 ngx.cookie_time 等。

数学库

常用数学函数：

    math.rad(x) 角度x转换成弧度
    math.deg(x) 弧度x转换成角度
    math.max(x, ...) 返回参数中值最大的那个数，参数必须是number型
    math.min(x, ...) 返回参数中值最小的那个数，参数必须是number型
    math.random ([m [, n]]) 不传入参数时，返回 一个在区间[0,1)内均匀分布的伪随机实数；只使用一个整数参数m时，返回一个在区间[1, m]内均匀分布的伪随机整数；使用两个整数参数时，返回一个在区间[m, n]内均匀分布的伪随机整数
    math.randomseed (x) 为伪随机数生成器设置一个种子x，相同的种子将会生成相同的数字序列
    math.abs(x) 返回x的绝对值
    math.fmod(x, y) 返回 x对y取余数
    math.pow(x, y) 返回x的y次方
    math.sqrt(x) 返回x的算术平方根
    math.exp(x) 返回自然数e的x次方
    math.log(x) 返回x的自然对数
    math.log10(x) 返回以10为底，x的对数
    math.floor(x) 返回最大且不大于x的整数
    math.ceil(x) 返回最小且不小于x的整数
    math.pi	圆周率
    math.sin(x) 求弧度x的正弦值
    math.cos(x) 求弧度x的余弦值
    math.tan(x) 求弧度x的正切值
    math.asin(x) 求x的反正弦值
    math.acos(x) 求x的反余弦值
    math.atan(x) 求x的反正切值

示例：

-- src/test_math.lua
print(math.pi) -- 3.1415926535898
print(math.pow(2,3))  -- 8
print(math.max(-1, 2, 0, 3.6, 9.1))     --  9.1
print(math.floor(3.14159))  -- 3
print(math.ceil(7.9988))    -- 8

注意：使用 math.random() 函数获得伪随机数时，如果不使用 math.randomseed() 设置伪随机数生成种子或者设置相同的伪随机数生成种子，那么得得到的伪随机数序列是一样的。示例：

-- math.randomseed(os.time())  -- 设置随机种子
print(math.random()) -- 0.79420629243124
print(math.random(10)) -- 7
print(math.random(10,20)) -- 16

上面的例子里同一机器运行多次的结果是一样的，只有设置了随机的伪随机数生成种子，才能保证每次生成的随机数是不相同的。

    08- Lua脚本学习--文件操作

Lua I/O 库用于读取和处理文件。分为简单模式、完全模式。

    简单模式（simple model） 拥有一个当前输入文件和一个当前输出文件，并且提供针对这些文件相关的操作。
    完全模式（complete model） 使用外部的文件句柄来实现。它以一种面对对象的形式，将所有的文件操作定义为文件句柄的方法。

对文件进行简单的读写操作时可以使用简单模式，但是对文件进行一些高级的操作简单模式则处理不了了。
简单模式

简单模式由io模块提供，主要有：

    io.open(filename [, mode]): 以mode模式打开一个文件
    io.input(file): 设置默认输入文件为file
    io.output(file): 设置默认输出文件为file
    io.write(content): 在文件最后一行添加content内容
    io.read(): 读取文件的一行。
    参数可以是下列中的一个：

"*n"	读取一个数字并返回它。例：file.read("*n")
"*a"	从当前位置读取整个文件。例：file.read("*a")
"*l"   （默认）读取下一行，在文件尾 (EOF) 处返回 nil。例：file.read("*l")
number	返回一个指定字符个数的字符串，或在 EOF 时返回 nil。例：file.read(5)

    io.close(file): 关闭打开的文件file
    io.tmpfile(): 返回一个临时文件句柄，该文件以更新模式打开，程序结束时自动删除
    io.type(file): 检测obj是否一个可用的文件句柄
    io.flush(): 向文件写入缓冲中的所有数据
    io.lines(optional file name): 返回一个迭代函数,每次调用将获得文件中的一行内容,当到文件尾时，将返回nil,但不关闭文件

mode模式：
模式 	描述
r 	以只读方式打开文件，该文件必须存在。
w 	打开只写文件，若文件存在则文件长度清为0，即该文件内容会消失。若文件不存在则建立该文件。
a 	以附加的方式打开只写文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾，即文件原先的内容会被保留。（EOF符保留）
r+ 	以可读写方式打开文件，该文件必须存在。
w+ 	打开可读写文件，若文件存在则文件长度清为零，即该文件内容会消失。若文件不存在则建立该文件。
a+ 	与a类似，但此文件可读可写
b 	二进制模式，如果文件是二进制文件，可以加上
b+ 	二进制模式，表示对文件既可以读也可以写

示例：

-- write
-- src/file_io_write.lua

local file = io.open("test_file.txt", 'w+')
io.output(file) -- 设置默认输出文件
io.write("hello lua!\nhahah") -- 把内容写到文件
io.close(file)

运行后查看生成的文件：

$ cat test_file.txt
hello lua!
hahah

-- read
-- src/file_io_read.lua

local file = io.open("test_file.txt", 'r')
io.input(file) -- 设置默认输入文件

-- while true do
--     line = io.read()
--     if line == nil then
--         break;
--     end
--     print(line)
-- end

for line in io.lines() do 
    print(line)
end
io.close(file)

运行：

$ luajit file_io_read.lua
hello lua!
hahah

完全模式

简单模式由file模块提供，主要有：

    file:write(content): 在文件最后一行添加content内容
    file:read(): 读取文件的一行
    file:close(): 关闭打开的文件
    file:seek(optional where, optional offset): 设置和获取当前文件位置,成功则返回最终的文件位置(按字节),失败则返回nil加错误信息。

参数 where 值可以是:

"set": 从文件头开始
"cur": 从当前位置开始[默认]
"end": 从文件尾开始
offset:默认为0

    file:flush(): 向文件写入缓冲中的所有数据

其中 file 为 io.open() 返回的文件句柄。

示例：

-- read
-- src/file_read.lua

local file = io.open("test_file.txt", 'r')

file:seek("end", -5) -- 定位到文件倒数第 5 个位置
print(file:read("*a")) -- 从当前位置读取整个文件

file:close()  -- 关闭打开的文件

输出：

$ luajit src/file_read.lua
hahah


    09- Lua脚本学习--元表

在Lua5.1语言中，元表 (metatable) 的表现行为类似于 C++ 语言中的操作符重载，类似PHP的魔术方法。Python里也有元类(metaclass)一说。

通过元表，Lua有了更多的扩展特性。Lua的面向对象特性就是基于元表实现的。

Lua 提供了两个十分重要的用来处理元表的方法，如下：

    setmetatable(table, metatable)：此方法用于为一个表设置元表。
    getmetatable(table)：此方法用于获取表的元表对象。

设置元表的方法很简单，如下：

local mytable = {}
local mymetatable = {}
setmetatable(mytable, mymetatable)

上面的代码可以简写成如下的一行代码：

local mytable = setmetatable({}, {})

例如我们可以重载 __add 元方法 (metamethod)，实现重载+操作符，来计算两个 Lua 数组的并集：

-- 计算集合的并集实例
set1 = {10,40}
set2 = {10,20,30}

setmetatable(set1, {
	__add = function(self, another)
		local res = {}
		local set = {}
		
		for k,v in pairs(self) do set[v] = true end -- 防止集合元素重复
		for k,v in pairs(another) do set[v] = true end -- 防止集合元素重复
		
		for k,v in pairs(set) do table.insert(res, k) end
		
		return res
	end
})

local set3 = set1 + set2
for k,v in pairs(set3) do print(v) end 

输出：

30
20
10
40

类似的元方法还有：

    __add +操作

    __sub -操作 其行为类似于 add 操作

    __mul *操作 其行为类似于 add 操作

    __div /操作 其行为类似于 add 操作

    __mod %操作 其行为类似于 add 操作

    __pow ^（幂）操作 其行为类似于 add 操作

    __unm 一元 - 操作

    __concat ..（字符串连接） 操作

    __len #操作

    __eq ==操作 函数 getcomphandler 定义了 Lua 怎样选择一个处理器来作比较操作，仅在两个对象类型相同且有对应操作相同的元方法时才起效

    __lt <操作

    __le <=操作

    __index 取下标操作用于访问 table[key]

    __newindex 赋值给指定下标 table[key] = value

    __tostring 转换成字符串

    __call 当 Lua 调用一个值时调用

    __mode 用于弱表(week table)

    __metatable 用于保护metatable不被访问

__index 元方法

该方法实现了在表中查找键不存在时转而在元表中查找该键的功能。有两种写法：

第一种是给 __index 元方法一个函数：

local mytable = setmetatable({}, {
	__index = function(self, key)
		return "__index"
	end
})
print(mytable.key1) -- __index 

另一种方法是给 __index 元方法一个表：

local _M = {
	add = function(x,y) return x+y end,
	mul = function(x,y) return x*y end,
	ver = "1.0",
}
local mytable = setmetatable({}, {
	__index = _M
})
print(mytable.ver) -- 1.0 
print(mytable.add(1,3)) -- 4 

Lua查找一个表元素时的规则，其实就是如下3个步骤:

    在表中查找，如果找到，返回该元素，找不到则继续
    判断该表是否有元表，如果没有元表，返回nil，有元表则继续。
    判断元表有没有__index方法，如果__index方法为nil，则返回nil；如果__index方法是一个表，则重复1、2、3；如果__index方法是一个函数，则返回该函数的返回值。

通过__index这个方法，我们可以实现继承的特性。下节再详细讲述。
__newindex 元方法

如果说__index具有PHP里__get的一些特性，那么__newindex则类似__set。

以下实例使用了 rawset 函数来更新表：

mytable = setmetatable({key1 = "value1"}, {
  __newindex = function(self, key, value)
        rawset(self, key, "\""..value.."\"")

  end
})

mytable.key1 = "new value"
mytable.key2 = 4

print(mytable.key1,mytable.key2)

以上实例执行输出结果为：

new value    "4"

__tostring 元方法

如果设置了__tostring 元方法，当直接输出表时会自动调用该方法。示例：

local mytable = setmetatable({ 10, 20, 30 }, {
  __tostring = function(mytable)
    sum = 0
    for k, v in pairs(mytable) do
        sum = sum + v
    end
    return sum
  end
})
print(mytable) -- 60

__call 元方法

__call 元方法的功能类似于 C++ 中的仿函数，使得普通的表也可以被调用。

local mytable = setmetatable({}, {
  __call = function(self, arg)
	local sum = 0
	for _,v in pairs(arg) do
		sum = sum + v
	end
    print(sum)
  end
})
mytable({10,20,30}) -- 60

示例里我们调用自定义的表，并给该表传了参数，最终算出了参数的和。
__metatable 元方法

如果给表设置了 __metatable 元方法的值，getmetatable 将返回这个域的值，而调用 setmetatable将会被禁止，会直接报错。

local mytable = setmetatable({}, {
  __metatable = "no access"
})
print(getmetatable(mytable)) -- no access
setmetatable(mytable, {}) -- 引发编译器报错

    10- Lua脚本学习--面向对象编程

在Lua 中，我们可以使用表和函数实现面向对象。将函数和相关的数据放置于同一个表中就形成了一个对象。

示例：

-- module/cache.lua

local _M = {}

_M.mt = {}

_M.set = function(self, key ,value)
	self.mt[key] = value
end

_M.get = function(self, key)
	return self.mt[key]
end

_M.getall = function(self)
	return self.mt
end

_M.new = function(self)
	return setmetatable({}, {__index = _M })
end

return _M

调用：

local cache = require "module/cache"
local c = cache:new()
c:set("name", "lua")
c:set("year", 2018)
print(c:get("name"))
print(c:get("year"))

for k,v in pairs(c:getall()) do
	print(k,v)
end

输出：

lua
2018
name    lua
year    2018

setmetatable 将 _M 作为新建表的原型，所以在自己的表内找不到所调用方法和变量的时候，便会到 __index 所指定的 _M 类型中去寻找。
继承

__index元方法实现了在父类中查找存在的方法和变量的机制。借助这个，可以实现继承。

还是利用上面的例子：

 -- module/mycache
local cache = require "module/cache"

local _M = {}

_M.del = function(self, key)
	_M.mt[key] = nil
end

_M.new = function(self)
	return setmetatable(_M, {__index = cache }) --该方法需要覆写父类的，确保此处的setmetatable先执行
end

return _M

此处实现了删除操作。调用：

local cache = require "module/mycache"
local c = cache:new()
c:set("name", "lua")
c:del("name")
print(c:get("name"))

输出：

nil


    11- Lua脚本学习--Redis里使用Lua

版本：自2.6.0起可用。 时间复杂度：取决于执行的脚本。

使用Lua脚本的好处：

    减少网络开销。可以将多个请求通过脚本的形式一次发送，减少网络时延。
    原子操作。redis会将整个脚本作为一个整体执行，中间不会被其他命令插入。因此在编写脚本的过程中无需担心会出现竞态条件，无需使用事务。
    复用。客户端发送的脚本会永久存在redis中，这样，其他客户端可以复用这一脚本而不需要使用代码完成相同的逻辑。

如何使用
基本使用

命令格式：

EVAL script numkeys key [key ...] arg [arg ...]

说明：

    script是第一个参数，为Lua 5.1脚本。该脚本不需要定义Lua函数（也不应该）。
    第二个参数numkeys指定后续参数有几个key。
    key [key ...]，是要操作的键，可以指定多个，在lua脚本中通过KEYS[1], KEYS[2]获取
    arg [arg ...]，参数，在lua脚本中通过ARGV[1], ARGV[2]获取。

简单实例：

127.0.0.1:6379> eval "return ARGV[1]" 0 100 
"100"
127.0.0.1:6379> eval "return {ARGV[1],ARGV[2]}" 0 100 101
1) "100"
2) "101"
127.0.0.1:6379> eval "return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}" 2 key1 key2 first second
1) "key1"
2) "key2"
3) "first"
4) "second"

127.0.0.1:6379> eval "redis.call('SET', KEYS[1], ARGV[1]);redis.call('EXPIRE', KEYS[1], ARGV[2]); return 1;" 1 test 10 60
(integer) 1
127.0.0.1:6379> ttl test
(integer) 59
127.0.0.1:6379> get test
"10"

注：

    {}在lua里是指数据类型table，类似数组。
    redis.call()可以调用redis命令。

命令行里使用

如果直接使用redis-cli命令，格式会有点不一样：

redis-cli --eval lua_file key1 key2 , arg1 arg2 arg3

注意的地方：

    eval 后面参数是lua脚本文件,.lua后缀
    不用写numkeys，而是使用,隔开。注意,前后有空格。

示例：

incrbymul.lua

local num = redis.call('GET', KEYS[1]);  

if not num then
	return 0;
else
	local res = num * ARGV[1]; 
	redis.call('SET',KEYS[1], res); 
	return res;
end

命令行运行：

$ redis-cli --eval incrbymul.lua lua:incrbymul , 8
(integer) 0
$ redis-cli incr lua:incrbymul 
(integer) 1
$ redis-cli --eval incrbymul.lua lua:incrbymul , 8
(integer) 8
$ redis-cli --eval incrbymul.lua lua:incrbymul , 8
(integer) 64
$ redis-cli --eval incrbymul.lua lua:incrbymul , 2
(integer) 128

由于redis没有提供命令可以实现将一个数原子性的乘以N倍，这里我们就用Lua脚本实现了，运行过程中确保不会被其它客户端打断。
phpredis里使用

接着上面的例子：

incrbymul.php

<?php 

$lua = <<<EOF
local num = redis.call('GET', KEYS[1]);  

if not num then
	return 0;
else
	local res = num * ARGV[1]; 
	redis.call('SET',KEYS[1], res); 
	return res;
end

EOF;

$redis = new Redis();
$redis->connect('127.0.0.1', 6379);
$ret = $redis->eval($lua, array("lua:incrbymul", 2), 1);
echo $ret;

运行：

$ redis-cli set lua:incrbymul 0
OK
$ redis-cli incr lua:incrbymul
(integer) 1
$ php incrbymul.php 
2
$ php incrbymul.php 
4

eval原型：

Redis::eval(string script, [array keys, long num_keys])

eval函数的第3个参数为KEYS个数，phpredis依据此值将KEYS和ARGV做区分。

    12- Lua脚本学习--Ngx_lua

简介

ngx_lua 指的是 lua-nginx-module模块：通过将 LuaJIT 的虚拟机嵌入到 Nginx 的 worker 中，这样既保持高性能，又能不失去lua开发的简单特性。

OpenResty 就是一个基于 Nginx 与 Lua 的高性能 Web 平台，其内部集成了大量精良的 Lua 库、第三方模块以及大多数的依赖项。OpenResty 基于Nginx开发，可以简单认为是 Nginx + lua-nginx-module的组合版。

官网：https://openresty.org/cn/
官方文档：https://github.com/openresty/lua-nginx-module
Hello World
OpenResty 安装

以 CentOS 为例：

mkdir /opt && cd /opt

# download openresty
wget https://openresty.org/download/openresty-1.13.6.2.tar.gz

tar zxvf openresty-1.13.6.2.tar.gz
cd openresty-1.13.6.2

# configure
./configure --prefix=/usr/local/openresty -j4

make -j4 && make install

其中 源码包可以到 https://openresty.org/cn/download.html 该页面获取。 -j4表示使用4核。configure那一步还可以指定各种参数：

./configure --prefix=/usr/local/openresty \
            --with-luajit \
            --without-http_redis2_module \
            --with-http_iconv_module \
            --with-http_postgres_module

使用 ./configure --help 查看更多的选项。

其它系统环境上安装可以参考 https://openresty.org/cn/installation.html 。

其实安装 OpenResty 和安装 Nginx 是类似的，因为 OpenResty 是基于 Nginx 开发的。

如果已经安装了 Nginx，又想使用 OpenResty 的功能，可以参考 《Nginx编译安装Lua》：https://www.cnblogs.com/52fhy/p/10164553.html 一文安装lua-nginx-module模块即可。
第一个程序

修改 /usr/local/openresty/nginx/conf/nginx.conf:

worker_processes  1;
error_log logs/error.log;
events {
    worker_connections 1024;
}
http {
    server {
        listen 8080;
        location /hello {
            default_type text/html;
            content_by_lua '
                ngx.say("<p>hello, world</p>")
            ';
        }
    }
}

把默认的80端口改为8080，新增/hello部分。

其中content_by_lua便是 OpenResty 提供的指令，在官方文档可以搜索到：

现在我们启动OpenResty：

/usr/local/openresty/nginx/sbin/nginx

启动成功后，查看效果：

curl http://127.0.0.1:8080/hello
<p>hello, world</p>

说明成功运行了。

    lua 基础
        概述

概述

Lua 是用 C 语言开发的可扩展的轻量级编程语言。它起源于 1993 年由 Roberto lerusalimschy,Luiz Henrique de Figueiredo 与 Waddemar Celes 领导的一个内部项目。
设计者的初衷是希望 Lua 可以成为一款整合 C 语言代码以及其它传统语言代码的软件。这种整合会带来很多好处，它让你不需要重复做 C 语言已经做的很好的工作，
而专注于提供那些 C 语言不擅长的特性：提供更高的抽象（离硬件更远）、动态结构、无冗余、易于测试与调试。
为了提供这些特性，Lua 提供了安全的环境、动态内存管理，以及擅长处理字符串和其它动态大小数据结构的工具。
特点

Lua 有着许多自身的特点使得它与其它编程语言不同。主要包括：

    可扩展性
    简单
    高效
    跨平台
    自由与开放

示例代码

print("Hello World!")

Lua 是如何实现的

Lua 主要包括两个部分：Lua 解释器部分以及运行软件系统。 运行软件系统是真正解释执行由 Lua 语言编写的程序的应用程序
（译注：此处 Lua 解释器部分用于将 Lua代码编译成中间字节码，运行软件系统指 Lua 虚拟机，而一般我们所说 Lua 解释器包括这两部分）。 
Lua 解释器是由 ANSI C 编写的，因此它有很好的可移植性，可以运行各种各运的设备上，无论是大型网络服务器还是小型移动设备。

无论 Lua 语言还是 Lua 解释器都已经是非常成熟的、同时还兼备体积小，运行速度非常快的特点。小体积的特性也使得 Lua 可以运行在很多只有少量内存的小型设备中。
学习 Lua

学习 Lua 语言最重要的一点是把注意力放在它的概念上，千万不要迷失在语言的技术细节中。
学习 Lua 的目的是成为一个更好的程序人员。也就是说，学习 Lua 可以帮助您在设计与实现新系统，或者维护旧系统的时候变得更加的高效。
Lua 的应用场景

    游戏开发
    开发单机应用
    网站开发
    扩展数据库或者为数据库开发插件，比如，MySQL 代理或 MySQL WorkBench
    开发安全系统，如入侵检测系统（IDS）

        运行环境

Lua 运行环境
本地环境搭建

在本地搭建 Lua 编程语言的开发运行环境，你需要在你的计算机上安装如下三个软件：(1) 文本编辑器。(2) Lua 解释器。（3）Lua 编译器。
文本编辑器

文本编辑器用来编辑你的程序代码。有如下几款常用的文本编辑器软件：Windows notepad、Brief、Epsilon、EMACS、vim/vi。

在不同的操作系统中有各自不同的编辑器，而且编辑器的版本不一样。例如，Notepad 主要用在 Windows 系统中，vim/vi 不仅可以用于 Windows 系统也可以用于 Linux 和 UNIX 操作系统。

用文本编辑器编辑的文件被称为源文件。源文件中包含程序的源代码。Lua 程序的源文件经常以 .lua　作为其后缀名。

开始编写程序之前，请确保您已经安装好一个文本编辑软件，并且曾经有过写代码，将其存入文件，生成并执行的经验。
Lua 解释器

Lua 解释器是一个能让您输入 Lua　命令并立即执行的小程序。它在执行一个　Lua 文件过程中，一旦遇到错误就立即停止执行，而不像编译器会执行完整个文件。
Lua 编译器

如果将 Lua 扩展到其它语言或者应用中时，我们需要一个软件开发工具箱以及 Lua 应用程序接口兼容的编译器。
在 Windows 系统安装 Lua

在 Windows 系统环境可以安装一个叫 SciTE 的 Lua 开发 IDE (集成开发环境)。它可以在这儿下载：http://code.google.com/p/luaforwindows。

运行下载的可执行程序就可安装 Lua 语言的 IDE 了。

在这个 IDE 上，你可以创建并生成 Lua 代码。

如果你希望在命令行模式下安装 Lua，你则需要安装 MinGW 或者 Cygwin，然后在 Ｗindows 系统中编译安装 Lua。
在 Linux 系统安装 Lua

使用下面的命令下载并生成 Lua 程序：

$ wget http://www.lua.org/ftp/lua-5.2.3.tar.gz
$ tar zxf lua-5.2.3.tar.gz
$ cd lua-5.2.3
$ make linux test

在其它系统上安装 Lua 时，比如 aix，ansi，bsd，generic，linux，mingw，posix，solaris，你需要将 make linux test 命令中的 linux 替换为相应的系统平台名称。

假设我们已经有一个文件 helloWord.lua ，文件内容如下：

print("Hello World!")

我们先使用 cd 命令切换至 helloWord.lua　文件所在的目录，然后生成并运行该文件：　　

$ lua helloWorld

执行上面的命令，我们可以看到如下的输出：

Hello World!

在 Mac OS X 系统安装 Lua

使用下面的命令可以在 Mac OS X 系统生成并测试 Lua：

$ curl -R -O http://www.lua.org/ftp/lua-5.2.3.tar.gz
$ tar zxf lua-5.2.3.tar.gz
$ cd lua-5.2.3
$ make macosx test

如果你没有安装 Xcode 和命令行工具，那么你就不能使用 make 命令。你先需要从 mac 应用商店安装 Xcode，然后在 Xcode 首选项的下载选项中安装命令行工具组件。完成上面的步骤后，你就可以使用 make 命令了。
make macosx test 命令并不是非执行不可的。即使你没有执行这个命令，你仍可以在你的 Mac OS X 系统中使用 Lua。

假设我们已经有一个文件 helloWord.lua ，文件内容如下：

print("Hello World!")

我们先使用 cd 命令切换至 helloWord.lua　文件所在的目录，然后生成并运行该文件：　　

$ lua helloWorld

执行上面的命令，我们可以看到如下的输出：

Hello World!

Lua IDE

正如前面提到的那样，Windows 系统中 SciTE 是 Lua 创始团队提供的默认的 Lua 集成开发环境（IDE)。 此外，还有一款名叫 ZeroBrane 的 IDE。 它具有跨平台的特性，支持 Windows、Mac 与 Linux。
同时，许多 eclipse 插件使得 eclipse 能成为 Lua 的 IDE。IDE 中像代码自动补全等诸多特性使得开发变得简单了很多，因此建议你使用 IDE 开发 Lua 程序。同样，IDE 也能像 Lua 命令行版本那样提供交互式编程功能。

        基本语法

基本语法

Lua 学起来非常简单。现在，让我们开始创建我们的第一个 Lua 程序吧！
第一个 Lua 程序

Lua 提供交互式编程模式。在这个模式下，你可以一条一条地输入命令，然后立即就可以得到结果。你可以在 shell 中使用 lua -i 或者 lua 命令启动。输入命令后，按下回车键，就启动了交互模式，显示如下：

$ lua -i 
$ Lua 5.1.4  Copyright (C) 1994-2008 Lua.org, PUC-Rio
quit to end; cd, dir and edit also available

你可以使用如下命令打印输出：

$> print("test")

按下回车键后，你会得到如下输出结果：

'test'

默认模式编辑

使用 Lua 文件做为解释器的参数启动解释器,然后开始执行文件直到文件结束。当脚本执行结束后，解释器就不在活跃了。

让我们写一个简单的 Lua 程序。所有的 Lua　文件都扩展名都是.lua。因此，将下面的源代码放到 test.lua 文件中。

print("test")

假如你已经设置好 Lua 程序的环境，用下面的命令运行程序：

$ lua test.lua

我们会得到如下的输出结果：

test

让我们尝试使用另外的方式运行 Lua 程序。下面是修改后的 test.lua 文件：

#!/usr/local/bin/lua
print("test")

这里，我们假设你的 Lua 解释器程序在 /usr/local/bin/lua 目录下。test.lua 文件中第一行由于以 # 开始而被解释器忽略，运行这个程序可以得到如下的结果：

$ chmod a+rx test.lua
$./test.lua

我们会得到如下的的输出结果：

test

接下来让我们看一下 Lua 程序的基本结构。这样，你可以更容易理解 Lua 编程语言的基本结构单元。
Lua 中的符号

Lua 程序是由大量的符号组成的。这些符号可以分为关键字、标识符、常量、字符串常量几类。例如，下面的 Lua 语句中包含三个符号：

io.write("Hello world, from ",_VERSION,"!\n")

这三个符号分别是:

io.write
(
"Hello world, from ",_VERSION,"!\n"
)

注释

注释就是 Lua 程序中的帮助文档，Lua 解释器会自动忽略它们。所有注释都以 --[[ 开始，并以 --]]结束。如下所示：

--[[ my first program in Lua --]]

标识符

Lua 中标识符是识别变量、函数或者其它用户自定义项的名字。标符识总是以字母或者下划线开始，其后可以是零个或多个字母、下划线或数字。
Lua 标识符中不允许出现任何标点符号，比如，@，$ 或者 %。Lua 是大小写敏感的语言，因此 Manpower 和 manpower 是 Lua 中两个不同的标识符。下面所列的是一些合法标识符的例子。

mohd         zara      abc     move_name    a_123
myname50     _temp     j       a23b9        retVal

关键字

下面列表中所示的是 Lua 中一小部分保留字。这些保留字不能用作常量、变量以及任何标识符的名字。
and 		break 	do 	else
elseif 		end 	false 	for
function 	if 	in 	local
nil 		not 	or 	repeat
return 		then 	true 	until
while 			
Lua 中的空白符

如果 Lua 程序中某一行只包含空格或者注释，那么这样的一行被称之为空行。 Lua 解释器将完全忽略这一行。
在 Lua 中，空白是用来描述空格、制表符、换行符和注释的术语。空白符用于将语句中的一部分与其它部分区分开，使得解释器可以语句中的一个元素，比如 int，何处结束，以及另一个元素从何处开始。
因此，在下面的语句中：

local age

在 local 与 age 之间至少有一个空白符（通常是空格）,这个空白符使得解释器可以将 local 与 age 区分开。
另一方面，在下面的语句中：

fruit = apples + oranges   --get the total fruit

fruit 与 = 之间以及 = 与 apples 之间的空白符都是可以没有的。但是为了程序的可读性目的，建议你在它们之间使用空白符。

        变量

变量

变量就是给一块内存区域赋予的一个名字。变量使得在程序中就可以修改或读取相应的内存区域中的内容。它可以代表各种不同类型的值，包括函数与表。

变量的名字由字母、数字与下划线组成。它必须是字母或下划线开头。由于 Lua 是字母大小写敏感的，所以大写字母与小写字母是不一样的。Lua 中有八种基本值类型：

在 Lua 语言中，虽然我们没有变量数据类型，但是依据变量的作用域我们可以将变量分为三类：

    全局变量：除非显示的声明一个局部变量，否则所有的变量都被默认当作全局变量。
    局部变量：如果我们将一个变量定义为局部变量，那么这么变量的作用域就被限制在函数内。
    表字段：这种特殊的变量可以是除了 nil 以外的所有类型，包括函数。

Lua 变量定义

一个变量定义就意味着告诉解释器在什么地方创建多大的一块存储空间。一个变量定义包括一个可选的类型( type )以及该类型的一个或多个变量名的列表，如下所示：

type variable_list;

其中，type 是可以选择指定为 local 或者不指定使用默认值 global，variable_list 是包含一个或多个由逗号分隔的标识符名字。下面是合法变量定义的示例：

local    i, j
local    i
local    a,c

local i,j 声明定义了两个变量 i 与 j；它命令解释器创建两个名称分别为 i,j 的变量，并且将其作用域限制在局部。

在声明变量的时候可以同时初始化变量（为变量赋初值）。在变量名后跟上等号和一个常量表达式就可以初始化变量。如下所示：

type variable_list = value_list;

一些例子如下：

local d , f = 5 ,10 --声明局部变量 d，f。 
d , f = 5, 10;      --声明全局变量 d，f。 
d, f = 10           --[[声明全局变量 d，f，其中 f 的值是 nil--]]

如果只是定义没有初始化，则静态存储变量被隐式初始化为 nil。
Lua 变量声明

正如在上面例子看到的那样，为多个变量赋值就是在变量列表后跟上值列表。例子 local d，f = 5，10 中,变量列表是 d，f，值列表是 5，10。

Lua 赋值时会将第一个值赋给第一个变量，第二个值赋给第二个变量，依次类推。所以，d 的值是 5,f 的值是 10。
示例

下面的示例中，变量被声明在顶部，但是它们在主函数中定义和初始化:

-- 变量定义:
local a, b
-- 初始化
a = 10
b = 30
print("value of a:", a)
print("value of b:", b)
-- 交换变量的值
b, a = a, b
print("value of a:", a)
print("value of b:", b)
f = 70.0/3.0
print("value of f", f)

上面的代码被编译生成和执行后，会产生如下的结果：

value of a:	10
value of b:	30
value of a:	30
value of b:	10
value of f	23.333333333333

Lua 中的左值与右值

Lua　中有两种表达式：

    左值：引用内存位置的表达式被称之为左值表达式。左值表达式既可以出现在赋值符号的左边也可以出现在赋值符号的右边。
    右值：术语“右值”指存在内存某个位置的数据值。我们不能为右值表达式赋值，也就是说右值表达式只可能出现在赋值符号的右边，而不可能出现在赋值符号的左边。

变量属于左值表达式，所以它可以现在赋值符号的左边。数值常量属于右值表达式，它不能被赋值也不能出现在赋值符号的左边。下面是合法的语句：

g = 20

但是，下面的语句是非法的，它会产生生成时错误：

10 = 20 

在 Lua 语言中，除了上面讲的这种赋值，还允许在一个赋值语句中存在多个左值表达式与多个右值表达式。如下所示：

g,l = 20,30

在这个语句中，g 被赋值为 20，l 被赋值为 30。

        Lua 中的类型

数据类型

Lua 是动态类型编程语言，变量没有类型，只有值才有类型。值可以存储在变量中，作为参数传递或者作为返回值。
尽管在 Lua 中没有变量数据类型，但是值是有类型的。下面的列表中列出了数据类型：
值类型 	描述
nil 	用于区分值是否有数据，nil 表示没有数据。
boolean 	布尔值，有真假两个值，一般用于条件检查。
number 	数值，表示实数(双精度浮点数)。
string 	字符串。
function 	函数，表示由 C 或者 Lua 写的方法。
userdata 	表示任意 C 数据。
thread 	线程，表示独立执行的线程，它被用来实现协程。
table 	表，表示一般的数组，符号表，集合，记录，图，树等等，它还可以实现关联数组。它可以存储除了 nil 外的任何值。
type 函数

Lua　中有一个 type　函数，它可以让我们知道变量的类型。下面的代码中给出了一些例子：　　

print(type("What is my type"))   --> string
t=10
print(type(5.8*t))               --> number
print(type(true))                --> boolean
print(type(print))               --> function
print(type(type))                --> function
print(type(nil))                 --> nil
print(type(type(ABC)))           --> string

在 Linux 系统中运行上面的代码可以得到如下的结果：

string
number
function
function
boolean
nil
string

默认情况下，在被初始化或赋值前，所有变量都指向 nil。 Lua 中空字符串和零在条件检查时，都被当作真。所以你在使用布尔运算的时候要特别注意。在下一章中，我们会了解到更多关于这些类型的知识。

        操作符

操作符

操作符是用于告诉解释器执行特定的数学或逻辑运算的符号。Lua 语言有丰富的内置操作符，主要包括以下几类：

    算术运算操作符
    关系运算操作符
    逻辑运算操作符
    其它操作符

这篇教程将会依次介绍以上四类操作符。
算术去处操作符

下面的表中列出了所有 Lua 语言支持的算术运算操作符。假设 A 变量的值为 10，B 变量的值为 20，则：
操作符 	描述 	示例
+ 	两个操作数据相加 	A + B = 30
- 	第一个操作数减去第二个操作数据 	A - B = 10
* 	两个操作数相乘 	A * B = 200
% 	模除操作符 	A % B = 0
^ 	幂运算符 	A ^ 2 = 100
- 	一元减操作符用于取反 	-A = -10
关系运算符

下面的表列出了 Lua 支持的所有关系运算符。假设 A 的值为 10，B 的值为 20，则：
操作符 	描述 	示例
== 	判断两个操作数是否相等，若相等则条件为真，否则为假。 	(A == B) 为假。
~= 	判断两个操作数是否相等，若不相等则条件为真，否则为假。 	(A ~= B) 为真。
> 	如果左操作数大于右操作数则条件为真，否则条件为假。 	(A > B) 为假。
< 	如果左操作数小于右操作数则条件为真，否则条件为假。 	(A < B) 为真。
>= 	如果左操作数大于或等于右操作数则条件为真，否则条件为假。 	(A >= B) 为假。
<= 	如果左操作数小于或等于右操作数则条件为真，否则条件为假。 	(A <= B) 为真。
逻辑运算符

下面的表列出了 Lua 支持的所有逻辑运算符。假设 A 的值为 真（非零），B 的值为 假（零），则：
操作符 	描述 	示例
and 	逻辑与运算符。如果两个操作数都非零，则条件为真。 	(A and B) 为假。
or 	逻辑或运算符。如果两个操作数中其中有一个非零，则条件为真。 	(A or B) 为真。
not 	逻辑非运算符。翻转操作数的逻辑状态。如果条件是真，则逻辑非运算符会将其变成假。 	!(A and B) 为真。
其它操作符

Lua 语言还支持另外两个操作符：
操作符 	描述 	示例
.. 	连接两个字符串。 	若 a 为 "Hello"，b 为 "World",则 a..b 返回 "Hello World"。
# 	一元运算符，返回字符串或者表的长度。 	#"Hello" 返回 5。
操作符优先级

操作符的优先级将决定表达式中的项如何组合。这会影响到表达式的求值。一些操作符比另外一些操作符有更高的优先级。例如，乘法操作符优先级比加法操作符更高。

例如 x = 7 +3*2，这里 x 的值为 13，而不是 20。这是因为操作符 * 优级级比操作符 + 优先级更高，所以先得到 3*2 的乘积，然后再加上 7。

下面的表中，从上到下优先级递减。在每个表达式中，高优先级操作数先运算。
分类 	操作数 	结合性
一元运算符类 	not # - 	从右至左
连接运算符 	.. 	从右至左
乘除运算符类 	* / % 	从左至右
加减运算符类 	+ - 	从左至右
关系运算符类 	< > <= >= == ~= 	从左至右
等于运算符类 	== ~= 	从左至右
逻辑与运算符 	and 	从左至右
逻辑或运算符 	or 	从左至右

        循环

循环

　 虽然一般情况下，语句都是顺序执行的：函数内的第一条语句先执行，然后是第二条，依次类推。 但是还是可能存在需要执行一段代码多次的情况。

为此编程语言提供各式各样的控制结构实现复杂的程序执行路径。

其中，循环语句可以让我们可以执行一条或一组语句多次。下图中所描述的是大多数语言中循环语句的形式：

Lua 语言提供了如下几种循环结构语句。点击链接可查看详细说明。
循环类型 	描述
while 循环 	先检测条件，条件为真时再执行循环体，直到条件为假时结束。
for 循环 	执行一个语句序列多次，可以简化管理循环变量的代码。
repeat...until 循环 	重复执行一组代码语句，直到 until 条件为真为止。
嵌套循环 	可以在一个循环语句中再使用一个循环语句。
循环控制语句

循环控制语句改变循环正常的执行顺序。当离开一个作用域时，在该作用域内自动创建的对象都会被自动销毁。

Lua 支持如下所示的循环控制语句。点击下面的链接查看详细内容：
循环控制语句 	描述
break 	break 语句结束循环，并立即跳转至循环后的第一条语句处开始执行。
无限循环

如果循环条件永远不可能为假，则此循环为无限循环。while 语句经常被当作无限循环语句使用。因为我们可以直接将其条件设置为真，这样 while 就会一直循环下去。在无限循环中，可以使用 break 跳出循环。

while( true )
do
   print("This loop will run forever.")
end


        决策

决策

决策结构要求程序开发人员设置一个或多测试或计算条件。如果条件计算结果为真，则执行一个或多个语句；如果条件为假，则执行另外的语句。

下面是大多数程序语言中的决策结构的一般形式：

Lua 语言中所有布尔真和非 nil 值都当作真；把所有的布尔假和 nil 作为假。请注意，Lua 中的零会被当作真，而其它大部分语言会将零当作假。

Lua 语言提供了如下几类决策语句。点击下面的链接查看详细内容。
语句 	描述
if 语句 	if 语句中包括一个布尔表达式和一个或多个语句。
if...else 语句 	if 语句也可以选择和 esle 语句一起使用。当条件为假时，则执行 else 语句。
嵌套 if 语句 	在 if 语句或者 else if 语句内使用　if 或者 else if。

        函数

Lua 函数

函数用于将一组语句组合起来完成一个任务。你可以将你的代码分割到不同的函数中。如何将你的代码分到不同的函数中完全由你自己决定，不过一般会按照逻辑功能进行划分，每个函数都执行一个特定的任务。

在 Lua 中提供了大量的内置函数供我们使用。例如，print() 函数用于将输入的参数输出到终端。

函数往往也被称作方法，子例程或过程等等。
函数定义

Lua 中函数定义的语法如下所示：　　

optional_function_scope function function_name( argument1, argument2, argument3..., argumentn)
function_body
return result_params_comma_separated
end

Lua 中函数定义包括函数头和函数名两部分。如下列出函数的所有部分：

    可选的函数作用域：你可以使用关键字 local 限制函数的作用域，你也可以忽略此部分而使用默认值。函数作用域默认是全局。
    函数名：函数的真正名称。函数名与函数的参数列表一起被称为函数签名。
    参数：一个参数就一个占位符一样。函数调用时，把值传递给参数。这个值被称之为实际参数或直参数。参数列表指参数的类型，顺序与数量。参数是可选的，一个函数可以没有参数。
    函数体：函数体是代码语句集合，定义了函数的功能。
    返回：在 Lua 中，可以使用 return 关键字同时返回多返回值，每个返回值之间使用逗号分隔。

示例

下面是函数 max() 源代码。此函数接受两个参数 num1 与 num2，返回两个输入参数的最大值。

--[[ function returning the max between two numbers --]]
function max(num1, num2)
   if (num1 > num2) then
      result = num1;
   else
      result = num2;
   end

   return result; 
end

函数参数

如果函数需要用到参数，则它必须声明接受参数值的变量。这些被声明的变量被称为函数的形式参数或简称形参。

函数的形参与函数中其它局部变量一样，在函数的入口处被创建，函数结束时被销毁。
调用函数

创建函数的时候，我们已经定义了函数做什么。接下来，我们就可以调用函数来完成已定义的任务或功能。

当程序中调用一个函数时，程序的控制转移到被调用的函数中。被调用的函数执行定义的任务；当 return 语句被执行或者到达函数末尾时，程序的控制回到主程序中。

调用函数的方法很简单，你只需要将函数要求的参数传递给函数就可以实现函数的调用。如果函数有返回值，你也可以将函数的返回值存储下来。如下如示：

function max(num1, num2)
   if (num1 > num2) then
      result = num1;
   else
      result = num2;
   end

   return result; 
end

-- 调用函数
print("The maximum of the two numbers is ",max(10,4))
print("The maximum of the two numbers is ",max(5,6))

执行上面的代码，可以得到如下的输出结果：

The maximum of the two numbers is 	10
The maximum of the two numbers is 	6

赋值与传递函数

在 Lua 语言中，我们可以将函数赋值给一个变量，也可以将函数作为参数传递给另外一个函数。下面是赋值传递函数的一个例子：

myprint = function(param)
   print("This is my print function -   ##",param,"##")
end

function add(num1,num2,functionPrint)
   result = num1 + num2
   functionPrint(result)
end
myprint(10)
add(2,5,myprint)

执行上面的代码，可以得到如下的输出结果：

This is my print function -   ##	10	##
This is my print function -   ##	7	##

变参函数

在 Lua 语言中，使用 ... 作为参数可以创建参数个数可变的函数，即变参函数。我们可以使用下面的这个例子来理解变参函数的概念。下面的这个例子中函数返回输入参数的平均值：

function average(...)
   result = 0
   local arg={...}
   for i,v in ipairs(arg) do
      result = result + v
   end
   return result/#arg
end

print("The average is",average(10,5,3,4,5,6))

执行上面的代码，可以得到如下的输出结果：

The average is	5.5

        字符串

Lua 字符串

字符串就是一个由字符或控制字符组成的序列。字符串可以用以下三种方式任意一种进行初始化。

    单引号字符串
    双引号字符串
    [[和]]之间的字符串

上面三种初始化方式的示例如下：

string1 = "Lua"
print("\"String 1 is\"",string1)
string2 = 'Tutorial'
print("String 2 is",string2)

string3 = [["Lua Tutorial"]]
print("String 3 is",string3)

运行上面的程序，我们可以得到如下的输出结果：

"String 1" is	Lua
String 2 is	Tutorial
String 3 is	"Lua Tutorial"

字符串中转义字符用于改变字符的一般正常的解释。在上面的例子中，输出双引号（""）的时候，我们使用的是 "。下表列出了转义序列及相应的使用方法：
转义序列 	用法
\a 	响铃
\b 	退格
\f 	换页
\n 	换行
\r 	回车
\t 	制表符
\v 	垂直制表符
\\ 	反斜线
\" 	双引号
\' 	单引号
\[ 	左方括号
\] 	右方括号
字符串操作

Lua 支持如下的字符串操作方法：
S.N. 	函数及其功能
1 	string.upper(argument):将输入参数全部字符转换为大写并返回。
2 	string.lower(argument):将输入参数全部字符转换为小写并返回。
3 	string.gsub(maingString,findString,replaceString):将 mainString 中的所有 findString 用 replaceString 替换并返回结果。
4 	string.find(mainString,findString,optionalStartIndex,optionalEndIndex):在主字符串中查找 findString 并返回 findString 在主字符串中的开始和结束位置，若查找失败则返回 nil。
5 	string.reverse(arg):将输入字符串颠倒并返回。
6 	string.format(...):返回格式化后的字符串。
7 	string.char(arg) 和 string.byte(arg):前者返回输出参数的所代表的字符，后者返回输入参数（字符）的数值。
8 	string.len(arg):返回输入字符串的长度。
9 	string.rep(string,n): 将输入字符串 string 重复 n　次后的新字符串返回。
10 	..:连接两个字符串。

接下来我们用一些例子来讲解如何使用上面这些函数。
大小写操作函数

下面的代码将字符串中字符全部转换成大写或小写：

string1 = "Lua";
print(string.upper(string1))
print(string.lower(string1))

执行上面的代码可以得到如下的输出结果：

LUA
lua

替换子串

用一个字符串替换字符串的某子串的示例代码如下：

string = "Lua Tutorial"
-- 替换字符串
newstring = string.gsub(string,"Tutorial","Language")
print("The new string is",newstring)

执行上面的代码可以得到如下的输出结果：

The new string is	Lua Language

查找与颠倒

查找一个子串的索引与颠倒一个字符串函数的示例代码如下所示：

string = "Lua Tutorial"
-- 替换字符串
print(string.find(string,"Tutorial"))
reversedString = string.reverse(string)
print("The new string is",reversedString)

执行上面的代码可以得到如下的输出结果：

5	12
The new string is	lairotuT auL

格式化字符串

在编程过程中，我们经常需要将字符串以某种格式输出。此时，你就可以使用 string.format 函数格式化你的输出内容。如下所示：

string1 = "Lua"
string2 = "Tutorial"
number1 = 10
number2 = 20
-- 基本字符串格式
print(string.format("Basic formatting %s %s",string1,string2))
-- 日期格式化
date = 2; month = 1; year = 2014
print(string.format("Date formatting %02d/%02d/%03d", date, month, year))
-- 符点数格式化
print(string.format("%.4f",1/3))

执行上面的代码可以得到如下的输出结果：

Basic formatting Lua Tutorial
Date formatting 02/01/2014
0.3333

字符与字节表示

字节表示函数用于将字符的内部表示转换为字符表示，而字符表示函数正好相反。 示例代码如下：

-- 字节转换
-- 第一个字符
print(string.byte("Lua"))
-- 第三个字符
print(string.byte("Lua",3))
-- 倒数第一个字符
print(string.byte("Lua",-1))
-- 第二个字符
print(string.byte("Lua",2))
-- 倒数第二个字符
print(string.byte("Lua",-2))

-- 内部 ASCII 字值转换为字符
print(string.char(97))

执行上面的代码可以得到如下的输出结果：

76
97
97
117
117
a

其它常用函数

其它常用的字符串处理函数包括字符串连接，字符串长度函数以及重复字符串多次的函数。它们的使用方法示例如下：

string1 = "Lua"
string2 = "Tutorial"
-- 用 .. 连接两个字符串
print("Concatenated string",string1..string2)

-- 字符串的长度
print("Length of string1 is ",string.len(string1))

-- 重复字符串
repeatedString = string.rep(string1,3)
print(repeatedString)

执行上面的代码可以得到如下的输出结果：

Concatenated string	LuaTutorial
Length of string1 is 	3
LuaLuaLua


        数组

Lua 数组

数组是一组有序的对象排列，既可以是一维的也可以是多维的。

在 Lua 语言中，数组是用整数索引表实现的。数组的大小并不固定，随着数组元素的增加，它可以动态地增加内存空间大小。
一维数组

一维数组可以使用一个简单的表结构表示。可以通过一个简单循环初始化数组或者读取数组中数据。示例代码如下所示：

array = {"Lua", "Tutorial"}

for i= 0, 2 do
   print(array[i])
end

执行上面的代码可以得到如下的输出结果：

nil
Lua
Tutorial

从上面的例子中可以看出，当我们尝试着访问数组中一个不存在的索引时，会得到 nil 值。 Lua 语言与 C 语言不同，Lua 数组的索引是从 1 开始的，而 C 语言中索引是从 0 开始的。
不过呢，你也可以在索引值为 0 或小于 0 的位置创建对象。下面的代码演示了如何使用负索引值创建并初始化数组：

array = {}

for i= -2, 2 do
   array[i] = i *2
end

for i = -2,2 do
   print(array[i])
end

执行上面的代码可以得到如下的输出结果：

-4
-2
0
2
4

多维数组

多维数组有以下两种实现方式：

    数组的数组（译注：数组的每一个元素是一个数组）。
    修改一维数组的索引值（译注：将多维数组映射到一维数组中）。

使用方法一创建 3x3 的二维数组：

-- 初始化数组
array = {}
for i=1,3 do
   array[i] = {}
      for j=1,3 do
         array[i][j] = i*j
      end
end

-- 访问数组元素
for i=1,3 do
   for j=1,3 do
      print(array[i][j])
   end
end

执行上面的代码可以得到如下的输出结果：

1
2
3
2
4
6
3
6
9

通过修改数组的的索引值实现 3x3 的二维数组，示例代码如下:

-- 初始化数组
array = {}
maxRows = 3
maxColumns = 3
for row=1,maxRows do
   for col=1,maxColumns do
      array[row*maxColumns +col] = row*col
   end
end

-- 访问数组元素
for row=1,maxRows do
   for col=1,maxColumns do
      print(array[row*maxColumns +col])
   end
end

执行上面的代码可以得到如下的输出结果：

1
2
3
2
4
6
3
6
9

正如从上面例子中所看到的那样，数组中数据是基于索引存储的。这使得数组可以以稀疏的方式存储，这也是 Lua 矩阵的存储方式。正是因为 Lua 中不会存储 nil 值，所以 Lua　不需要使用任何特殊的技术就可以节约大量的空间，这一点在其它语言中是做不到的。

        迭代器

Lua 迭代器

迭代器是用于遍历集合或容器中元素的一种结构。在 Lua 语言中，集合往往指的是可以用来创建各种数据结构的表。比如，数组就是用表来创建的。

泛型 for 迭代器
泛型 for 在自己内部保存迭代函数，实际上它保存三个值：迭代函数、状态常量、控制变量。
下面我们看看泛型 for 的执行过程：

首先，初始化，计算 in 后面表达式的值，表达式应该返回泛型 for 需要的三个值：迭代函数、状态常量、控制变量；与多值赋值一样，如果表达式返回的结果个数不足三个会自动用 nil 补足，多出部分会被忽略。
第二，将状态常量和控制变量作为参数调用迭代函数（注意：对于 for 结构来说，状态常量没有用处，仅仅在初始化时获取他的值并传递给迭代函数）。
第三，将迭代函数返回的值赋给变量列表。
第四，如果返回的第一个值为nil循环结束，否则执行循环体。
第五，回到第二步再次调用迭代函数

通用迭代器

通用迭代器可以访问集合中的键值对。下面是通用迭代器的一个简单例子：

array = {"Lua", "Tutorial"}

for key,value in ipairs(array) 
do
   print(key, value)
end

执行的上面的代码，我们可以得到如下的输出结果：

1  Lua
2  Tutorial

上面的例子中使用了 Lua 提供的默认迭代器函数 ipairs。

在 Lua 语言中，我们使用函数表示迭代器。根据是否在迭代器函数中是否维护状态信息，我们将迭代器分为以下两类：

    无状态迭代器
    有状态迭代器

无状态迭代器

由此迭代器的名称就可以看出来，这一类的迭代器函数中不会保存任何中间状态。

让我们一起来看一下下面这个例子。在这个例子中，我们用一个简单的函数创建了一个自己的迭代器。这个迭代器用以输出 n 个数的平方值。

function square(iteratorMaxCount,currentNumber)
   if currentNumber<iteratorMaxCount
   then
      currentNumber = currentNumber+1
   return currentNumber, currentNumber*currentNumber
   end
end

for i,n in square,3,0
do
   print(i,n)
end

执行上面的代码，我们可以得到如下的输出结果：

1	1
2	4
3	9

我们可以稍微的修改一下上面的代码，使得此迭代器可以像 ipairs 那样工作。如下所示：

function square(iteratorMaxCount,currentNumber)
   if currentNumber<iteratorMaxCount
   then
      currentNumber = currentNumber+1
   return currentNumber, currentNumber*currentNumber
   end
end

function squares(iteratorMaxCount)
   return square,iteratorMaxCount,0
end  

for i,n in squares(3)
do 
	print(i,n)
end

执行上面的代码，我们可以得到如下的输出结果：

1	1
2	4
3	9

有状态迭代器

前面的例子使用的迭代器函数是不保存状态的。每次调用迭代器函数时，函数基于传入函数的第二个变量访问集合的下一个元素。在 Lua 中可以使用闭包来存储当前元素的状态。闭包通过函数调用得到变量的值。
为了创建一个新的闭包，我们需创建两个函数，包括闭包函数本身和一个工厂函数，其中工厂函数用于创建闭包。

下面的示例中，我们将使用闭包来创建我们的迭代器。

array = {"Lua", "Tutorial"}

function elementIterator (collection)
   local index = 0
   local count = #collection
   -- 返回闭包函数
   return function ()
      index = index + 1
      if index <= count
      then
         -- 返回迭代器的当前元素
         return collection[index]
      end
   end
end

for element in elementIterator(array)
do
   print(element)
end

执行上面的代码，我们可以得到如下的输出结果：

Lua
Tutorial

上面的例子中我们可以看到，在　elementIterator 函数内定义了另外一个匿名函数。此匿名函数中使用了一个外部变量 index (译注：此变量在匿名函数之外，elementIterator 函数内)。每次内部的匿名函数被调用时，都会将 index 的值增加 1，并统计数返回的每个元素。

我们可以参照上面的方法使用闭包创建一个迭代器函数。每次我们使用迭代器遍历集合时，它都可以返回多个元素。

        表

Lua 表

在 Lua 语言中，表是唯一可以用来创建不同数据类型的数据结构，比如常见的数组和字典都是用表来创建的。 Lua 语言中经常到关联数组这种数据类型，它不仅可以用数值作为索引值，除了 nil 以外的字符串同样可以作为其索引。表没有固定的大小，当数据量增加时表会自动增大。

Lua 语言中的各种结构表示都用到了表，包括包（package）的表示。当我们使用方法 string.format 时，我们用到的其实是包 string 中的方法 format。
使用表

表被称之为对象，它既不是值也不是变量。Lua 用构造表达式 {} 创建一个空表。需要注意的是，在存储表的变量和表本身之间没有什么固定的对应关系（译注：一个表可以被不同的变量引用，一个变量也可以随时改变其所引用的表对象）。

--简单的表初始化
mytable = {}

--简单的表赋值
mytable[1]= "Lua"

--移除引用
mytable = nil
-- lua 的垃圾回收机制负责回收内存空间

当我们有一个拥有一系列元素的表时，如果我们将其赋值给 b。那么 a 和 b 都会引用同一个表对象(a 先引用该表)，指向相同的内存空间。而不会再单独为 b 分配内存空间。即使给变量 a 赋值 nil，我们仍然可以用变量 b 访问表本身。如果已经没有变量引用表时，Lua　语言垃圾回收机制负责回收不再使用的内存以被重复使用。

下面的示例代码使用到了上面提到的表的特性。　　

-- 声明空表
mytable = {}
print("Type of mytable is ",type(mytable))

mytable[1]= "Lua"
mytable["wow"] = "Tutorial"
print("mytable Element at index 1 is ", mytable[1])
print("mytable Element at index wow is ", mytable["wow"])

-- alternatetable 与 mytable 引用相同的表
alternatetable = mytable

print("alternatetable Element at index 1 is ", alternatetable[1])
print("mytable Element at index wow is ", alternatetable["wow"])

alternatetable["wow"] = "I changed it"

print("mytable Element at index wow is ", mytable["wow"])

-- 只是变量被释放，表本身没有被释放
alternatetable = nil
print("alternatetable is ", alternatetable)

-- mytable 仍然可以访问
print("mytable Element at index wow is ", mytable["wow"])

mytable = nil
print("mytable is ", mytable)

执行上面的代码，我们可以得到如下的输出结果：

Type of mytable is 	table
mytable Element at index 1 is 	Lua
mytable Element at index wow is 	Tutorial
alternatetable Element at index 1 is 	Lua
mytable Element at index wow is 	Tutorial
mytable Element at index wow is 	I changed it
alternatetable is 	nil
mytable Element at index wow is 	I changed it
mytable is 	nil

表的操作函数

下面的表中列出了 Lua 语言内置的表操作函数，具体内容如下所示：
S.N. 	方法与作用
1 	table.concat(table[, sep [, i[,j]]]): 根据指定的参数合并表中的字符串。具体用法参考下面的示例。
2 	table.insert(table,[pos,]value):在表中指定位置插入一个值。
3 	table.maxn(table)：返回表中最大的数值索引。
4 	table.remove(table[,pos]):从表中移出指定的值。
5 	table.sort(table[,comp]):根据指定的（可选）比较方法对表进行排序操作。

让我们一起看一些上述函数使用的例子。
表连接操作

我们可以使用表连接操作连接表中的元素，如下所示。

fruits = {"banana","orange","apple"}
-- 返回表中字符串连接后的结果
print("Concatenated string ",table.concat(fruits))

--用字符串连接
print("Concatenated string ",table.concat(fruits,", "))

--基于索引连接 fruits 
print("Concatenated string ",table.concat(fruits,", ", 2,3))

执行上面的代码，我们可以得到如下的输出结果：

Concatenated string 	bananaorangeapple
Concatenated string 	banana, orange, apple
Concatenated string 	orange, apple

插入与移出操作

插入和移除表中元素是对表最常见的操作。使用方法如下所示：

fruits = {"banana","orange","apple"}

-- 在 fruits 的末尾插入一种水果
table.insert(fruits,"mango")
print("Fruit at index 4 is ",fruits[4])

-- 在索引 2 的位置插入一种水果
table.insert(fruits,2,"grapes")
print("Fruit at index 2 is ",fruits[2])

print("The maximum elements in table is",table.maxn(fruits))

print("The last element is",fruits[5])
table.remove(fruits)
print("The previous last element is",fruits[5])

执行上面的代码，我们可以得到如下的输出结果：

Fruit at index 4 is 	mango
Fruit at index 2 is 	grapes
The maximum elements in table is	5
The last element is	mango
The previous last element is	nil

表排序操作

在程序开发过程中，常常有对表排序的需求。 sort 函数默认使用字母表对表中的元素进行排序（可以通过提供比较函数改变排序策略）。示例代码如下：

fruits = {"banana","orange","apple","grapes"}
for k,v in ipairs(fruits) do
print(k,v)
end
table.sort(fruits)
print("sorted table")
for k,v in ipairs(fruits) do
print(k,v)
end

执行上面的代码，我们可以得到如下的输出结果：

1	banana
2	orange
3	apple
4	grapes
sorted table
1	apple
2	banana
3	grapes
4	orange


        模块

Lua 模块
什么是模块？

Lua 中的模块与库的概念相似，每个模块都有一个全局唯一名字，并且每个模块都包含一个表。使用一个模块时，可以使用 require 加载模块。模块中可以包括函数和变量，所有这些函数和变量被表存储于模块的表中。模块中的表的功能类似于命名空间，用于隔离不同模块中的相同的变量名。在使用模块的时候，我们应该遵守模块定义的规范，在 require 加载模块时返回模块中的包含函数和变量的表对象。
Lua 模块的特别之处

模块中表的使用使得我们可在绝大多数情况下可以像操作其它表一样操作模块。由于 Lua 语言允许对模块本身进行操作，所以 Lua 也就具备了许多其它语言需要特殊机制才能实现的特殊性质。例如，这种自由的表操作机制使得编程人员可以用多种方法调用模块中的函数。下面的例子演示了其中的一些方法：

-- 假设我们有一个板块 printFormatter
-- 该模块有一个函数 simpleFormat(arg)
-- 方法 1
require "printFormatter"
printFormatter.simpleFormat("test")

-- 方法 2
local formatter = require "printFormatter"
formatter.simpleFormat("test")

-- 方法 3
require "printFormatter"
local formatterFunction = printFormatter.simpleFormat
formatterFunction("test")

从上面的例子中可以看出，Lua 不需要任何额外的代码就可以实现非常灵活的编程技巧。
require 函数

Lua 提供了一个高层次抽象的函数 require，使用这个函数可以加载所有需要的模块。在设计之初，这个函数就被设计的尽可能的简单，以避免加载模块时需要太多的模块信息。
require 函数加载模块时把所有模块都只当作一段定义了变量的代码（事实上是一些函数或者包含函数的表）而已，完全不需要更多的模块信息。
示例

让我们看一下面这个例子。在这个例子中，我们定义了模块 mymath,在这个模块中定义一些数学函数，并将该模块存储于 mymath.lua 文件中。具体内容如下：

local mymath =  {}
function mymath.add(a,b)
   print(a+b)
end

function mymath.sub(a,b)
   print(a-b)
end

function mymath.mul(a,b)
   print(a*b)
end

function mymath.div(a,b)
   print(a/b)
end

return mymath

接下来，我们在另一个文件　moduletutorial.lua 文件中访问这个模块。具体代码如下所示：

mymathmodule = require("mymath")
mymathmodule.add(10,20)
mymathmodule.sub(30,20)
mymathmodule.mul(10,20)
mymathmodule.div(30,20)

运行这段代码这前，我们需要将两个 lua 源代码文件放在同一目录下，或者把模块代码文件放在包路径下（这种情况需要额外的配置）。运行上面的代码，可以得到如下的输出结果：

30
10
200
1.5

注意事项

    把模块和待运行的文件放在相同的目录下。
    模块的名称与文件名称相同。
    为 require 函数返回模块（在模块中使用 return 命令返回存储了函数和变量的表）。尽管有其它的模块实现的方式，但是建议您使用上面的实现方法。

更老的实现模块的方法

下面，我们将用 package.seall 这种比较老的方法重新实现上面的例子。这种实现方法主要用于 Lua 5.1 或 5.2 版本。使用这种方式实现模块的代码如下所示：

module("mymath", package.seeall)

function mymath.add(a,b)
   print(a+b)
end

function mymath.sub(a,b)
   print(a-b)
end

function mymath.mul(a,b)
   print(a*b)
end

function mymath.div(a,b)
   print(a/b)
end

使用此模块的代码如下所示：

require("mymath")
mymath.add(10,20)
mymath.sub(30,20)
mymath.mul(10,20)
mymath.div(30,20)

当我们运行这段代码，我们会得到与前面相同的输出结果。但是建议你不要使用这种方式，因为普遍认为这种方式不及新的方法安全。许多用到 Lua 语言的 SDK 都已经不再使用这种方式定义模块，例如, Corna SDK。

        元表

Lua 元表

正如其名，元表也是表。不过，将元表与表相关联后，我们就可以通过设置元表的键和相关方法来改变表的行为。元方法的功能十分强大，使用元方法可以实现很多的功能，比如：

    修改表的操作符功能或为操作符添加新功能（译注：如果您学过 C++ 之类的面向对象的语言，应该比较好理解，其实它实现的是操作的重载）。
    使用元表中的 __index 方法，我们可以实现在表中查找键不存在时转而在元表中查找键值的功能。

Lua 提供了两个十分重要的用来处理元表的方法，如下：

    setmetatable(table,metatable):此方法用于为一个表设置元表。
    getmetatable(table)：此方法用于获取表的元表对象。

首先，让我们看一下如何将一个表设置为另一个表的元表。示例如下：

mytable = {}
mymetatable = {}
setmetatable(mytable,mymetatable)

上面的代码可以简写成如下的一行代码：

mytable = setmetatable({},{})

__index

下面的例子中，我们实现了在表中查找键不存在时转而在元表中查找该键的功能：

mytable = setmetatable({key1 = "value1"}, {
  __index = function(mytable, key)
    if key == "key2" then
      return "metatablevalue"
    else
      return mytable[key]
    end
  end
})

print(mytable.key1,mytable.key2)

运行上面的程序，我们可以得到如下的输出结果：

value1	metatablevalue

接下来逐步解释上面例子运行的过程：

    表 mytable 为 {key = "values1"}
    为 mytable 设置了一个元表，该元表的键 __index 存储了一个函数，我们称这个函数为元方法。
    这个元方法的工作也十分简单。它仅查找索引 “key2”,如果找到该索引值，则返回 "metatablevalue",否则返回 mytable 中索引对应的值。

上面的程序同样可以简化成如下的形式：

mytable = setmetatable({key1 = "value1"}, { __index = { key2 = "metatablevalue" } })
print(mytable.key1,mytable.key2)

__newindex

为元表添加 __newindex 后，当访问的键在表中不存在时，此时添加新键值对的行为将由此元方法（__newindex）定义。下面的例子中，如果访问的索引在表中不存在则在元表中新加该索引值（注意，是添加在另外一个表 mymetatable 中而非在原表 mytable 中。），具体代码如下(译注：请注意此处 __newindex 的值并非一个方法而是一个表。)：

mymetatable = {}
mytable = setmetatable({key1 = "value1"}, { __newindex = mymetatable })

print(mytable.key1)

mytable.newkey = "new value 2"
print(mytable.newkey,mymetatable.newkey)

mytable.key1 = "new  value 1"
print(mytable.key1,mymetatable.newkey1)

执行上面的程序，我们可以得到如下的输出结果：

value1
nil	new value 2
new  value 1	nil

可以看出，在上面的程序中，如果键存在于主表中，只会简单更新相应的键值。而如果键不在表中时，会在另外的表 mymetatable 中添加该键值对。
在接下来这个例子中，我们用 rawset 函数在相同的表（主表）中更新键值，而不再是将新的键添加到另外的表中。代码如下所示：

mytable = setmetatable({key1 = "value1"}, {
  __newindex = function(mytable, key, value)
		rawset(mytable, key, "\""..value.."\"")

  end
})

mytable.key1 = "new value"
mytable.key2 = 4

print(mytable.key1,mytable.key2)

执行上面的程序，我们可以得到如下的输出结果：

new value	"4"

rawset 函数设置值时不会使用元表中的 __newindex 元方法。同样的，Lua 中也存的一个 rawget 方法，该方法访问表中键值时也不会调用 __index 的元方法。
为表添加操作符行为

使用 + 操作符完成两个表组合的方法如下所示（译注：可以看出重载的意思了）：

mytable = setmetatable({ 1, 2, 3 }, {
  __add = function(mytable, newtable)
    for i = 1, table.maxn(newtable) do
      table.insert(mytable, table.maxn(mytable)+1,newtable[i])
    end
    return mytable
  end
})

secondtable = {4,5,6}

mytable = mytable + secondtable
for k,v in ipairs(mytable) do
print(k,v)
end

执行上面的的程序，我们可以得到如下的输出结果：

1	1
2	2
3	3
4	4
5	5
6	6

元表中 __add 键用于修改加法操作符的行为。其它操作对应的元表中的键值如下表所示。
键 	描述
__add 	改变加法操作符的行为。
__sub 	改变减法操作符的行为。
__mul 	改变乘法操作符的行为。
__div 	改变除法操作符的行为。
__mod 	改变模除操作符的行为。
__unm 	改变一元减操作符的行为。
__concat 	改变连接操作符的行为。
__eq 	改变等于操作符的行为。
__lt 	改变小于操作符的行为。
__le 	改变小于等于操作符的行为。
__call

使用 __call 可以使表具有像函数一样可调用的特性。下面的例子中涉及两个表，主表 mytable 和 传入的实参表结构 newtable，程序完成两个表中值的求和。

mytable = setmetatable({10}, {
  __call = function(mytable, newtable)
	sum = 0
	for i = 1, table.maxn(mytable) do
		sum = sum + mytable[i]
	end
    	for i = 1, table.maxn(newtable) do
		sum = sum + newtable[i]
	end
	return sum
  end
})
newtable = {10,20,30}
print(mytable(newtable))

运行上面的代码，我们可以得到如下的输出结果：

70

__tostring

要改变 print 语句的行为，我们需要用到 __tostring 元方法。下面是一个简单的例子：

mytable = setmetatable({ 10, 20, 30 }, {
  __tostring = function(mytable)
    sum = 0
    for k, v in pairs(mytable) do
		sum = sum + v
	end
    return "The sum of values in the table is " .. sum
  end
})
print(mytable)

运行上面的代码，我们可以得到如下的输出结果：

The sum of values in the table is 60

如果你完全掌握了元表的用法，你就可以实现很多看上面很复杂的操作。如果不使用元表，就不仅仅是看上去很复杂了，而是真的非常复杂。所以，多做一些使用元表的练习，并熟练掌握所有元表的可选项，这会让你受益匪浅。

        协程

Lua 协程
概述

协程具有协同的性质，它允许两个或多个方法以某种可控的方式协同工作。在任何一个时刻，都只有一个协程在运行，只有当正在运行的协程主动挂起时它的执行才会被挂起（暂停）。

上面的定义可能看上去比较模糊。接下来让我讲得很清楚一点，假设我们有两个方法，一个是主程序方法，另一个是一个协程。当我们使用 resume 函数调用一个协程时，协程才开始执行。当在协程调用 yield 函数时，协程挂起执行。再次调用 resume 函数时，协程再从上次挂起的地方继续执行。这个过程一直持续到协程执行结束为止。
协程中可用的函数

下面的表中列出 Lua 语言为支持协程而提供的所有函数以及它们的用法。
S.N. 	方法和功能
1 	coroutine.create(f):用函数 f 创建一个协程，返回 thread 类型对象。
2 	coroutine.resume(co[,val1,...]): 传入参数（可选），重新执行协程 co。此函数返回执行状态，也可以返回其它值。
3 	coroutine.running():返回正在运行的协程，如果在主线程中调用此函数则返回 nil。
4 	coroutine.status(co):返回指定协程的状态，状态值允许为：正在运行(running)，正常(normal)，挂起(suspended)，结束(dead)。
5 	coroutine.wrap(f):与前面 coroutine.create 一样，coroutine.wrap 函数也创建一个协程，与前者返回协程本身不同，后者返回一个函数。当调用该函数时，重新执行协程。
6 	coroutine.yield(...):挂起正在执行的协程。为此函数传入的参数值作为执行协程函数 resume 的额外返回值（默认会返回协程执行状态）。
示例

让我们通过下面的例子来理解一下协程这个概念。

co = coroutine.create(function (value1,value2)
   local tempvar3 =10
   print("coroutine section 1", value1, value2, tempvar3)
   local tempvar1 = coroutine.yield(value1+1,value2+1)
   tempvar3 = tempvar3 + value1
   print("coroutine section 2",tempvar1 ,tempvar2, tempvar3)
   local tempvar1, tempvar2= coroutine.yield(value1+value2, value1-value2)
   tempvar3 = tempvar3 + value1
   print("coroutine section 3",tempvar1,tempvar2, tempvar3)
   return value2, "end"
end)

print("main", coroutine.resume(co, 3, 2))
print("main", coroutine.resume(co, 12,14))
print("main", coroutine.resume(co, 5, 6))
print("main", coroutine.resume(co, 10, 20))

执行上面的程序，我们可以得到如下的输出结果：

coroutine section 1	3	2	10
main	true	4	3
coroutine section 2	12	nil	13
main	true	5	1
coroutine section 3	5	6	16
main	true	2	end
main	false	cannot resume dead coroutine

上面的例子到底做了些什么呢？

和前面说到的一样，在例子中我们使用 resume 函数继续执行协程，用 yield 函数挂起协程。同样，从例子中也可以看出如何为执行协程的 resueme 函数返回多个值。下面我将逐步解释上面的代码。

    首先，我们创建了一个协程并将其赋给变量 co。此协程允许传入两个参数。
    第一次调用函数 resume 时，协程内局部变量 value1 和 value2 的值分别为 3 和 2。
    为了便于理解，我们使用了局部变量 tempvar3 该变量被初始化为 10。由于变量 value1 的值为3，所以 tempvar3 在随后的协程调用过程中被先后更新为 13 和 16。
    第一次调用 coroutine.yield 时，为 resume 函数返回了值 4 和 3，这两个值是由传入的参数 3，2 分别加 1 后的结果，这一点可以从 yield 语句中得到证实。
    除了显示指定的返回值外，resume 还收到隐式的返回值 true，该值表示协程执行的状态，有 true 和 false 两个可能取值。
    上面的例子中，我们还应该关注在下一次调用 resume 时如何为协程传入参数。从例子中可以看到，coroutine.yield 函数返回后为两个变量赋值，该值即是第二次调用 resume 时传入的参数。
    这种参数传递的机制让可以结合前面传入的参数完成很多新的操作。
    最后，协程中所有语句执行完后，后面的调用就会返回 false 状态，同时返回 "cannot resume dead coroutine"消息。

另一个协程的示例

下面这例子中的协程使用 yield 函数和 resume 函数依次返回数字 1 到 5。示例中，如果没有协程对象或对象已结束（dead），则重新创建一个新的协程对象；若协程已经存在，则执行已经存在的协程。

function getNumber()
   local function getNumberHelper()
      co = coroutine.create(function ()
      coroutine.yield(1)
      coroutine.yield(2)
      coroutine.yield(3)
      coroutine.yield(4)
      coroutine.yield(5)
      end)
      return co
   end
   if(numberHelper) then
      status, number = coroutine.resume(numberHelper);
      if coroutine.status(numberHelper) == "dead" then
         numberHelper = getNumberHelper()
         status, number = coroutine.resume(numberHelper);
      end
      return number
   else
      numberHelper = getNumberHelper()
      status, number = coroutine.resume(numberHelper);
      return number
   end
end
for index = 1, 10 do
   print(index, getNumber())
end

执行上述的程序，我们可以得到如下的输出结果：

1	1
2	2
3	3
4	4
5	5
6	1
7	2
8	3
9	4
10	5

大家经常会把协程和多线程编程语言中的线程进行对比，但我们要明白，协程有着与线程类似的特性，但是协程与线程的区别在于协程不能并发，任意时刻只会有一个协程执行，而线程允许并发的存在。（译注：译者认为本质上协程其是就是线程，不过是用户态的线程罢了，它将调度问题交由程序开发人员手动完成。）

我们通过控制程序执行顺序以满足获取某些临时信息的需求。配合全局变量的使用，协程会变得更加的灵活方便。

        文件 I/O

Lua 文件 I/O

Lua 的 IO 库用于读取或操作文件。Lua IO 库提供两类文件操作，它们分别是隐式文件描述符(implict file descriptors)和显式文件描述符(explicit file descriptors)。

在接下来的例子的，我们会用到一个示例文件 test.lua，文件内容如下：

-- sample test.lua
-- sample2 test.lua

简单的打开文件操作可以用如下的语句完成。

file = io.open (filename [, mode])

可选的打开文件的模式如下表所示。
模式 	描述
"r" 	只读模式，这也是对已存在的文件的默认打开模式。
"w" 	可写模式，允许修改已经存在的文件和创建新文件。
"a" 	追加模式，对于已存的文件允许追加新内容，但不允许修改原有内容，同时也可以创建新文件。
"r+" 	读写模式打开已存的在文件。
"w+" 	如果文件已存在则删除文件中数据；若文件不存在则新建文件。读写模式打开。
"a+" 	以可读的追加模式打开已存在文件，若文件不存在则新建文件。
隐式文件描述符

隐式文件描述符使用标准输入输出模式或者使用单个输入文件和输出文件。使用隐匿文件描述符的示例代码如下：

-- 只读模式打开文件
file = io.open("test.lua", "r")

-- 将 test.lua 设置为默认输入文件
io.input(file)

--打印输出文件的第一行
print(io.read())

-- 关闭打开的文件
io.close(file)

-- 以追加模式打开文件
file = io.open("test.lua", "a")

-- 将 test.lua 设置为默认的输出文件
io.output(file)

-- 将内容追加到文件最后一行
io.write("-- End of the test.lua file")

-- 关闭打开的文件
io.close(file)

执行上面的程序，我们可以看到输出了 test.lua 文件的第一行。在本例中，输出的结果为：

- Sample test.lua

输出的内容是 test.lua 文件中的第一行。“-- End of the test.lua file” 他会被追加到 test.lua 文件的最后一行。

从上面的例子中，你可以看到隐式的描述述如何使用 io."x" 方法与文件系统交互。上面的例子使用 io.read() 函数时没有使用可选参数。此函数的可选参数包括：

模式 	描述
"*n" 从文件当前位置读入一个数字，如果该位置不为数字则返回 nil。
"*a" 读入从当前文件指针位置开始的整个文件内容。
"*l" 读入当前行。
number 读入指定字节数的内容。

另外一些常用的方法：

    io.tmpfile():返回一个可读写的临时文件，程序结束时该文件被自动删除。
    io.type(file):检测输入参数是否为可用的文件句柄。返回 "file" 表示一个打开的句柄；“closed file” 表示已关闭的句柄；nil 表示不是文件句柄。
    io.flush():清空输出缓冲区。
    io.lines(optional file name): 返回一个通用循环迭代器以遍历文件，每次调用将获得文件中的一行内容,当到文件尾时，将返回nil。若显示提供了文件句柄，则结束时自动关闭文件；使用默认文件时，结束时不会自动关闭文件。

显示文件描述符

我们也会经常用到显示文件描述符，因为它允许我们同时操作多个文件。这些函数与隐式文件描述符非常相似，只不过我们在这儿使用 file:function_name 而不是使用 io.function_name 而已。下面的例子使用显示文件描述符实现了与前面例子中完全相同的功能。
　

-- 只读模式打开文件
file = io.open("test.lua", "r")

-- 输出文件的第一行
print(file:read())

-- 关闭打开的文件
file:close()

-- 以追加模式打开文件 
file = io.open("test.lua", "a")

-- 添加内容到文件的尾行
file:write("--test")

-- 关闭打开的文件
file:close()

执行上面的程序，我们可以得到与前面使用隐式文件描述符类似的输出结果：

-- Sample test.lua

在显式文件描述符中，打开文件的描述与读文件时的参数与隐式文件描述中的完全相同。另外的常用方法包括：

    file:seek(option whence,option offset)：此函数用于移动文件指针至新的位置。参数 whence 可以设置为 “set”，"cur","end"，offset 为一个偏移量值，描述相对位置。
    如果第一个参数为 "set"，则相对位置从文件开始处开始计算；如果第一个参数为 "cur"，则相对位置从文件当前位置处开始计算； 如果第一个参数为 "end"，则相对位置从文件末尾处开始计算。
    函数的参数默认值分别为 "cur" 和 ０，因此不传递参数调用此函数可以获得文件的当前位置。
    file:flush()：清空输出缓冲区。
    io.lines(optional file name)：提供一个循环迭代器以遍历文件，如果指定了文件名则当遍历结束后将自动关闭该文件；若使用默认文件，则遍历结束后不会自动关闭文件。

下面的例子演示 seek 函数的使用方法。它将文件指针从文件末尾向前移动 25。并使用 read 函数从该位置出输出剩余的文件内容。

-- Opens a file in read
file = io.open("test.lua", "r")

file:seek("end",-25)
print(file:read("*a"))

-- closes the opened file
file:close()

执行上的面的程序，你可以得到类似下面的输出结果：

 sample2 test.lua
--test

你还可以尝试不同的参数了解更多的 Lua 文件操作方法。

        错误处理

Lua 错误处理
为什么需要错误处理机制

在真实的系统中程序往往非常复杂，它们经常涉及到文件操作、数据库事务操作或网络服务调用等，这个时候错误处理就显得非常重要。不关注错误处理可能在处理诸如涉密或金融交易这些业务时造成重大的损失。
无论什么时候，程序开发都要求小心地做好错误处理工作。在 Lua 中错误可以被分为两类：

    语法错误
    运行时错误

语法错误　　

语法错误是由于不正确的使用各种程序语法造成的，比如错误的使用操作符或表达式。下面即是一个语法错误的例子：

a == 2

正如你知道的那样，单个等号与双等号是完全不一样的。二者之间随意的替换就导致语法错误。一个等号表示的是赋值，而双等号表示比较。类似地，下面这一小段代码中也存在语法错误：

for a= 1,10
   print(a)
end

执行上面的这段程序，我们会得到如下的输出结果：

lua: test2.lua:2: 'do' expected near 'print'

语法错误相比于运行时错误更容易处理，因为 Lua 解释器可以更精确的定位到语法错误的位置。由上面的错误，我们可以容易就知道，在 print 语句前添加 do 语句就可以了，这是 Lua 语法结构所要求的。
运行时错误

对于运行时错误，虽然程序也能成功运行，但是程序运行过程中可能因为错误的输入或者错误的使用函数而导致运行过程中产生错误。下面的例子显示了运行时错误如何产生的：

function add(a,b)
   return a+b
end

add(10)

当我们尝试生成(build)上面的程序，程序可以正常的生成和运行。但是一旦运行后，立马出现下面的运行时错误。

lua: test2.lua:2: attempt to perform arithmetic on local 'b' (a nil value)
stack traceback:
	test2.lua:2: in function 'add'
	test2.lua:5: in main chunk
	[C]: ?

这个运行时错误是由于没有正确的为 add 函数传入参数导致的，由于没有为 b 传入值，所有 b 的值为 nil 从而导致在进行加法运算时出错。
Assert and Error 函数

我们经常用到 assert 和 error 两个函数处理错误。下面是一个简单的例子。

local function add(a,b)
   assert(type(a) == "number", "a is not a number")
   assert(type(b) == "number", "b is not a number")
   return a+b
end
add(10)

执行上面的程序，我们会得到如下的输出结果：

lua: test2.lua:3: b is not a number
stack traceback:
	[C]: in function 'assert'
	test2.lua:3: in function 'add'
	test2.lua:6: in main chunk
	[C]: ?

error(message [,level]) 函数会结束调用自己的函数，并将 message 作为错误信息返回调用者(译注:保护模式下才会返回调用者，一般情况会结束程序运行并在控制终端输出错误信息)。error 函数本身从不返回。
一般地，error 函数会在消息前附上错误位置信息。级别(level) 参数指定错误发生的位置。若其值为 1(默认值)，返回的错误的位置是 error 函数被调用的位置。若为 2, 返回的错误位置为调用 error 函数的函数被调用的位置，依次类推。将 level 参数的值设为 0 就不再需要在消息前增加额外的位置信息了。
pcall 与 xpcall　　

在 Lua 中，为了避免使用抛出错误和处理错误，我们需要用到 pcall 和 xpcall 函数来处理异常。
使用 pcall(f,arg1,...) 函数可以使用保护模式调用一个函数。如果函数 f 中发生了错误， 它并不会抛出一个错误，而是返回错误的状态。使用的 pcall 函数的方法如下所示：

function myfunction ()
   n = n/nil
end

if pcall(myfunction) then
   print("Success")
else
	print("Failure")
end

执行上面的程序，我们可以得到如下的输出结果：

Failure

xpcall(f,err) 函数调用函数 f 同时为其设置了错误处理方法 err，并返回调用函数的状态。任何发生在函数 f 中的错误都不会传播，而是由 xpcall 函数捕获错误并调用错误处理函数 err，传入的参数即是错误对象本身。xpcall 的使用示例如下：

function myfunction ()
   n = n/nil
end

function myerrorhandler( err )
   print( "ERROR:", err )
end

status = xpcall( myfunction, myerrorhandler )
print( status)

执行上面的程序，我们可以得到如下的输出结果：

ERROR:	test2.lua:2: attempt to perform arithmetic on global 'n' (a nil value)
false

作为程序开发人员，在程序中正确合理地处理错误是非常重要的。正确地处理错误可以保证发生意外情况不会影响到程序用户的使用。

    lua 进阶
        调试

Lua 调试

Lua 提供一个调试库，这个库中提供了创建自己的调试器所需的所有原语函数。虽然，Lua 没有内置调试器，但是开发者们为 Lua 开发了许多的开源调试器。

Lua 调试库包括的函数如下表所示。
S.N. 	方法和描述
1 	debug():进入交互式调试模式，在此模式下用户可以用其它函数查看变量的值。
2 	getfenv(object):返回对象的环境。
3 	gethook(optional thread)：返回线程当前的钩子设置，总共三个值：当前钩子函数、当前的钩子掩码与当前的钩子计数。
4 	getinfo(optional thread,function or stack leve,optional flag)：返回保存函数信息的一个表。你可以直接指定函数，或者你也可以通过一个值指定函数，该值为函数在当前线程的函数调用栈的层次。其中，0 表示当前函数（getinfo 本身）；层次 1 表示调用 getinfo 的函数，依次类推。如果数值大于活跃函数的总量，getinfo 则返回 nil。
5 	getlocal(optional thread,stack level,local index)：此函数返回在 level 层次的函数中指定索引位置处的局部变量和对应的值。如果指定的索引处不存在局部变量，则返回 nil。当 level 超出范围时，则抛出错误。
6 	getmetatable(value)：返回指定对象的元表，如果不存在则返回 nil。
7 	getregistry()：返回寄存器表。寄存器表是一个预定义的用于 C 代码存储 Lua 值的表。
8 	getupvalue(func function,upvalue index)：根据指定索引返回函数 func 的 upvalue 值（译注：upvalue 值与函数局部变量的区别在于，即使函数并非活跃状态也可能有 upvalue 值，而非活跃函数则不存在局部变量，所以其第一个参数不是栈的层次而是函数）。如果不存在，则返回 nil。
9 	setfenv(function or thread or userdata,environment table)：将指定的对象的环境设置为 table,即改变对象的作用域。
10 	sethook(optional thread,hook function,hook mask string with "c" and/or "r" and/or "l",optional instruction count)：把指定函数设置为钩子。字符串掩码和计数值表示钩子被调用的时机。这里，c 表示每次调用函数时都会执行钩子；r 表示每次从函数中返回时都调用钩子；l 表示每进入新的一行调用钩子。
11 	setlocal(optional thread,stack level,local index,value):在指定的栈深度的函数中，为 index 指定的局部变量赋予值。如果局部变量不存在，则返回 nil。若 level 超出范围则抛出错误；否则返回局部变量的名称。
12 	setmetatable(value,metatable):为指定的对象设置元表，元表可以为 nil。
13 	setupvalue(function,upvalue index,value):为指定函数中索引指定的 upvalue 变量赋值。如果 upvalue 不存在，则返回 nil。否则返回此 upvalue 的名称。
14 	traceback(optional thread,optional meesage string,opitona level argument)：用 traceback 构建扩展错误消息。

上面的表中列出了 Lua 的全部调试函数，我们经常用到的调试库都会用到上面的函数，它让调试变得非常容易。虽然提供了便捷的接口，但是想要用上面的函数创建一个自己的调试器并不是件容易的事。无论怎样，我们可以看一下下面这个例子中怎么使用这些调试函数的。

function myfunction ()
print(debug.traceback("Stack trace"))
print(debug.getinfo(1))
print("Stack trace end")
	return 10
end
myfunction ()
print(debug.getinfo(1))

执行上面的程序，我们可以得到如下的栈轨迹信息：

Stack trace
stack traceback:
	test2.lua:2: in function 'myfunction'
	test2.lua:8: in main chunk
	[C]: ?
table: 0054C6C8
Stack trace end

上面的例子中，我们使用 debug.trace 函数输出了栈轨迹。 debug.getinfo 函数获得函数的当前表。
示例二

在调试过程中，我们常常需要查看或修改函数局部变量的值。因此，我们可以用 getupvalue 获得变量的值，用 setupvalue 修改变量的值。示例如下：

function newCounter ()
  local n = 0
  local k = 0
  return function ()
    k = n
    n = n + 1
    return n
    end
end

counter = newCounter ()
print(counter())
print(counter())

local i = 1

repeat
  name, val = debug.getupvalue(counter, i)
  if name then
    print ("index", i, name, "=", val)
	if(name == "n") then
		debug.setupvalue (counter,2,10)
	end
    i = i + 1
  end -- if
until not name

print(counter())

运行上面的程序，我们可以得到如下面的输出结果：

1
2
index	1	k	=	1
index	2	n	=	2
11

在这个例子中，每次调用 counter 都会更新该闭包函数。我们可以通过 getupvalue 查看其当前的局部变量值。随后，我们更新局部变量的值。在为 n 设置新值之前，其值为 2。调用 setupvalue 后，n 被设置为 10。再调用 counter 时，它就会返回值 11 而不再是 3。
调试类型

    命令行调试
    图形界面调试

命令行调试工具

命令行调试就是使用命令行命令和 print 语句来调试程序。已经有许多现成的 Lua 命令行调试工具，下面列出了其中的一部分：

    RemDebug：RemDebug 是一个远程的调试器，它支持 Lua 5.0 和 5.1 版本。允许远程调试 Lua 程序，设置断点以及查看程序的当前状态。同时，它还能调试 CGILua 脚本。
    clidebugger：此调试器是用纯 Lua 脚本开发的命令行调试工具，支持 Lua 5.1。除了 Lua 5.1 标准库以外，它不依赖于任何其它的 Lua 库。虽然它受到了 RemDebug 影响而产生的，但是它没有远程调试的功能。
    ctrace：跟踪 Lua API 调用的小工具。
    xdbLua：windows 平台下的 Lua 命令行调试工具。
    LuaInterface - Debuger：这个项目是 LuaInterface 的扩展，它对 Lua 调试接口进行进一步的抽象，允许通过事件和方法调用的方式调试程序。
    RIdb：使用套接字的远程 Lua 调试器，支持 Linux 和 Windows 平台。它的特性比任何其它调试器都丰富。
    ModDebug：允许远程控制另外一个 Lua　程序的执行、设置断点以及查看程序的当前状态。

图形界面调试工具

图形界面的调试工具往往和集成开发环境（IDE）打包在一起。它允许在可视环境下进行调试，比如查看变量值，栈跟踪等。通过 IDE 的图形界面，你可以设置断点单步执行程序。

下面列出了几种图形界面的调试工具。

    SciTE：Windows 系统上默认的 Lua 集成开发环境，它提供了丰富的调试功能，比如，断点、单步、跳过、查看变量等等。
    Decoda：一个允许远程调试的图形界面调试工具。
    ZeroBrane Studio：一个 Lua 的集成开发环境，它集成了远程调试器、栈视图、远程控制终端、静态分析等诸多功能。它兼容各类 Lua 引擎，例如 LuaJIT,Love2d,Moai等。支持 Windows, OSX, Linux；开源。
    akdebugger：eclipse 的 Lua 调试器和编辑器插件。
    luaedit：支持运程调试、本地调试、语法高亮、自动补完、高级断点管理（包括有条件地触发断和断点计数）、函数列表、全局和本地变量列表、面对方案的管理等。


        垃圾回收机制

Lua 垃圾回收机制

Lua 通过特定算法的垃圾回收机制实现自动内存管理。由于自动内存管理机制的存在，作为程序开发人员：

    不需要关心对象的内存分配问题。
    不再使用对象时，除了将引用它的变量设为 nil，不需要主动释放对象。

Lua 的垃圾回收器会不断运行去收集不再被 Lua 程序访问的对象。 所有的对象，包括表、userdata、函数、线程、字符串等都由自动内存管理机制管理它们空间的分配和释放。Lua 实现了一个增量式标记清除垃圾收集器。它用两个数值控制垃圾回收周期，垃圾收集器暂停时间（garbage-collector pause） 和垃圾收集器步长倍增器（garbage-collector step multiplier）。其数值是以百分制计数的，即数值 100 内部表示 1。
垃圾收集器暂停时间

该数值被用于控制垃圾收集器被 Lua 自动内存管理再次运行之前需要的等待时长。当其小于 100 时意味着收集器在新周期开始前不再等待。其值越大垃圾回收器被运行的频率越低，越不主动。当其值 200 时，收集器在总使用内存数量达到上次垃圾收集时的两倍时再开启新的收集周期。因此，根据程序不同的特征，可以通过修改该值使得程序达到最佳的性能。
垃圾收集器步长倍增器

步长倍增器用于控制了垃圾收集器相对内存分配的速度。数值越大收集器工作越主动，但同时也增加了垃圾收集每次迭代步长的大小。值小于 100 可能会导致垃圾器一个周期永远不能结束，建议不要这么设置。默认值为 200，表示垃圾收集器运行的速率是内存分配的两倍。
垃圾回收器相关函数

作为开发人员，我们可能需要控制 Lua 的自动内存管理机制，可以使用下面的这些方法：

    collectgarbage("collect")：运行一个完整的垃圾回收周期。
    collectgarbage("count")：返回当前程序使用的内存总量，以 KB 为单位。
    collectgarbage("restart")：如果垃圾回收器停止，则重新运行它。
    collectgarbage("setpause")：设置垃圾收集暂停时间变量的值，值由第二个参数指出（第二参数的值除以 100 后赋予变量）。稍后，我们将详细讨论它的用法。
    collectgarbage("setsetmul")：设置垃圾收集器步长倍增器的值，第二个参数的含义与上同。
    collectgarbage("step")：进行一次垃圾回收迭代。第二个参数值越大，一次迭代的时间越长；如果本次迭代是垃圾回收的最后一次迭代则此函数返回 true。
    collectgarbage("stop")：停止垃圾收集器运行。

下面的示例代码中使用了垃圾收集器相关函数，如下所示：

mytable = {"apple", "orange", "banana"}

print(collectgarbage("count"))

mytable = nil

print(collectgarbage("count"))

print(collectgarbage("collect"))

print(collectgarbage("count"))

运行上面的程序，我们可以得到如下的输出结果。请注意，输出结果与操作系统类型与 Lua 自动内存管理都有关，所以可能实际运行的结果与下面不相同。

20.9560546875
20.9853515625
0
19.4111328125

从上面的程序，我们可以看出，一旦垃圾回收运行后，使用的内存量立即就减少了。但是，我们并不需要主动去调用它。因为，即使我们不调用此函数，Lua 也会按配置的周期自动的调用垃圾回收器。
显然，如果需要，我们可以用上面的这些函数调整垃圾回收器的行为。这些函数帮且程序开发人员处理更加复杂的场景。根据开发的不同程序的内存需求，我们可以使用到这些方法来提高程序的性能。虽然大部分情况下，我们都不会用到这些函数，但是了解这些方法可以帮助我们调试程序，以免应用上线后带来的损失。

译注：更多垃圾回收器的内容请参考官网或者此博客。

        面向对象

Lua 面向对象
面向对象概述

面向对象编程技术是目前最常用的编程技术之一。目前大量的编程语言都支持面向对象的特性：

    C++
    Java
    Objective-C
    Smalltalk
    C#
    Ruby

面向对象的特征

    类（class）：类是可以创建对象，并为状态（成员变量）提供初值及行为实现的可扩展模板。
    对象（objects）：对象是类的实例，每个对象都有独立的内存区域。
    继承（inheritance）：继承用于描述一个类的变量和函数被另一个类继承的行为。
    封装（encapsulation）：封装是指将数据和函数组织在一个类中。外部可以通过类的方法访问内中的数据。封装也被称之为数据抽象。

## Lua 中的面向对象

在 Lua 中，我们可以使用表和函数实现面向对象。将函数和相关的数据放置于同一个表中就形成了一个对象。继承可以用元表实现，它提供了在父类中查找存在的方法和变量的机制。
Lua 中的表拥有对象的特征，比如状态和独立于其值的标识。两个有相同值的对象（表）是两个不同的对象，但是一个对象在不同的时间可以拥有不同的值。与对象一样，表拥有独立于其创建者和创建位置的生命周期。
一个真实世界的例子

面向对象已经是一个广泛使用的概念，但是你需要正确清楚地理解它。
让我们看一个数学方面的例子。我们经常需要处理各种形状，比如圆、矩形、正方形。
这些形状有一个共同的特征——面积。所以，所有其它的形状都可以从有一个公共特征——面积的基类扩展而来。每个对象都可以有它自己的特征和函数，比如矩阵有属性长、宽和面积，printArea 和 calculateArea 方法。
创建一个简单的类

下面例子实现了矩阵类的三个属性：面积、长和宽。它还同时实现了输出面积的函数 printArea。

-- 元类
Rectangle = {area = 0, length = 0, breadth = 0}

-- 继承类的方法 new
function Rectangle:new (o,length,breadth)
  o = o or {}
  setmetatable(o, self)
  self.__index = self
  self.length = length or 0
  self.breadth = breadth or 0
  self.area = length*breadth;
  return o
end

-- 继承类的方法 printArea
function Rectangle:printArea ()
  print("The area of Rectangle is ",self.area)
end

创建对象

创建对象即是为类的实例分配内存空间的过程。每个对象都有自己独立的内存区域，同时还会共享类的数据。

r = Rectangle:new(nil,10,20)

访问属性

我们可以使用点操作符访问类中属性。

print(r.length)

访问成员方法

使用冒号操作符可以访问对象的成员方法，如下所示：

r:printArea()

初始化阶段，调用函数为对象分配内存同时设置初值。这与其它与面向对象的语言中的构造器很相似。其实，构造器本身也就和上面的初始化代码一样，并没有什么特别之处。
完整的例子

让我们一起看一个 Lua 实现面向对象的完整例子。

-- 元类
Shape = {area = 0}

-- 基类方法 new
function Shape:new (o,side)
  o = o or {}
  setmetatable(o, self)
  self.__index = self
  side = side or 0
  self.area = side*side;
  return o
end

-- 基类方法 printArea
function Shape:printArea ()
  print("The area is ",self.area)
end

-- 创建对象
myshape = Shape:new(nil,10)

myshape:printArea()

运行上面的程序，我们可以得到如下的输出结果：

The area is 	100

Lua 中的继承

继承就是从基对象扩展的过程，正如从图形扩展至矩形、正方形等等。在现实世界中，常用来共享或扩展某些共同的属性和方法。
让我们看一个简单的类扩展的例子。我们有如下的类：

 -- 元类
Shape = {area = 0}
-- 基类方法 new
function Shape:new (o,side)
  o = o or {}
  setmetatable(o, self)
  self.__index = self
  side = side or 0
  self.area = side*side;
  return o
end
-- 基类方法 printArea
function Shape:printArea ()
  print("The area is ",self.area)
end

我们从上面的类中扩展出正方形类，如下所示：

Square = Shape:new()
-- 继承类方法 new
function Square:new (o,side)
  o = o or Shape:new(o,side)
  setmetatable(o, self)
  self.__index = self
  return o
end

重写基类的函数

继承类可以重写基类的方法，从而根据自己的实际情况实现功能。示例代码如下所示：

-- 继承方法 printArea
function Square:printArea ()
  print("The area of square is ",self.area)
end

继承的完整示例

在元表的帮助下，我们可以使用新的 new 方法实现类的扩展（继承）。子类中保存了所有基类的成员变量和方法。

 -- Meta class
Shape = {area = 0}
-- Base class method new
function Shape:new (o,side)
  o = o or {}
  setmetatable(o, self)
  self.__index = self
  side = side or 0
  self.area = side*side;
  return o
end
-- Base class method printArea
function Shape:printArea ()
  print("The area is ",self.area)
end

-- Creating an object
myshape = Shape:new(nil,10)
myshape:printArea()

Square = Shape:new()
-- Derived class method new
function Square:new (o,side)
  o = o or Shape:new(o,side)
  setmetatable(o, self)
  self.__index = self
  return o
end

-- Derived class method printArea
function Square:printArea ()
  print("The area of square is ",self.area)
end

-- Creating an object
mysquare = Square:new(nil,10)
mysquare:printArea()

Rectangle = Shape:new()
-- Derived class method new
function Rectangle:new (o,length,breadth)
  o = o or Shape:new(o)
  setmetatable(o, self)
  self.__index = self
  self.area = length * breadth
  return o
end

-- Derived class method printArea
function Rectangle:printArea ()
  print("The area of Rectangle is ",self.area)
end

-- Creating an object
myrectangle = Rectangle:new(nil,10,20)
myrectangle:printArea()

运行上面的程序，我们可以得到如下的输出结果：

The area is 	100
The area of square is 	100
The area of Rectangle is 	200

上面的例子中，我们继承基类 Shape 创建了两个子类 Rectange 与 Square。在子类中可以重写基类提供的方法。在这个例子中，子类重写了 printArea 方法。

Programming in Lua 学习总结

Chapter 1. Getting Started
hello.lua
print("Hello World")

lua hello.lua

factorial.lua
function fact (n)
    if n == 0 then
        return 1
    else
　    return n * fact(n - 1)
    end
end

print("enter a number:")
a = io.read("*n")
print(fact(a))

lua factorial.lua
enter a number:
5
120

lua
Lua 5.3	Copyright (C) 1994-2016 Lua.org, PUC-Rio
> math.pi / 4	--> 0.78539816339745
> a = 15
> a^2	--> 225
> a + 2	--> 17

print(math.pi / 4)
a = 15
print(a^2)
print(a + 2)

We can use the -i option to instruct Lua to start an interactive session after running a given chunk:

lua -i prog.lua

lib1.lua

function norm (x, y)
    return math.sqrt(x^2 + y^2)
end

function twice (x)
    return 2.0 * x
end

Then, in interactive mode, we can type this code:

> dofile("lib1.lua")	-- load our library
> n = norm(3.4, 1.0)
> twice(n)	--> 7.0880180586677

Identifiers (or names) in Lua can be any string of letters, digits, and underscores, not beginning with a digit; for instance
You should avoid identifiers starting with an underscore followed by one or more upper-case letters; they are reserved for special uses in Lua. 
Usually, I reserve the identifier _ (a single underscore) for dummy variables.

The following words are reserved; we cannot use them as identifiers:

and
break
do
else
elseif
end
false
for
function
goto
if
in
local
nil
not
or
repeat
return
then
true
until
while

Lua is case-sensitive: and is a reserved word, but And and AND are two different identifiers.
A comment starts anywhere with two consecutive hyphens (--) and runs until the end of the line. 
Lua also offers long comments, which start with two hyphens followed by two opening square brackets 
and run until the first occurrence of two consecutive closing square brackets, like here:

--[[A multi-line
    long comment
--]]
A common trick that we use to comment out a piece of code is to enclose the code between --[[ and --]], like here:
--[[
print(10)	-- no action (commented out)
--]]
To reactivate the code, we add a single hyphen to the first line:

---[[
print(10)	--> 10
--]]
In the first example, the --[[ in the first line starts a long comment, and the two hyphens in the last line are still inside that comment. 
In the second example, the sequence ---[[ starts an ordinary, single-line comment, so that the first and the last lines become independent comments. 
In this case, the print is outside comments.

Lua needs no separator between consecutive statements, but we can use a semicolon if we wish. Line breaks play no role in Lua's syntax; 
for instance, the following four chunks are all valid and equivalent:

a = 1
b = a * 2

a = 1;
b = a * 2;

a = 1; b = a * 2

a = 1	b = a * 2	-- ugly, but valid
My personal convention is to use semicolons only when I write two or more statements in the same line (which I hardly do).
Global Variables
Global variables do not need declarations; we simply use them. It is not an error to access a non-initialized variable; we just get the value nil as the result:

> b	--> nil
> b = 10
> b	--> 10
If we assign nil to a global variable, Lua behaves as if we have never used the variable:

> b = nil
> b	--> nil
Lua does not differentiate a non-initialized variable from one that we assigned nil. After the assignment, Lua can eventually reclaim the memory used by the variable.
Types and Values
Lua is a dynamically-typed language. There are no type definitions in the language; each value carries its own type.
There are eight basic types in Lua: nil, Boolean, number, string, userdata, function, thread, and table. The function type gives the type name of any given value:
> type(nil)	--> nil
> type(true)	--> boolean
> type(10.4 * 3)	--> number
> type("Hello world")	--> string
> type(io.stdin)	--> userdata
> type(print)	--> function
> type(type)	--> function
> type({})	--> table
> type(type(X))	--> string
The last line will result in "string" no matter the value of X, because the result of type is always   a string.
The userdata type allows arbitrary C data to be stored in Lua variables. It has no predefined operations in Lua, except assignment and equality test. 
Userdata are used to represent new types created by an application program or a library written in C; for instance, the standard I/O library uses them to represent open files. 
We will discuss more about userdata later, when we get to the C API.

Nil

Variables have no predefined types; any variable can contain values of any type:

> type(a)	--> nil	('a' is not initialized)
> a = 10
> type(a)	--> number
> a = "a string!!"
> type(a)	--> string
> a = nil
> type(a)	--> nil

Nil is a type with a single value, nil, whose main property is to be different from any other value. Lua uses nil as a kind of non-value, to represent the absence of a useful value. 
As we have seen, a global variable has a nil value by default, before its first assignment, and we can assign nil to a global variable to delete it.
Booleans
The Boolean type has two values, false and true, which represent the traditional Boolean values. 
Conditional tests consider both the Boolean  false and nil  as false and anything else as true. 
In particular, Lua considers both zero and the empty string as true in conditional tests.

Lua supports a conventional set of logical operators: and, or, and not. Like control structures, all logical operators consider both the Boolean false and nil as false, and anything else as true. 
The result of the and operator is its first operand if that operand is false; otherwise, the result is its second operand. 
The result of the or operator is its first operand if it is not false; otherwise, the result is its second operand:

> 4 and 5	--> 5
> nil and 13	--> nil
> false and 13	--> false
> 0 or 5	--> 0
> false or "hi"	--> "hi"
> nil or false	--> false
Both and and or use short-circuit evaluation, that is, they evaluate their second operand only when necessary. 

A useful Lua idiom is x = x or v, which is equivalent to
if not x then
    x = v
end

That is, it sets x to a default value v when x is not set (provided that x is not set to false).

Another useful idiom is ((a and b) or c)，It is equivalent to the C expression a ? b : c, provided that b is not false. 
For instance, we can select the maximum of two numbers x and y with the expression (x > y) and x or y. 
When x > y, the first expression of the and is true, so the and results in its second operand (x), which is always true (because it is a number), 
and then the or expression results in the value of its first operand, x. When x > y is false, the and expression is false and so the or results in its second operand, y.
The not operator always gives a Boolean value:

> not nil	--> true
> not false	--> true
> not 0	--> false
> not not 1	--> true
> not not nil	--> false

The Stand-Alone Interpreter
When the interpreter loads a file, it ignores its first line if this line starts with a hash (#). This feature allows the use of Lua as a script interpreter in POSIX systems. 
If we start our script with something like

#!/usr/local/bin/lua
(assuming that the stand-alone interpreter is located at /usr/local/bin), or
#!/usr/bin/env lua
then we can call the script directly, without explicitly calling the Lua interpreter.

The usage of lua is
lua [options] [script [args]]
Everything is optional. As we have seen already, when we call lua without arguments the interpreter enters the interactive mode.

The -e option allows us to enter code directly into the command line, like here:
lua -e "print(math.sin(12))"	--> -0.53657291800043
(POSIX systems need the double quotes to stop the shell from interpreting the parentheses.)

The -l option loads a library. As we saw previously, -i enters interactive mode after running the other arguments. 
Therefore, the next call will load the lib library, then execute the assignment x = 10, and finally present a prompt for interaction.

lua -i -llib -e "x = 10"
If we write an expression in interactive mode, Lua prints its value:

> math.sin(3)	--> 0.14112000805987
> a = 30
> a	--> 30

(Remember, this feature came with Lua 5.3. In older versions, we must precede the expressions with equals signs.)
To avoid this print, we can finish the line with a semicolon:

> io.flush()	--> true
> io.flush();
The semicolon makes the line syntactically invalid as an expression, but still valid as a command. 

A script can retrieve its arguments through the predefined global variable arg. In a call like lua script a b c, the interpreter creates the table arg with all the command-line arguments, before running any code. 
The script name goes into index 0; its first argument ("a" in the example) goes to index 1, and so on. Preceding options go to negative indices, as they appear before the script. 
For instance, consider this call:

lua -e "sin=math.sin" script a b

The interpreter collects the arguments as follows:

arg[-3] = "lua"
arg[-2] = "-e"
arg[-1] = "sin=math.sin"
arg[0] = "script"
arg[1] = "a"
arg[2] = "b"

More often than not, a script uses only the positive indices (arg[1] and arg[2], in the example).
A script can also retrieve its arguments through a vararg expression. In the main body of a script, the expression ... (three dots) results in the arguments to the script. 
(We will discuss vararg expressions in the section called “Variadic Functions”.)

lua -e "sin=math.sin" hello.lua a b
Hello World
1       a
2       b
0       hello.lua
-3      lua
-2      -e
-1      sin=math.sin

cat hello.lua
print("Hello World")
for k,v in pairs(arg) do
    print(k,v)
end

Chapter 2. Interlude: The Eight-Queen Puzzle

N = 8	-- board size

-- check whether position (n,c) is free from attacks
function isplaceok (a, n, c)
    for i = 1, n - 1 do
        if (a[i] == c) or (a[i] - i == c - n) or (a[i] + i == c + n) then
            return false
        end
    end
    return true
end

-- print a board
function printsolution (a)
    for i = 1, N do	-- for each row
        for j = 1, N do
            io.write(a[i] == j and "X" or "-", " ")
        end
        io.write("\n")
    end
    io.write("\n")
end

-- add to board 'a' all queens from 'n' to 'N'
function addqueen (a, n)
    if n > N then
        printsolution(a)
    else
        for c = 1, N do
            if isplaceok(a, n, c) then
                a[n] = c
                addqueen(a, n + 1)
            end
        end
    end
end

-- run the program
addqueen({}, 1)

Chapter 3. Numbers
Until version 5.2, Lua represented all numbers using double-precision floating-point format. 
Starting with version 5.3, Lua uses two alternative representations for numbers: 64-bit integer numbers, called simply integers, 
and double-precision floating-point numbers, called simply floats. (Note that, in this book, the term “float” does not imply single precision.) 
For restricted platforms, we can compile Lua 5.3 as Small Lua, which uses 32-bit integers and single-precision floats.
The introduction of integers is the hallmark of Lua 5.3, its main difference against previous versions of Lua. Nevertheless, this change created few incompatibilities, 
because double-precision floating-point numbers can represent integers exactly up to 2^53. Most of the material we will present here is valid for Lua 5.2 and older versions, too. 
In the end of this chapter I will discuss in more detail the incompatibilities.
Numerals
We can write numeric constants with an optional decimal part plus an optional decimal exponent, like these examples:

> 4 --> 4
> 0.4 --> 0.4
> 4.57e-3 --> 0.00457
> 0.3e12 --> 300000000000.0
> 5E+20 --> 5e+20
Numerals with a decimal point or an exponent are considered floats; otherwise, they are treated as integers. Both integer and float values have type "number":
> type(3)	--> number
> type(3.5)	--> number
> type(3.0)	--> number
They have the same type because, more often than not, they are interchangeable. Moreover, integers and floats with the same value compare as equal in Lua:
> 1 == 1.0	--> true
> -3 == -3.0	--> true
> 0.2e3 == 200	--> true
In the rare occasions when we need to distinguish between floats and integers, we can use math.type:
> math.type(3)	--> integer
> math.type(3.0)	--> float
Moreover, Lua 5.3 shows them differently:

> 3 --> 3
> 3.0 --> 3.0
> 1000 --> 1000
> 1e3 --> 1000.0
Like many other programming languages, Lua supports hexadecimal constants, by prefixing them with 0x. 
Unlike many other programming languages, Lua supports also floating-point hexadecimal constants,
which can have a fractional part and a binary exponent, prefixed by p or P. The following examples illustrate this format:

> 0xff --> 255
> 0x1A3 --> 419
> 0x0.2 --> 0.125
> 0x1p-1 --> 0.5, (1*(2^-1))
> 0xa.bp2 --> 42.75, (10.6875 *(2^2))
Lua can write numbers in this format using string.format with the %a option:
> string.format("%a", 419)	--> 0x1.a3p+8, (1.63671875*(2^8))
> string.format("%a", 0.1)	--> 0x1.999999999999ap-4
Although not very friendly to humans, this format preserves the full precision of any float value, and the conversion is faster than with decimals.
Arithmetic Operators
Lua presents the usual set of arithmetic operators: addition, subtraction, multiplication, division, and negation (unary minus). 
It also supports floor division, modulo, and exponentiation.
One of the main guidelines for the introduction of integers in Lua 5.3 was that “the programmer may choose to mostly ignore the difference between integers and floats or to assume complete control over the representation of each number.”
Therefore, any arithmetic operator should give the same result when working on integers and when working on reals.
The addition of two integers is always an integer. The same is true for subtraction, multiplication, and negation. 
For those operations, it does not matter whether the operands are integers or floats with integral values (except in case of overflows, which we will discuss in the section called “Representation Limits”); the result is the same in both cases:

> 13 + 15	--> 28
> 13.0 + 15.0	--> 28.0
If both operands are integers, the operation gives an integer result; otherwise, the operation results in a float. 
In case of mixed operands, Lua converts the integer one to a float before the operation:

> 13.0 + 25	--> 38.0
> -(3 * 6.0)	--> -18.0
Division does not follow that rule, because the division of two integers does not need to be an integer. (In mathematical terms, we say that the integers are not closed under division.) To avoid different results between division of integers and divisions of floats, division always operates on floats and gives float results:

> 3.0 / 2.0	--> 1.5
> 3 / 2	--> 1.5
For integer division, Lua 5.3 introduced a new operator, called floor division and denoted by //. As its name implies, floor division always rounds the quotient towards minus infinity, ensuring an integral result for all operands. 
With this definition, this operation can follow the same rule of the other arithmetic operators: if both operands are integers, the result is an integer; otherwise, the result is a float (with an integral value):

> 3 // 2 --> 1
> 3.0 // 2 --> 1.0
> 6 // 2 --> 3
> 6.0 // 2.0 --> 3.0
> -9 // 2 --> -5
> 1.5 // 0.5 --> 3.0

The following equation defines the modulo operator:

a % b == a - ((a // b) * b)
Integral operands ensure integral results, so this operator also follows the rule of other arithmetic operations: 
if both operands are integers, the result is an integer; otherwise, the result is a float.
For integer operands, modulo has the usual meaning, with the result always having the same sign as the second argument. 
In particular, for any given positive constant K, the result of the expression x % K  is always in the range [0,K-1], even when x is negative. 
For instance, i % 2 always results in 0 or 1, for any integer i.
For real operands, modulo has some unexpected uses. For instance, x - x % 0.01 is x with exactly two decimal digits, and x - x % 0.001 is x with exactly three decimal digits:
> x = math.pi
> x - x%0.01	--> 3.14
> x - x%0.001	--> 3.141
As another example of the use of the modulo operator, suppose we want to check whether a vehicle turning a given angle will start to backtrack. 
If the angle is in degrees, we can use the following formula:

local tolerance = 10
function isturnback (angle)
    angle = angle % 360
　return (math.abs(angle - 180) < tolerance)
end
This definition works even for negative angles:

print(isturnback(-180))	--> true
If we want to work with radians instead of degrees, we simply change the constants in our function:

local tolerance = 0.17
function isturnback (angle)
    angle = angle % (2*math.pi)
　return (math.abs(angle - math.pi) < tolerance)
end
The operation angle % (2 * math.pi) is all we need to normalize any angle to a value in the interval [0, 2 * math.pi).
Lua also offers an exponentiation operator, denoted by a caret (^). Like division, it always operates on floats. 
(Integers are not closed under exponentiation; for instance, 2^-2 is not an integer.) We can write x^0.5 to compute the square root of x and x^(1/3) to compute its cubic root.
Relational Operators
Lua provides the following relational operators:
<	>	<=	>=	==	~=
All these operators always produce a Boolean value.

The == operator tests for equality; the ~= operator is the negation of equality. We can apply these operators to any two values. 
If the values have different types, Lua considers them not equal. Otherwise, Lua compares them according to their types.

Comparison of numbers always disregards their subtypes; it makes no difference whether the number is represented as an integer or as a float. 
What matters is its mathematical value. (Nevertheless, it is slightly more efficient to compare numbers with the same subtypes.)
The Mathematical Library
Lua provides a standard math library with a set of mathematical functions, including trigonometric functions (sin, cos, tan, asin, etc.), logarithms, rounding functions, max and min, 
a function for generating pseudo-random numbers (random), plus the constants pi and huge (the largest representable number, which is the special value inf on most platforms.)

> math.sin(math.pi / 2)	--> 1.0
> math.max(10.4, 7, -3, 20)	--> 20
> math.huge	--> inf
All trigonometric functions work in radians. We can use the functions deg and rad to convert between degrees and radians.

Random-number generator
The math.random function generates pseudo-random numbers. We can call it in three ways. 
When we call it without arguments, it returns a pseudo-random real number with uniform distribution in the interval [0,1). 
When we call it with only one argument, an integer n, it returns a pseudo-random integer in the interval [1,n]. 
For instance, we can simulate the result of tossing a die with the call random(6). 
Finally, we can call random with two integer arguments, l and u, to get a pseudo-random integer in the interval [l,u].

We can set a seed for the pseudo-random generator with the function randomseed; its numeric sole argument is the seed. 
When a program starts, the system initializes the generator with the fixed seed. Without another seed, every run of a program will generate the same sequence of pseudo-random numbers. 
For debugging, this is a nice property; but in a game, we will have the same scenario over and over. 
A common trick to solve this problem is to use the current time as a seed, with the call math.randomseed(os.time()). 
Rounding functions
The math library offers three rounding functions: floor, ceil, and modf. Floor rounds towards minus infinite, ceil rounds towards plus infinite, and modf rounds towards zero. 
They return an integer result if it fits in an integer; otherwise, they return a float (with an integral value, of course). 
The function modf, besides the rounded value, also returns the fractional part of the number as a second result.
> math.floor(3.3)	--> 3
> math.floor(-3.3)	--> -4
> math.ceil(3.3) --> 4
> math.ceil(-3.3) --> -3
> math.modf(3.3) --> 3 0.3
> math.modf(-3.3) --> -3 -0.3
> math.floor(2^70)	--> 1.1805916207174e+21
If the argument is already an integer, it is returned unaltered.

If we want to round a number x to the nearest integer, we could compute the floor of x + 0.5. However, this simple addition can introduce errors when the argument is a large integral value. For instance, consider the next fragment:

x = 2^52 + 1
print(string.format("%d %d", x, math.floor(x + 0.5)))
--> 4503599627370497 4503599627370498
What happens is that 2^52 + 1.5 does not have an exact representation as a float, so it is internally rounded in a way that we cannot control. 
To avoid this problem, we can treat integral values separately:

function round (x)
    local f = math.floor(x)
    if x == f then
        return f
    else
        return math.floor(x + 0.5)
    end
end

> math.floor(3.5 + 0.5) --> 4
> math.floor(2.5 + 0.5) --> 3

function round (x)
    local f = math.floor(x)
    if (x == f) or (x % 2.0 == 0.5) then
        return f
    else
　    return math.floor(x + 0.5)
    end
end

print(round(2.5)) --> 2
print(round(3.5)) --> 4
print(round(-2.5)) --> -2
print(round(-1.5)) --> -2

Representation Limits
Most programming languages represent numbers with some fixed number of bits. Therefore, those representations have limits, both in range and in precision.
Standard Lua uses 64-bit integers. Integers with 64 bits can represent values up to 2^63 - 1, roughly 10^19. 
The math library defines constants with the maximum (math.maxinteger) and the minimum (math.mininteger) values for an integer.
This maximum value for a 64-bit integer is a large number: it is thousands times the total wealth on earth counted in cents of dollars and one billion times the world population. 
Despite this large value, overflows occur. When we compute an integer operation that would result in a value smaller than mininteger or larger than maxinteger, the result wraps around.
In mathematical terms, to wrap around means that the computed result is the only number between min- integer and maxinteger that is equal modulo 2^64 to the mathematical result. 
In computational terms, it means that we throw away the last carry bit. (This last carry bit would increment a hypothetical 65th bit, which represents 2^64. Thus, to ignore this bit does not change the modulo 2^64 of the value.) 
This behavior is consistent and predictable in all arithmetic operations with integers in Lua:

> math.maxinteger + 1 == math.mininteger	--> true
> math.mininteger - 1 == math.maxinteger	--> true
> -math.mininteger == math.mininteger	--> true
> math.mininteger // -1 == math.mininteger	--> true
 The maximum representable integer is 0x7ff...fff, that is, a number with all bits set to one except the highest bit, which is the signal bit (zero means a non-negative number). 
When we add one to that number, it becomes 0x800...000, which is the minimum representable integer. 
The minimum integer has a magnitude one larger than the magnitude of the maximum integer, as we can see here:

> math.maxinteger --> 9223372036854775807
> 0x7fffffffffffffff --> 9223372036854775807
> math.mininteger --> -9223372036854775808
> 0x8000000000000000 --> -9223372036854775808
For floating-point numbers, Standard Lua uses double precision. It represents each number with 64 bits, 11 of which are used for the exponent. 
Double-precision floating-point numbers can represent numbers with roughly 16 significant decimal digits, in a range from -10^308 to 10^308. 

The range of double-precision floats is large enough for most practical applications, but we must always acknowledge the limited precision. 
The situation here is not different from what happens with pen and paper. If we use ten digits to represent a number, 1/7 becomes rounded to 0.142857142. 
If we compute 1/7 * 7 using ten digits, the result will be 0.999999994, which is different from 1. 
Moreover, numbers that have a finite representation in decimal can have an infinite representation in binary. 
For instance, 12.7 - 20 + 7.3 is not exactly zero even when computed with double precision, because both 12.7 and 7.3 do not have an exact finite representation in binary.
Because integers and floats have different limits, we can expect that arithmetic operations will give different results for integers and floats when the results reach these limits:

> math.maxinteger + 2	--> -9223372036854775807
> math.maxinteger + 2.0	--> 9.2233720368548e+18
In this example, both results are mathematically incorrect, but in quite different ways. The first line makes an integer addition, so the result wraps around. 
The second line makes a float addition, so the result is rounded to an approximate value, as we can see in the following equality:

> math.maxinteger + 2.0 == math.maxinteger + 1.0	--> true

Each representation has its own strengths. Of course, only floats can represent fractional numbers. Floats have a much larger range, 
but the range where they can represent integers exactly is restricted to [-2^53,2^53]. (Those are quite large numbers nevertheless.) 
Up to these limits, we can mostly ignore the differences between integers and floats. Outside these limits, we should think more carefully about the representations we are using.
Conversions
To force a number to be a float, we can simply add 0.0 to it. An integer always can be converted to a float:
> -3 + 0.0	--> -3.0
> 0x7fffffffffffffff + 0.0	--> 9.2233720368548e+18
Any integer up to 2^53 (which is 9007199254740992) has an exact representation as a double-precision floating-point number. 
Integers with larger absolute values may lose precision when converted to a float:

> 9007199254740991 + 0.0 == 9007199254740991	--> true
> 9007199254740992 + 0.0 == 9007199254740992	--> true
> 9007199254740993 + 0.0 == 9007199254740993	--> false
In the last line, the conversion rounds the integer 2^53+1 to the float 2^53, breaking the equality. To force a number to be an integer, we can OR it with zero:
> 2^53 --> 9.007199254741e+15 (float)
> 2^53 | 0 --> 9007199254740992 (integer)
Lua does this kind of conversion only when the number has an exact representation as an integer, that is, it has no fractional part and it is inside the range of integers. Otherwise, Lua raises an error:

> 3.2 | 0	-- fractional part
stdin:1: number has no integer representation
> 2^64 | 0	-- out of range
stdin:1: number has no integer representation
> math.random(1, 3.5)
stdin:1: bad argument #2 to 'random'
(number has no integer representation)
To round a fractional number, we must explicitly call a rounding function.

Another way to force a number into an integer is to use math.tointeger, which returns nil when the number cannot be converted:

> math.tointeger(-258.0)	--> -258
> math.tointeger(2^30)	--> 1073741824
> math.tointeger(5.01)	--> nil	(not an integral value)
> math.tointeger(2^64)	--> nil	(out of range)
This function is particularly useful when we need to check whether the number can be converted. 
As an example, the following function converts a number to integer when possible, leaving it unchanged otherwise:

function cond2int (x)
    return math.tointeger(x) or x
end

Precedence
Operator precedence in Lua follows the table below, from the higher to the lower priority:

^
unary operators	(- # ~ not)
* / // %
+ -
.. (concatentation)
<< >> (bitwise shifts)
& (bitwise AND)
~ (bitwise exclusive OR)
| (bitwise OR)
< > <= >= ~= ==
and
or

All binary operators are left associative, except for exponentiation and concatenation, which are right associative. 
Therefore, the following expressions on the left are equivalent to those on the right:

a+i < b/2+1 <--> (a+i) < ((b/2)+1)
5+x^2*8 <--> 5+((x^2)*8)
a < y and y <= z <--> (a < y) and (y <= z)
-x^2 <--> -(x^2)
x^y^z <--> x^(y^z)
When in doubt, always use explicit parentheses. It is easier than looking it up in the manual and others will probably have the same doubt when reading your code.

Chapter 4. Strings
Strings in Lua are sequences of bytes. The Lua core is agnostic about how these bytes encode text. Lua is eight-bit clean and its strings can contain bytes with any numeric code, including embedded zeros. 
This means that we can store any binary data into a string. We can also store Unicode strings in any representation (UTF-8, UTF-16, etc.); however, as we will discuss, there are several good reasons to use UTF-8 whenever possible. 
The standard string library that comes with Lua assumes one-byte characters, but it can handle UTF-8 strings quite reasonably. Moreover, since version 5.3, Lua comes with a small library to help the use of UTF-8 encoding.

Strings in Lua are immutable values. We cannot change a character inside a string, as we can in C; instead, we create a new string with the desired modifications, as in the next example:

a = "one string"
b = string.gsub(a, "one", "another")
print(a)	--> one string
print(b)	--> another string
Strings in Lua are subject to automatic memory management, like all other Lua objects (tables, functions, etc.). This means that we do not have to worry about allocation and deallocation of strings; Lua handles it for us.
We can get the length of a string using the length operator (denoted by #): 
a = "hello"
print(#a)	--> 5
print(#"good bye")	--> 8
This operator always counts the length in bytes, which is not the same as characters in some encodings.

We can concatenate two strings with the concatenation operator .. (two dots). If any operand is a number, Lua converts this number to a string:

> "Hello " .. "World"	--> Hello World
> "result is " .. 3	--> result is 3
(Some languages use the plus sign for concatenation, but 3 + 5 is different from 3 .. 5.)
Remember that strings in Lua are immutable values. The concatenation operator always creates a new string, without any modification to its operands:

> a = "Hello"
> a .. " World"	--> Hello World
> a	--> Hello
Literal strings
We can delimit literal strings by single or double matching quotes:

a = "a line"
b = 'another line'

They are equivalent; the only difference is that inside each kind of quote we can use the other quote without escapes.

As a matter of style, most programmers always use the same kind of quotes for the same kind of strings, where the “kinds” of strings depend on the program. 
For instance, a library that manipulates XML may reserve single-quoted strings for XML fragments, because those fragments often contain double quotes.

Strings in Lua can contain the following C-like escape sequences:

\a bell
\b back space
\f form feed
\n newline
\r carriage return
\t horizontal tab
\v vertical tab
\\ backslash
\" double quote
\' single quote
The following examples illustrate their use:

> print("one line\nnext line\n\"in quotes\", 'in quotes'")
one line
next line
"in quotes", 'in quotes'
> print('a backslash inside quotes: \'\\\'')
a backslash inside quotes: '\'
> print("a simpler way: '\\'")
a simpler way: '\'
We can specify a character in a literal string also by its numeric value through the escape sequences \ddd and \xhh, 
where ddd is a sequence of up to three decimal digits and hh is a sequence of exactly two hexadecimal digits. 
As a somewhat artificial example, the two literals "ALO\n123\"" and '\x41LO\10\04923"' have the same value in a system using ASCII: 
0x41 (65 in decimal) is the ASCII code for A, 10 is the code for newline, and 49 is the code for the digit 1. 
(In this example we must write 49 with three digits, as \049, because it is followed by another digit; otherwise Lua would read the escape as \492.) 
We could also write that same string as '\x41\x4c\x4f\x0a\x31\x32\x33\x22', representing each character by its hexadecimal code.

Since Lua 5.3, we can also specify UTF-8 characters with the escape sequence \u{h... h}; we can write any number of hexadecimal digits inside the brackets:

> "\u{3b1} \u{3b2} \u{3b3}"	--> # # #
(The above example assumes an UTF-8 terminal.)

Long strings
We can delimit literal strings also by matching double square brackets, as we do with long comments. 
Literals in this bracketed form can run for several lines and do not interpret escape sequences. 
Moreover, it ignores the first character of the string when this character is a newline. This form is especially convenient for writing strings that contain large pieces of code, as in the following example:

page = [[
<html>
<head>
<title>An HTML Page</title>
</head>
<body>
<a href="http://www.lua.org">Lua</a>
</body>
</html>
]]

write(page)
Sometimes, we may need to enclose a piece of code containing something like a = b[c[i]] (notice the ]] in this code), or we may need to enclose some code that already has some code commented out. 
To handle such cases, we can add any number of equals signs between the two opening brackets, as in [===[. 
After this change, the literal string ends only at the next closing brackets with the same number of equals signs in between (]===], in our example). 
The scanner ignores any pairs of brackets with a different number of equals signs. By choosing an appropriate number of signs, we can enclose any literal string without having to modify it in any way.

This same facility is valid for comments, too. For instance, if we start a long comment with --[=[, it extends until the next ]=]. 
This facility allows us to comment out easily a piece of code that contains parts already commented out.

Long strings are the ideal format to include literal text in our code, but we should not use them for non-text literals. 
Although literal strings in Lua can contain arbitrary bytes, it is not a good idea to use this feature (e.g., you may have problems with your text editor); 
moreover, end-of-line sequences like "\r\n" may be normalized to "\n" when read. 
Instead, it is better to code arbitrary binary data using numeric escape sequences either in decimal or in hexadecimal, such as "\x13\x01\xA1\xBB". 
However, this poses a problem for long strings, because they would result in quite long lines. 
For those situations, since version 5.2 Lua offers the escape sequence \z: it skips all subsequent space characters in the string until the first non-space character. The next example illustrates its use:

data = "\x00\x01\x02\x03\x04\x05\x06\x07\z
\x08\x09\x0A\x0B\x0C\x0D\x0E\x0F"
The \z at the end of the first line skips the following end-of-line and the indentation of the second line, so that the byte \x08 directly follows \x07 in the resulting string.
Coercions
Lua provides automatic conversions between numbers and strings at run time. Any numeric operation applied to a string tries to convert the string to a number. 
Lua applies such coercions not only in arithmetic operators, but also in other places that expect a number, such as the argument to math.sin.
Conversely, whenever Lua finds a number where it expects a string, it converts the number to a string:

print(10 .. 20)	--> 1020
(When we write the concatenation operator right after a numeral, we must separate them with a space; otherwise, Lua thinks that the first dot is a decimal point.)

Many people argue that these automatic coercions were not a good idea in the design of Lua. As a rule, it is better not to count on them. 
They are handy in a few places, but add complexity both to the language and to programs that use them.

As a reflection of this “second-class status”, Lua 5.3 did not implement a full integration of coercions and integers, favoring instead a simpler and faster implementation. 
The rule for arithmetic operations is that the result is an integer only when both operands are integers; a string is not an integer, so any arithmetic operation with strings is handled as a floating-point operation:

> "10" + 1	--> 11.0

To convert a string to a number explicitly, we can use the function tonumber, which returns nil if the string does not denote a proper number. Otherwise, it returns integers or floats, following the same rules of the Lua scanner:

> tonumber("	-3 ")	--> -3
> tonumber(" 10e4 ")	--> 100000.0
> tonumber("10e")	--> nil	(not a valid number)
> tonumber("0x1.3p-4")	--> 0.07421875

By default, tonumber assumes decimal notation, but we can specify any base between 2 and 36 for the conversion:

> tonumber("100101", 2) --> 37
> tonumber("fff", 16) --> 4095
> tonumber("-ZZ", 36) --> -1295
> tonumber("987", 8) --> nil

In the last line, the string does not represent a proper numeral in the given base, so tonumber returns nil. 
To convert a number to a string, we can call the function tostring:
print(tostring(10) == "10")	--> true

These conversions are always valid. Remember, however, that we have no control over the format (e.g., the number of decimal digits in the resulting string). 
For full control, we should use string.format, which we will see in the next section.

Unlike arithmetic operators, order operators never coerce their arguments. Remember that "0" is different from 0. Moreover, 2 < 15 is obviously true, but "2" < "15" is false (alphabetical order). 
To avoid inconsistent results, Lua raises an error when we mix strings and numbers in an order comparison, such as 2 < "15".
The String Library
The power of a raw Lua interpreter to manipulate strings is quite limited. A program can create string literals, concatenate them, compare them, and get string lengths. 
However, it cannot extract substrings or examine their contents. The full power to manipulate strings in Lua comes from its string library.

As I mentioned before, the string library assumes one-byte characters. This equivalence is true for several encodings (e.g., ASCII or ISO-8859-1), but it breaks in any Unicode encoding. 
Nevertheless, as we will see, several parts of the string library are quite useful for UTF-8.

Some functions in the string library are quite simple: the call  string.len(s) returns the length     of a string s; it is equivalent to #s. 
The call string.rep(s, n) returns the string s repeated n times; we can create a string of 1 MB (e.g., for tests) with string.rep("a", 2^20). 
The function string.reverse reverses a string. The call string.lower(s) returns a copy of s with the upper-case letters converted to lower case; 
all other characters in the string are unchanged. The function string.upper converts to upper case.
> string.rep("abc", 3)	--> abcabcabc
> string.reverse("A Long Line!")	--> !eniL gnoL A
> string.lower("A Long Line!")	--> a long line!
> string.upper("A Long Line!")	--> A LONG LINE!
As a typical use, if we want to compare two strings regardless of case, we can write something like this:

string.lower(a) < string.lower(b)
The call string.sub(s, i, j) extracts a piece of the string s, from the i-th to the j-th character inclusive. (The first character of a string has index 1.) 
We can also use negative indices, which count from the end of the string: index -1 refers to the last character, -2 to the previous one, and so on. 
Therefore, the call string.sub(s, 1, j) gets a prefix of the string s with length j; string.sub(s, j, -1) gets a suffix of the string, starting at the j-th character; 
and string.sub(s, 2, -2) returns a copy of the string s with the first and last characters removed:

> s = "[in brackets]"
> string.sub(s, 2, -2)	--> in brackets
> string.sub(s, 1, 1)	--> [
> string.sub(s, -1, -1)	--> ]
Remember that strings in Lua are immutable. Like any other function in Lua, string.sub does not change the value of a string, but returns a new string. 
A common mistake is to write something like string.sub(s, 2, -2) and assume that it will modify the value of s. 
If we want to modify the value of a variable, we must assign the new value to it:

s = string.sub(s, 2, -2)

The functions string.char and string.byte convert between characters and their internal numeric representations. 
The function string.char gets zero or more integers, converts each one to a character, and returns a string concatenating all these characters. 
The call string.byte(s, i) returns the internal numeric representation of the i-th character of the string s; the second argument is optional; 
the call string.byte(s) returns the internal numeric representation of the first (or single) character of s. The following examples assume the ASCII encoding for characters:

print(string.char(97))	--> a
i = 99;
print(string.char(i, i+1, i+2))	--> cde
print(string.byte("abc"))	--> 97
print(string.byte("abc", 2))	--> 98
print(string.byte("abc", -1))	--> 99
In the last line, we used a negative index to access the last character of the string.

A call like string.byte(s, i, j) returns multiple values with the numeric representation of all characters between indices i and j (inclusive):

print(string.byte("abc", 1, 2))	--> 97 98
A nice idiom is {string.byte(s, 1, -1)}, which creates a list with the codes of all characters in s. 
(This idiom only works for strings somewhat shorter than 1 MB. Lua limits its stack size, which in turn limits the maximum number of returns from a function. The default stack limit is one million entries.)


The function string.format is a powerful tool for formatting strings and converting numbers to strings. It returns a copy of its first argument, the so-called format string, 
with each directive in that string replaced by a formatted version of its correspondent argument. 
The directives in the format string have rules similar to those of the C function printf. A directive is a percent sign plus a letter that tells how to format the argument: 
d for a decimal integer, x for hexadecimal, f for a floating-point number, s for strings, plus several others.

> string.format("x = %d	y = %d", 10, 20)	--> x = 10	y = 20
> string.format("x = %x", 200)	--> x = c8
> string.format("x = 0x%X", 200)	--> x = 0xC8
> string.format("x = %f", 200)	--> x = 200.000000
> tag, title = "h1", "a title"
> string.format("<%s>%s</%s>", tag, title, tag)
--> <h1>a title</h1>

Between the percent sign and the letter, a directive can include other options that control the details of the formatting, 
such as the number of decimal digits of a floating-point number:

print(string.format("pi = %.4f", math.pi))	--> pi = 3.1416
d = 5; m = 11; y = 1990
print(string.format("%02d/%02d/%04d", d, m, y)) --> 05/11/1990

In the first example, the %.4f means a floating-point number with four digits after the decimal point. In the second example, the %02d means a decimal number with zero padding and at least two digits; 
the directive %2d, without the zero, would use blanks for padding. For a complete description of these directives, see the documentation of the C function printf, as Lua calls the standard C library to do the hard work here.
We can call all functions from the string library as methods on strings, using the colon operator. 
For instance, we can rewrite the call string.sub(s, i, j) as s:sub(i, j); string.upper(s) becomes s:upper(). 
(We will discuss the colon operator in detail in Chapter 21, Object-Oriented Programming.)

The string library includes also several functions based on pattern matching. 
The function string.find searches for a pattern in a given string:

> string.find("hello world", "wor")	--> 7	9
> string.find("hello world", "war")	--> nil

It returns the initial and final positions of the pattern in the string, or nil if it cannot find the pattern.   
The function string.gsub (Global SUBstitution) replaces all occurrences of a pattern in a string with another string:

> string.gsub("hello world", "l", ".") --> he..o wor.d 3
> string.gsub("hello world", "ll", "..") --> he..o world 1
> string.gsub("hello world", "a", ".") --> hello world 0

It also returns, as a second result, the number of replacements it made.

We will discuss more about these functions and all about pattern matching in Chapter 10, Pattern Matching.

Unicode
Since version 5.3, Lua includes a small library to support operations on Unicode strings encoded in UTF-8. Even before that library, Lua already offered a reasonable support for UTF-8 strings.

UTF-8 is the dominant encoding for Unicode on the Web. Because of its compatibility with ASCII, UTF-8 is also the ideal encoding for Lua. That compatibility is enough to ensure that several string-manipulation techniques that work on ASCII strings also work on UTF-8 with no modifications.

UTF-8 represents each Unicode character using a variable number of bytes. For instance, it represents A with one byte, 65; it represents the Hebrew character Aleph, which has code 1488 in Unicode, with the two-byte sequence 215–144. 
UTF-8 represents all characters in the ASCII range as in ASCII, that is, with a single byte smaller than 128. It represents all other characters using sequences of bytes where the first byte is in the range [194,244] and the continuation bytes are in the range [128,191]. 
More specifically, the range of the starting bytes for two-byte sequences is [194,223]; for three-byte sequences, the range  is [224,239]; and for four-byte sequences, it is [240,244]. 
None of those ranges overlap. This property ensures that the code sequence of any character never appears as part of the code sequence of any other character. 
In particular, a byte smaller than 128 never appears in a multibyte sequence; it always represents its corresponding ASCII character.
Several things in Lua “just work” for UTF-8 strings. Because Lua is 8-bit clean, it can read, write, and store UTF-8 strings just like other strings. Literal strings can contain UTF-8 data. (Of course, you probably will want to edit your source code as a UTF-8 file in a UTF-8–aware editor.) 
The concatenation operation works correctly for UTF-8 strings. String order operators (less than, less equal, etc.) compare UTF-8 strings following the order of their character codes in Unicode.

Lua's operating-system library and I/O library are mainly interfaces to the underlying system, so their support for UTF-8 strings depends on that underlying system. 
On Linux, for instance, we can use UTF-8 for file names, but Windows uses UTF-16. Therefore, to manipulate Unicode file names on Windows, we need either extra libraries or changes to the standard Lua libraries.

Let us now see how functions from the string library handle UTF-8 strings. The functions reverse,  upper, lower, byte, and char do not work for UTF-8 strings, 
as all of them assume that one character is equivalent to one byte. The functions string.format and string.rep work without problems with UTF-8 strings except for the format option '%c', which assumes that one character is one byte. 
The functions string.len and string.sub work correctly with UTF-8 strings, with indices referring to byte counts (not character counts). More often than not, this is what we need.

Let us now have a look at the new utf8 library. The function utf8.len returns the number of UTF-8 characters (codepoints) in a given string. 
Moreover, it validates the string: if it finds any invalid byte sequence, it returns false plus the position of the first invalid byte:

> utf8.len("résumé") --> 6
> utf8.len("ação") --> 4
> utf8.len("Månen") --> 5
> utf8.len("ab\x93") --> nil 3
(Of course, to run these examples we need a terminal that understands UTF-8.)

The functions utf8.char and utf8.codepoint are the equivalent of string.char and string.byte in the UTF-8 world:
> utf8.char(114, 233, 115, 117, 109, 233)	--> résumé
> utf8.codepoint("résumé", 6, 7)	--> 109	233
Note the indices in the last line. Most functions in the utf8 library work with indices in bytes. 
For instance, the call string.codepoint(s, i, j) considers both i and j to be byte positions in string s. 
If we want to use character indices, the function utf8.offset converts a character position to a byte position:
> s = "Nähdään"
> utf8.codepoint(s, utf8.offset(s, 5))	--> 228
> utf8.char(228)	--> ä
In this example, we used utf8.offset to get the byte index of the fifth character in the string, and then provided that index to codepoint.
As in the string library, the character index for utf8.offset can be negative, in which case the counting is from the end of the string:

> s = "ÃøÆËÐ"
> string.sub(s, utf8.offset(s, -2))	--> ËÐ
The last function in the utf8 library is utf8.codes. It allows us to iterate over the characters in a UTF-8 string:

for i, c in utf8.codes("Ação") do
    print(i, c)
end
--> 1 65
--> 2 231
--> 4 227
--> 6 111
This construction traverses all characters in the given string, assigning its position in bytes and its numeric code to two local variables. 
In our example, the loop body only prints the values of those variables. (We will discuss iterators in more detail in Chapter 18, Iterators and the Generic for.)
Unfortunately, there is not much more that Lua can offer. Unicode has too many peculiarities. It is virtually impossible to abstract almost any concept from specific languages. 
Even the concept of what is a character is vague, because there is no one-to-one correspondence between Unicode coded characters and graphemes. 
For instance, the common grapheme é can be represented by a single codepoint ("\u{E9}") or by two codepoints, an e followed by a diacritical mark ("e\u{301}"). 
Other apparently basic concepts, such as what is a letter, also change across different languages. Because of this complexity, complete support for Unicode demands huge tables, which are incompatible with the small size of Lua. 
So, for anything fancier, the best approach is an external library.

Chapter 5. Tables
Tables are the main (in fact, the only) data structuring mechanism in Lua, and a powerful one. We use tables to represent arrays, sets, records, and many other data structures in a simple, uniform, and efficient way. 
Lua uses tables to represent packages and objects as well. When we write math.sin, we think about “the function sin from the math library”. 
For Lua, this expression means “index the table math using the string "sin" as the key”.
A table in Lua is essentially an associative array. A table is an array that accepts not only numbers as indices, but also strings or any other value of the language (except nil).
Tables in Lua are neither values nor variables; they are objects. If you are familiar with arrays in Java or Scheme, then you have a fair idea of what I mean. 
You may think of a table as a dynamically-allocated object; programs manipulate only references (or pointers) to them. Lua never does hidden copies or creation of new tables behind the scenes.
We create tables by means of a constructor expression, which in its simplest form is written as {}:
> a = {}	-- create a table and assign its reference
> k = "x"
> a[k] = 10	-- new entry, with key="x" and value=10
> a[20] = "great"	-- new entry, with key=20 and value="great"
> a["x"]	--> 10
> k = 20
> a[k]	--> "great"
> a["x"] = a["x"] + 1	-- increments entry "x"
> a["x"]	--> 11
A table is always anonymous. There is no fixed relationship between a variable that holds a table and the table itself:

> a = {}
> a["x"] = 10
> b = a	-- 'b' refers to the same table as 'a'
> b["x"]	--> 10
> b["x"] = 20
> a["x"]	--> 20
> a = nil	-- only 'b' still refers to the table
> b = nil	-- no references left to the table
When a program has no more references to a table, the garbage collector will eventually delete the table and reuse its memory.
Table Indices
Each table can store values with different types of indices, and it grows as needed to accommodate new entries:

> a = {}	-- empty table
> -- create 1000 new entries
> for i = 1, 1000 do a[i] = i*2 end
> a[9]	--> 18
> a["x"] = 10
> a["x"]	--> 10
> a["y"]	--> nil
Note the last line: like global variables, table fields evaluate to nil when not initialized. Also like global variables, we can assign nil to a table field to delete it. 
This is not a coincidence: Lua stores global variables in ordinary tables. (We will discuss this subject further in Chapter 22, The Environment.)

To represent structures, we use the field name as an index. Lua supports this representation by providing a.name as syntactic sugar for a["name"]. 
Therefore, we could write the last lines of the previous example in a cleaner manner as follows:

> a = {} -- empty table
> a.x = 10 -- same as a["x"] = 10
> a.x --> 10 -- same as a["x"]
> a.y --> nil -- same as a["y"]
For Lua, the two forms are equivalent and can be intermixed freely. For a human reader, however, each form may signal a different intention. 
The dot notation clearly shows that we are using the table as a structure, where we have some set of fixed, predefined keys. 
The string notation gives the idea that the table can have any string as a key, and that for some reason we are manipulating that specific key.

A common mistake for beginners is to confuse a.x with a[x]. The first form represents a["x"], that is, a table indexed by the string "x". 
The second form is a table indexed by the value of the variable x. See the difference:

> a = {}
> x = "y"
> a[x] = 10 -- put 10 in field "y"
> a[x] --> 10 -- value of field "y"
> a.x --> nil -- value of field "x" (undefined)
> a.y --> 10 -- value of field "y"
Because we can index a table with any type, when indexing a table we have the same subtleties that arise in equality. 
Although we can index a table both with the number 0 and with the string "0", these two values are different and therefore denote different entries in a table. 
Similarly, the strings "+1", "01", and "1" all denote different entries. When in doubt about the actual types of your indices, use an explicit conversion to be sure:

> i = 10; j = "10"; k = "+10"
> a = {}
> a[i] = "number key"
> a[j] = "string key"
> a[k] = "another string key"
> a[i]	--> number key
> a[j]	--> string key
> a[k]	--> another string key
> a[tonumber(j)]	--> number key
> a[tonumber(k)]	--> number key
You can introduce subtle bugs in your program if you do not pay attention to this point.

Integers and floats do not have the above problem. In the same way that 2 compares equal to 2.0, both values refer to the same table entry, when used as keys:

> a = {}
> a[2.0] = 10
> a[2.1] = 20
> a[2]	--> 10
> a[2.1]	--> 20
More specifically, when used as a key, any float value that can be converted to an integer is converted. For instance, when Lua executes a[2.0] = 10, it converts the key 2.0 to 2. 
Float values that cannot be converted to integers remain unaltered.
Table Constructors
Constructors are expressions that create and initialize tables. They are a distinctive feature of Lua and one of its most useful and versatile mechanisms.
The simplest constructor is the empty constructor, {}, as we have seen. Constructors also initialize lists. 
For instance, the following statement will initialize days[1] with the string "Sunday" (the first element of the constructor has index 1, not 0), days[2] with "Monday", and so on:
days = {"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"}

print(days[4])	--> Wednesday
Lua also offers a special syntax to initialize a record-like table, as in the next example:

a = {x = 10, y = 20}
This previous line is equivalent to these commands:

a = {}; a.x = 10; a.y = 20
The original expression, however, is faster, because Lua creates the table already with the right size.

No matter what constructor we use to create a table, we can always add fields to and remove fields from the result:

w = {x = 0, y = 0, label = "console"}
x = {math.sin(0), math.sin(1), math.sin(2)}
w[1] = "another field"	-- add key 1 to table 'w'
x.f = w	-- add key "f" to table 'x'
print(w["x"])	--> 0
print(w[1])	--> another field
print(x.f[1])	--> another field
w.x = nil	-- remove field "x"
However, as I just mentioned, creating a table with a proper constructor is more efficient, besides being cleaner.
We can mix record-style and list-style initializations in the same constructor:

polyline = {color="blue",
thickness=2, 
npoints=4,
{x=0,	y=0},	-- polyline[1]
{x=-10, y=0},	-- polyline[2]
{x=-10, y=1},	-- polyline[3]
{x=0,	y=1}	-- polyline[4]
}

The above example also illustrates how we can nest tables (and constructors) to represent more complex data structures. 
Each of the elements polyline[i] is a table representing a record:
print(polyline[2].x)	--> -10
print(polyline[4].y)	--> 1
Those two constructor forms have their limitations. For instance, we cannot initialize fields with negative indices, nor with string indices that are not proper identifiers. 
For such needs, there is another, more general, format. In this format, we explicitly write each index as an expression, between square brackets:

opnames = {["+"] = "add", ["-"] = "sub",
                    ["*"] = "mul", ["/"] = "div"}

i = 20; s = "-"
a = {[i+0] = s, [i+1] = s..s, [i+2] = s..s..s}

print(opnames[s])	--> sub
print(a[22])	--> ---
This syntax is more cumbersome, but more flexible too: both the list-style and the record-style forms are special cases of this more general syntax, as we show in the following equivalences:

{x = 0, y = 0} <--> {["x"] = 0, ["y"] = 0}
{"r", "g", "b"} <--> {[1] = "r", [2] = "g", [3] = "b"}
We can always put a comma after the last entry. These trailing commas are optional, but are always valid:

a = {[1] = "red", [2] = "green", [3] = "blue",}
This flexibility frees programs that generate Lua constructors from the need to handle the last element as a special case.

Finally, we can always use a semicolon instead of a comma in a constructor. This facility is a leftover from older Lua versions and I guess it is seldom used nowadays.
Arrays, Lists, and Sequences
To represent a conventional array or a list, we simply use a table with integer keys. There is neither a way nor a need to declare a size; we just initialize the elements we need:

-- read 10 lines, storing them in a table
a = {}
for i = 1, 10 do
    a[i] = io.read()
end
Given that we can index a table with any value, we can start the indices of an array with any number that pleases us. 
However, it is customary in Lua to start arrays with one (and not with zero, as in C) and many facilities in Lua stick to this convention.

Usually, when we manipulate a list we must know its length. It can be a constant or it can be stored somewhere. 
Often we store the length of a list in a non-numeric field of the table; for historical reasons, several programs use the field "n" for this purpose. 
Often, however, the length is implicit. Remember that any non-initialized index results in nil; we can use this value as a sentinel to mark the end of the list. 
For instance, after we read 10 lines into a list, it is easy to know that its length is 10, because its numeric keys are 1, 2, ..., 10. 
This technique only works when the list does not have holes, which are nil elements inside it. We call such a list without holes a sequence.
For sequences, Lua offers the length operator (#). As we have seen, on strings it gives the number of bytes in the string. 
On tables, it gives the length of the sequence represented by the table. For instance, we could print the lines read in the last example with the following code:

-- print the lines, from 1 to #a
for i = 1, #a do
    print(a[i])
end
The length operator also provides a useful idiom for manipulating sequences:

a[#a + 1] = v	-- appends 'v' to the end of the sequence
The length operator is unreliable for lists with holes (nils). It only works for sequences, which we defined as lists without holes. 
More precisely, a sequence is a table where the positive numeric keys comprise a set {1,...,n} for some n. (Remember that any key with value nil is actually not in the table.) 
In particular, a table with no numeric keys is a sequence with length zero.

The behavior of the length operator for lists with holes is one of the most contentious features of Lua. Over the years, there have been many proposals either to raise an error when we apply the length operator to a list with holes, or to extend its meaning to those lists. 
However, these proposals are easier said than done. The problem is that, because a list is actually a table, the concept of “length” is somewhat fuzzy. 
For instance, consider the list resulting from the following code:

a = {}
a[1] = 1
a[2] = nil	-- does nothing, as a[2] is already nil
a[3] = 1
a[4] = 1
It is easy to say that the length of this list is four, and that is has a hole at index 2. However, what can we say about the next similar example?

a = {}
a[1] = 1
a[10000] = 1
Should we consider a as a list with 10000 elements, with 9998 holes? Now, the program does this:
a[10000] = nil
What is the list length now? Should it be 9999, because the program deleted the last element? 
Or maybe still 10000, as the program only changed the last element to nil? Or should the length collapse to one?
Another common proposal is to make the # operator return the total number of elements in the table. This semantics is clear and well defined, but not very useful or intuitive. 
Consider all the examples we are discussing here and think how useful would be such operator for them.

Yet more troubling are nils at the end of the list. What should be the length of the following list?

a = {10, 20, 30, nil, nil}
Remember that, for Lua, a field with nil is indistinct from an absent field. Therefore, the previous table is equal to {10, 20, 30}; its length is 3, not 5.

You may consider that a nil at the end of a list is a very special case. However, many lists are built by adding elements one by one. 
Any list with holes that was built that way must have had nils at its end along the way.

Despite all these discussions, most lists we use in our programs are sequences (e.g., a file line cannot be nil) and, therefore, most of the time the use of the length operator is safe. 
If you really need to handle lists with holes, you should store the length explicitly somewhere.

Table Traversal
We can traverse all key–value pairs in a table with the pairs iterator:

t = {10, print, x = 12, k = "hi"}
for k, v in pairs(t) do
    print(k, v)
end
--> 1	10
--> k	hi
--> 2	function: 0x420610
--> x	12

Due to the way that Lua implements tables, the order that elements appear in a traversal is undefined. The same program can produce different orders each time it runs. 
The only certainty is that each element will appear once during the traversal.

For lists, we can use the ipairs iterator:

t = {10, print, 12, "hi"}
for k, v in ipairs(t) do
    print(k, v)
end
--> 1 10
--> 2 function: 0x420610
--> 3 12
--> 4 hi

In this case, Lua trivially ensures the order.

Another way to traverse a sequence is with a numerical for:

t = {10, print, 12, "hi"}
for k = 1, #t do
    print(k, t[k])
end
--> 1	10
--> 2	function: 0x420610
--> 3	12
--> 4	hi

Safe Navigation
Suppose the following situation: we want to know whether a given function from a given library is present. 
If we know for sure that the library itself exists, we can write something like if lib.foo then ....
Otherwise, we have to write something like if lib and lib.foo then ....


When the level of nested tables gets deeper, this notation becomes problematic, as the next example illustrates:

zip = company and company.director and company.director.address and company.director.address.zipcode

This notation is not only cumbersome, but inefficient, too. It performs six table accesses in a successful access, instead of three.

Some programming languages, such as C#, offer a safe navigation operator (written as ?. in C#) for this task. 
When we write a ?. b and a is nil, the result is also nil, instead of an error. Using that operator, we could write our previous example like this:

zip = company?.director?.address?.zipcode

If any component in the path were nil, the safe operator would propagate that nil until the final result.

Lua does not offer a safe navigation operator, and we do not think it should. Lua is minimalistic. Moreover, this operator is quite controversial, with many people arguing —not without some reason— that it promotes careless programming. 
However, we can emulate it in Lua with a bit of extra notation.

If we execute a or {} when a is nil, the result is the empty table. So, if we execute (a or {}).b
when a is nil, the result will be also nil. Using this idea, we can rewrite our original expression like this:

zip = (((company or {}).director or {}).address or {}).zipcode

Still better, we can make it a little shorter and slightly more efficient:

E = {}	-- can be reused in other similar expressions
...
zip = (((company or E).director or E).address or E).zipcode

Granted, this syntax is more complex than the one with the safe navigation operator. Nevertheless, we write each field name only once, it performs the minimum required number of table accesses (three, in this example), and it requires no new operators in the language. 
In my personal opinion, it is a good enough substitute.

The Table Library
The table library offers several useful functions to operate over lists and sequences.
The function table.insert inserts an element in a given position of a sequence, moving up other elements to open space. 
For instance, if t is the list {10, 20, 30}, after the call table.insert(t, 1, 15) it will become {15, 10, 20, 30}. 
As a special and frequent case, if we call insert without a position, it inserts the element in the last position of the sequence, moving no elements. 
As an example, the following code reads the input stream line by line, storing all lines in a sequence:

t = {}
for line in io.lines() do
    table.insert(t, line)
end
print(#t)	--> (number of lines read)

The function table.remove removes and returns an element from the given position in a sequence, moving subsequent elements down to fill the gap. 
When called without a position, it removes the last element of the sequence.
With these two functions, it is straightforward to implement stacks, queues, and double queues. 
We can initialize such structures as t = {}. A push operation is equivalent to table.insert(t, x); a pop operation is equivalent to table.remove(t). 
The call table.insert(t, 1, x) inserts at the other end of the structure (its beginning, actually), and table.remove(t, 1) removes from this end. 
The last two operations are not particularly efficient, as they must move elements up and down. However, because the table library implements these functions in C, 
these loops are not too expensive, so that this implementation is good enough for small arrays (up to a few hundred elements, say).
Lua 5.3 has introduced a more general function for moving elements in a table. 
The call table.move(a, f, e, t) moves the elements in table a from index f until e (both inclusive) to position t. 
For instance, to insert an element in the beginning of a list a, we can do the following:
table.move(a, 1, #a, 2)
a[1] = newElement
The next code removes the first element:
table.move(a, 2, #a, 1)
a[#a] = nil
Note that, as is common in computing, a move actually copies values from one place to another. In this last example, we must explicitly erase the last element after the move.
We can call table.move with an extra optional parameter, a table. In that case, the function moves the elements from the first table into the second one. 
For instance, the call table.move(a, 1, #a, 1, {}) returns a clone of list a (by copying all its elements into a new list), while table.move(a, 1, #a, #b + 1, b) appends all elements from list a to the end of list b.

Chapter 6. Functions
Functions can both carry out a specific task (what is sometimes called a procedure or a subroutine in other languages) or compute and return values. 
In the first case, we use a function call as a statement; in the second case, we use it as an expression:

print(8*9, 9/8)
a = math.sin(3) + math.cos(10)
print(os.date())
In both cases, a list of arguments enclosed in parentheses denotes the call; if the call has no arguments, we still must write an empty list () to denote it. 
There is a special case to this rule: if the function has one single argument and that argument is either a literal string or a table constructor, then the parentheses are optional:

print "Hello World" <--> print("Hello World")
dofile 'a.lua' <--> dofile ('a.lua')
print [[a multi-line 
message]] <--> print([[a multi-line 
message]])
f{x=10, y=20} <--> f({x=10, y=20})
type{} <--> type({})
Lua also offers a special syntax for object-oriented calls, the colon operator. An expression like o:foo(x) calls the method foo in the object o. 
In Chapter 21, Object-Oriented Programming, we will discuss such calls and object-oriented programming in more detail.

A Lua program can use functions defined both in Lua and in C (or in any other language used by the host application). 
Typically, we resort to C functions both to achieve better performance and to access facilities not easily accessible directly from Lua, such as operating-system facilities. 
As an example, all functions from the standard Lua libraries are written in C. However, when calling a function, there is no difference between functions defined in Lua and functions defined in C.
As we saw in other examples, a function definition in Lua has a conventional syntax, like here:

-- add the elements of sequence 'a'
function add (a)
    local sum = 0
    for i = 1, #a do
　    sum = sum + a[i]
    end
　return sum
end
In this syntax, a function definition has a name (add, in the example), a list of parameters, and a body, which is a list of statements. 
Parameters work exactly as local variables initialized with the values of the arguments passed in the function call.
We can call a function with a number of arguments different from its number of parameters. Lua adjusts the number of arguments to the number of parameters by throwing away extra arguments and supplying nils to extra parameters. 
For instance, consider the next function:

function f (a, b)
    print(a, b)
end
It has the following behavior:
f() --> nil nil
f(3) --> 3 nil
f(3, 4) --> 3 4
f(3, 4, 5) --> 3 4 (5 is discarded)

Although this behavior can lead to programming errors (easily spotted with minimal tests), it is also useful, especially for default arguments. 
As an example, consider the following function, to increment a global counter:

function incCount (n)
    n = n or 1
　globalCounter = globalCounter + n
end

This function has 1 as its default argument; the call incCount(), without arguments, increments globalCounter by one. 
When we call incCount(), Lua first initializes the parameter n with nil; the or expression results in its second operand and, as a result, Lua assigns a default 1 to n.
Multiple Results
An unconventional but quite convenient feature of Lua is that functions can return multiple results. Several predefined functions in Lua return multiple values. 
We have already seen the function string.find, which locates a pattern in a string. This function returns two indices when it finds the pattern: 
the index of the character where the match starts and the one where it ends. A multiple assignment allows the program to get both results:
s, e = string.find("hello Lua users", "Lua")
print(s, e)	--> 7	9
(Remember that the first character of a string has index 1.)

Functions that we write in Lua also can return multiple results, by listing them all after the return keyword. 
For instance, a function to find the maximum element in a sequence can return both the maximum value and its location:

function maximum (a)
    local mi = 1	-- index of the maximum value
    local m = a[mi]	-- maximum value
    for i = 1, #a do
        if a[i] > m then
　        mi = i; m = a[i]
        end
    end
　return m, mi	-- return the maximum and its index
end

print(maximum({8,10,23,12,5}))	--> 23	3

Lua always adjusts the number of results from a function to the circumstances of the call. When we call a function as a statement, Lua discards all results from the function. 
When we use a call as an expression (e.g., the operand of an addition), Lua keeps only the first result. 
We get all results only when the call is the last (or the only) expression in a list of expressions. 
These lists appear in four constructions in Lua: multiple assignments, arguments to function calls, table constructors, and return statements. 
To illustrate all these cases, we will assume the following definitions for the next examples:

function foo0 () end	-- returns no results
function foo1 () return "a" end	-- returns 1 result
function foo2 () return "a", "b" end	-- returns 2 results
In a multiple assignment, a function call as the last (or only) expression produces as many results as needed to match the variables:

x, y = foo2()	-- x="a", y="b"
x = foo2()	-- x="a", "b" is discarded
x, y, z = 10, foo2()	-- x=10, y="a", z="b"
In a multiple assignment, if a function has fewer results than we need, Lua produces nils for the missing values:

x,y = foo0()	-- x=nil, y=nil
x,y = foo1()	-- x="a", y=nil
x,y,z = foo2()	-- x="a", y="b", z=nil
Remember that multiple results only happen when the call is the last (or only) expression in a list. 
A function call that is not the last element in the list always produces exactly one result:

x,y = foo2(), 20 -- x="a", y=20 ('b' discarded)
x,y = foo0(), 20, 30 -- x=nil, y=20 (30 is discarded)
When a function call is the last (or the only) argument to another call, all results from the first call go as arguments. 
We saw examples of this construction already, with print. Because print can receive a variable number of arguments, the statement print(g()) prints all results returned by g.

print(foo0()) --> (no results)
print(foo1()) --> a
print(foo2())  --> a b
print(foo2(), 1) --> a 1
print(foo2() .. "x")	--> ax	(see next)
When the call to foo2 appears inside an expression, Lua adjusts the number of results to one; so, in the last line, the concatenation uses only the first result, "a".
If we write f(g()), and f has a fixed number of parameters, Lua adjusts the number of results from   g to the number of parameters of f. 
Not by chance, this is exactly the same behavior that happens in a multiple assignment.

A constructor also collects all results from a call, without any adjustments:

t = {foo0()}	-- t = {}	(an empty table)
t = {foo1()}	-- t = {"a"}
t = {foo2()}	-- t = {"a", "b"}
As always, this behavior happens only when the call is the last expression in the list; calls in any other position produce exactly one result:

t = {foo0(), foo2(), 4}	-- t[1] = nil, t[2] = "a", t[3] = 4
Finally, a statement like return f() returns all values returned by f: 
function foo(i)
    if i == 0 then
        return foo0()
    elseif i == 1 then
        return foo1()
    elseif i == 2 then
        return foo2()
    end
end

print(foo(1))	--> a
print(foo(2))	--> a	b
print(foo(0))	-- (no results)
print(foo(3))	-- (no results)
We can force a call to return exactly one result by enclosing it in an extra pair of parentheses:

print((foo0()))	--> nil
print((foo1()))	--> a
print((foo2()))	--> a
Beware that a return statement does not need parentheses around the returned value; any pair of parentheses placed there counts as an extra pair. 
Therefore, a statement like return (f(x)) always returns one single value, no matter how many values f returns. Sometimes this is what we want, sometimes not.
Variadic Functions
A function in Lua can be variadic, that is, it can take a variable number of arguments. For instance, we have already called print with one, two, and more arguments. 
Although print is defined in C, we can define variadic functions in Lua, too.

As a simple example, the following function returns the summation of all its arguments:

function add(...)
    local s = 0
    for _, v in ipairs({...}) do
        s = s + v
    end
    return s
end

print(add(3, 4, 10, 25, 12))	--> 54
The three dots (...) in the parameter list indicate that the function is variadic. When we call this function, Lua collects all its arguments internally; 
we call these collected arguments the extra arguments of the function. A function accesses its extra arguments using again the three dots, now as an expression. 
In our example, the expression {...} results in a list with all collected arguments. The function then traverses the list to add its elements.

We call the three-dot expression a vararg expression. It behaves like a multiple return function, returning all extra arguments of the current function. 
For instance, the command print(...) prints all extra arguments of the function. 
Likewise, the next command creates two local variables with the values of the first two optional arguments (or nil if there are no such arguments):

local a, b = ...
Actually, we can emulate the usual parameter-passing mechanism of Lua translating

function foo (a, b, c)
to

function foo (...)
    local a, b, c = ...
Those who fancy Perl's parameter-passing mechanism may enjoy this second form. A function like the next one simply returns all its arguments:
function id (...)
    return ...
end
It is a multi-value identity function. The next function behaves exactly like another function foo, except that before the call it prints a message with its arguments:

function foo1 (...)
    print("calling foo:", ...)
    return foo(...)
end
This is a useful trick for tracing calls to a specific function.
Let us see another useful example. Lua provides separate functions for formatting text (string.format) and for writing text (io.write). 
It is straightforward to combine both functions into a single variadic function:

function fwrite (fmt, ...)
    return io.write(string.format(fmt, ...))
end
Note the presence of a fixed parameter fmt before the dots. Variadic functions can have any number of fixed parameters before the variadic part. 
Lua assigns the first arguments to these parameters; the rest (if any) goes as extra arguments.
To iterate over its extra arguments, a function can use the expression {...} to collect them all in a table, as we did in our definition of add. 
However, in the rare occasions when the extra arguments can be valid nils, the table created with {...} may not be a proper sequence. 
For instance, there is no way to detect in such a table whether there were trailing nils in the original arguments. 
For these occasions, Lua offers the function table.pack. This function receives any number of arguments and returns a new table with all its arguments (just like {...}), 
but this table has also an extra field "n", with the total number of arguments. As an example, the following function uses table.pack to test whether none of its arguments is nil:

function nonils (...)
    local arg = table.pack(...)
    for i = 1, arg.n do
        if arg[i] == nil then
            return false
        end
    end
    return true
end

print(nonils(2,3,nil))	--> false
print(nonils(2,3))	--> true
print(nonils())	--> true
print(nonils(nil))	--> false
Another option to traverse the variable arguments of a function is the select function. 
A call to select has always one fixed argument, the selector, plus a variable number of extra arguments. 
If the selector is a number n, select returns all arguments after the n-th argument; otherwise, the selector should be the string "#", 
so that select returns the total number of extra arguments.

print(select(1, "a", "b", "c")) --> a b	c
print(select(2, "a", "b", "c")) --> b c
print(select(3, "a", "b", "c")) --> c
print(select("#", "a", "b", "c")) --> 3

More often than not, we use select in places where its number of results is adjusted to one, so we can think about select(n, ...) as returning its n-th extra argument.
As a typical example of the use of select, here is our previous add function using it:

function add (...)
    local s = 0
    for i = 1, select("#", ...) do
        s = s + select(i, ...)
    end
    return s
end
For few arguments, this second version of add is faster, because it avoids the creation of a new table   at each call. 
For more arguments, however, the cost of multiple calls to select with many arguments outperforms the cost of creating a table, so the first version becomes a better choice. 
(In particular, the second version has a quadratic cost, because both the number of iterations and the number of arguments passed in each iteration grow with the number of arguments.)

The function table.unpack
A special function with multiple returns is table.unpack. It takes a list and returns as results all elements from the list:

print(table.unpack{10,20,30})	--> 10	20	30
a,b = table.unpack{10,20,30}	-- a=10, b=20, 30 is discarded

As the name implies, table.unpack is the reverse of table.pack. While pack transforms a parameter list into a real Lua list (a table), unpack transforms a real Lua list (a table) into a return list, which can be given as the parameter list to another function.

An important use for unpack is in a generic call mechanism. A generic call mechanism allows us to call any function, with any arguments, dynamically. 
In ISO C, for instance, there is no way to code a generic call. We can declare a function that takes a variable number of arguments (with stdarg.h) and we can call a variable function, using pointers to functions. 
However, we cannot call a function with a variable number of arguments: each call you write in C has a fixed number of arguments, and each argument has a fixed type. 
In Lua, if we want to call a variable function f with variable arguments in an array a, we simply write this:

f(table.unpack(a))

The call to unpack returns all values in a, which become the arguments to f. For instance, consider the following call:

print(string.find("hello", "ll"))
We can dynamically build an equivalent call with the following code:

f = string.find
a = {"hello", "ll"}

print(f(table.unpack(a)))
Usually, table.unpack uses the length operator to know how many elements to return, so it works only on proper sequences. If needed, however, we can provide explicit limits:

print(table.unpack({"Sun", "Mon", "Tue", "Wed"}, 2, 3)) --> Mon	Tue
Although the predefined function unpack is written in C, we could write it also in Lua, using recursion:
function unpack(t, i, n)
    i = i or 1
    n = n or #t
    if i <= n then
　    return t[i], unpack(t, i + 1, n)
    end
end
The first time we call it, with a single argument, the parameter i gets 1 and n gets the length of the sequence. 
Then the function returns t[1] followed by all results from unpack(t, 2, n), which in turn returns t[2] followed by all results from unpack(t, 3, n), and so on, stopping after n elements.
Proper Tail Calls
Another interesting feature of functions in Lua is that Lua does tail-call elimination.This means that Lua is properly tail recursive, although the concept does not involve recursion directly.
A tail call is a goto dressed as a call. A tail call happens when a function calls another as its last action, so it has nothing else to do. 
For instance, in the following code, the call to g is a tail call:
function f(x)
    x = x + 1;
    return g(x)
end
After f calls g, it has nothing else to do. In such situations, the program does not need to return to the calling function when the called function ends. 
Therefore, after the tail call, the program does not need to keep any information about the calling function on the stack. 
When g returns, control can return directly to the point that called f. Some language implementations, such as the Lua interpreter, take advantage of this fact and actually do not use any extra stack space when doing a tail call. 
We say that these implementations do tail-call elimination.

Because tail calls use no stack space, the number of nested tail calls that a program can make is unlimited. 
For instance, we can call the following function passing any number as argument:

function foo (n)
　if n > 0 then
        return foo(n - 1)
    end
end
It will never overflow the stack.

A subtle point about tail-call elimination is what is a tail call. Some apparently obvious candidates fail the criterion that the calling function has nothing else to do after the call. 
For instance, in the following code, the call to g is not a tail call:
function f(x)
    g(x)
end

The problem in this example is that, after calling g, f still has to discard any results from g before returning. Similarly, all the following calls fail the criterion:

return g(x) + 1	-- must do the addition
return x or g(x)	-- must adjust to 1 result
return (g(x))	-- must adjust to 1 result
In Lua, only a call with the form return func(args) is a tail call. However, both func and its arguments can be complex expressions, because Lua evaluates them before the call. 
For instance, the next call is a tail call:

return x[i].foo(x[j] + a*b, i + j)

Chapter 7. The External World

The Simple I/O Model
The I/O library offers two different models for file manipulation. The simple model assumes a current input stream and a current output stream, and its I/O operations operate on these streams. 
The library  initializes the current input stream to the process's standard input (stdin) and the current output stream to the process's standard output (stdout). 
Therefore, when we execute something like io.read(), we read a line from the standard input.

We can change these current streams with the functions io.input and io.output. A call like io.input(filename) opens a stream over the given file in read mode and sets it as the current input stream. 
From this point on, all input will come from this file, until another call to io.input. The function io.output does a similar job for output. 
In case of error, both functions raise the error. If you want to handle errors directly, you should use the complete I/O model.

As write is simpler than read, we will look at it first. The function io.write simply takes an arbitrary number of strings (or numbers) and writes them to the current output stream. 
Because we can call it with multiple arguments, we should avoid calls like io.write(a..b..c); the call io.write(a, b, c) accomplishes the same effect with fewer resources, as it avoids the concatenations.
As a rule, you should use print only for quick-and-dirty programs or debugging; always use io.write when you need full control over your output. 
Unlike print, write adds no extra characters to the output, such as tabs or newlines. Moreover, io.write allows you to redirect your output, whereas print always uses the standard output. 
Finally, print automatically applies tostring to its arguments; this is handy for debugging, but it also can hide subtle bugs.

The function io.write converts numbers to strings following the usual conversion rules; for full control over this conversion, we should use string.format:

> io.write("sin(3) = ", math.sin(3), "\n")
--> sin(3) = 0.14112000805987
> io.write(string.format("sin(3) = %.4f\n", math.sin(3)))
--> sin(3) = 0.1411

The function io.read reads strings from the current input stream. Its arguments control what to read:

"a"
reads the whole file
"l"
reads the next line (dropping the newline)
"L"
reads the next line (keeping the newline)
"n"
reads a number
num
reads num characters as a string

In Lua 5.2 and before, all string options should be preceded by an asterisk. Lua 5.3 still accepts the asterisk for compatibility.

The call io.read("a") reads the whole current input file, starting at its current position. If we are at the end of the file, or if the file is empty, the call returns an empty string.

Because Lua handles long strings efficiently, a simple technique for writing filters in Lua is to read the whole file into a string, process the string, and then write the string to the output:

t = io.read("a")	-- read the whole file
t = string.gsub(t, "bad", "good")	-- do the job
io.write(t)	-- write the file

As a more concrete example, the following chunk is a complete program to code a file's content using the MIME quoted-printable encoding. 
This encoding codes each non-ASCII byte as =xx, where xx is the value of the byte in hexadecimal. To keep the consistency of the encoding, it must encode the equals sign as well:

t = io.read("a")
t = string.gsub(t, "([\128-\255=])", function (c) return string.format("=%02X", string.byte(c)) end)
io.write(t)

The function string.gsub will match all non-ASCII bytes (codes from 128 to 255), plus the equals sign, and call the given function to provide a replacement. 
(We will discuss pattern matching in detail in Chapter 10, Pattern Matching.)

The call io.read("l") returns the next line from the current input stream, without the newline char- acter; 
the call io.read("L") is similar, but it keeps the newline (if present in the file). When we reach the end of file, the call returns nil, as there is no next line to return. 
Option "l" is the default for read. Usually, I use this option only when the algorithm naturally handles the data line by line; 
otherwise, I favor reading the whole file at once, with option "a", or in blocks, as we will see later.

As a simple example of the use of line-oriented input, the following program copies its current input to the current output, numbering each line:

for count = 1, math.huge do
    local line = io.read("L")
    if line == nil then
        break
    end
    io.write(string.format("%6d	", count), line)
end

However, to iterate on a whole file line by line, the io.lines iterator allows a simpler code:

local count = 0
for line in io.lines() do
    count = count + 1
　io.write(string.format("%6d	", count), line, "\n")
end

As another example of line-oriented input, Figure 7.1, “A program to sort a file” shows a complete program to sort the lines of a file.

Figure 7.1. A program to sort a file

local lines = {}

-- read the lines in table 'lines'
for line in io.lines() do
    lines[#lines + 1] = line
end

-- sort
table.sort(lines)

-- write all the lines
for _, l in ipairs(lines) do
    io.write(l, "\n")
end

The call io.read("n") reads a number from the current input stream. This is the only case where read returns a number (integer or float, following the same rules of the Lua scanner) instead of a string. 
If, after skipping spaces, io.read cannot find a numeral at the current file position (because of bad format or end of file), it returns nil.

Besides the basic read patterns, we can call read with a number n as an argument: in this case, it tries to read n characters from the input stream. 
If it cannot read any character (end of file), the call returns nil; otherwise, it returns a string with at most n characters from the stream. 
As an example of this read pattern, the following program is an efficient way to copy a file from stdin to stdout:

while true do
    local block = io.read(2^13)	-- block size is 8K
    if not block then
        break
    end
　io.write(block)
end

As a special case, io.read(0) works as a test for end of file: it returns an empty string if there is more to be read or nil otherwise.

We can call read with multiple options; for each argument, the function will return the respective result. Suppose we have a file with three numbers per line:

6.0 -3.23 15e12
4.3 234 1000001
...

Now we want to print the maximum value of each line. We can read all three numbers of each line with a single call to read:

while true do
    local n1, n2, n3 = io.read("n", "n", "n")
    if not n1 then
        break
    end
    print(math.max(n1, n2, n3))
end

The Complete I/O Model
The simple I/O model is convenient for simple things, but it is not enough for more advanced file manipulation, such as reading from or writing to several files simultaneously. 
For these manipulations, we need the complete model.

To open a file, we use the function io.open, which mimics the C function fopen. It takes as arguments the name of the file to open plus a mode string. 
This mode string can contain an r for reading, a w for writing (which also erases any previous content of the file), or an a for appending, plus an optional b to open binary files. 
The function open returns a new stream over the file. In case of error, open returns nil, plus an error message and a system-dependent error number:

print(io.open("non-existent-file", "r"))
--> nil	non-existent-file: No such file or directory	2
print(io.open("/etc/passwd", "w"))
--> nil	/etc/passwd: Permission denied	13

A typical idiom to check for errors is to use the function assert: 
local f = assert(io.open(filename, mode))
If the open fails, the error message goes as the second argument to assert, which then shows the message.

After we open a file, we can read from or write to the resulting stream with the methods read and write. 
They are similar to the functions read and write, but we call them as methods on the stream object, using the colon operator. 
For instance, to open a file and read it all, we can use a fragment like this:

local f = assert(io.open(filename, "r"))
local t = f:read("a")
f:close()

(We will discuss the colon operator in detail in Chapter 21, Object-Oriented Programming.)

The I/O library offers handles for the three predefined C streams, called io.stdin, io.stdout, and io.stderr. 
For instance, we can send a message directly to the error stream with a code like this:

io.stderr:write(message)

The functions io.input and io.output allow us to mix the complete model with the simple model. We get the current input stream by calling io.input(), without arguments. 
We set this stream with the call io.input(handle). (Similar calls are also valid for io.output.) For instance, if we want to change the current input stream temporarily, 
we can write something like this:

local temp = io.input()	-- save current stream
io.input("newinput")	-- open a new current stream do something with new input
io.input():close()	-- close current stream
io.input(temp)	-- restore previous current stream

Note that io.read(args) is actually a shorthand for io.input():read(args), that is, the read method applied over the current input stream. 
Similarly, io.write(args) is a shorthand for io.output():write(args).

Instead of io.read, we can also use io.lines to read from a stream. As we saw in previous examples, io.lines gives an iterator that repeatedly reads from a stream. 
Given a file name, io.lines will open a stream over the file in read mode and will close it after reaching end of file. 
When called with   no arguments, io.lines will read from the current input stream. We can also use lines as a method over handles. 
Moreover, since Lua 5.2 io.lines accepts the same options that io.read accepts. As an example, the next fragment copies the current input to the current output, 
iterating over blocks of 8 KB:

for block in io.input():lines(2^13) do
    io.write(block)
end
Other Operations on Files
The function io.tmpfile returns a stream over a temporary file, open in read/write mode. This file is automatically removed (deleted) when the program ends.

The function flush executes all pending writes to a file. Like the function write, we can call it as a function —io.flush()— to flush the current output stream, or as a method —f:flush()— to flush the stream f.
The setvbuf method sets the buffering mode of a stream. Its first argument is a string: "no" means no buffering; "full" means that the stream data is only written out when the buffer is full or when we explicitly flush the file; 
and "line" means that the output is buffered until a newline is output or there is any input from some special files (such as a terminal device). 
For the last two options, setvbuf accepts an optional second argument with the buffer size.

In most systems, the standard error stream (io.stderr) is not buffered, while the standard output stream (io.stdout) is buffered in line mode. 
So, if we write incomplete lines to the standard output (e.g., a progress indicator), we may need to flush the stream to see that output.

The seek method can both get and set the current position of a stream in a file. Its general form is f:seek(whence, offset), where the whence parameter is a string that specifies how to interpret the offset. Its valid values are "set", for offsets relative to the beginning of the file; "cur", for offsets relative to the current position in the file; and "end", for offsets relative to the end of the file. Indepen- dently of the value of whence, the call returns the new current position of the stream, measured in bytes from the beginning of the file.

The default value for whence is "cur" and for offset is zero. Therefore, the call file:seek() returns the current stream position, without changing it; 
the call file:seek("set") resets the position to the beginning of the file (and returns zero); and the call file:seek("end") sets the position to the end of the file and returns its size. 
The following function gets the file size without changing its current position:

function fsize (file)
    local current = file:seek()	-- save current position
    local size = file:seek("end")	-- get file size
    file:seek("set", current)	-- restore position
    return size
end
To complete the set, os.rename changes the name of a file and os.remove removes (deletes) a file. 
Note that these functions come from the os library, not the io library, because they manipulate real files, not streams.

All these functions return nil plus an error message and an error code in case of errors.


Other System Calls
The function os.exit terminates the execution of a program. Its optional first argument is the return status of the program. 
It can be a number (zero means a successful execution) or a Boolean (true means a successful execution). 
An optional second argument, if true, closes the Lua state, calling all finalizers and releasing all memory used by that state. 
(Usually this finalization is not necessary, because most operating systems release all resources used by a process when it exits.)
The function os.getenv gets the value of an environment variable. It takes the name of the variable and returns a string with its value:

print(os.getenv("HOME"))	--> /home/lua
The call returns nil for undefined variables.

Running system commands
The function os.execute runs a system command; it is equivalent to the C function system. It takes a string with the command and returns information regarding how the command terminated. 
The first result is a Boolean: true means the program exited with no errors. The second result is a string: "exit" if the program terminated normally or "signal" if it was interrupted by a signal. 
A third result is the return status (if the program terminated normally) or the number of the signal that terminated the program. 
As an example, both in POSIX and Windows we can use the following function to create new directories:

function createDir (dirname)
    os.execute("mkdir " .. dirname)
end
Another quite useful function is io.popen. Like os.execute, it runs a system command, but it also connects the command output (or input) to a new local stream and returns that stream, 
so that our script can read data from (or write to) the command. For instance, the following script builds a table with the entries in the current directory:

-- for POSIX systems, use 'ls' instead of 'dir'
local f = io.popen("dir /B", "r")
local dir = {}
for entry in f:lines() do
    dir[#dir + 1] = entry
end
The second parameter ("r") to io.popen means that we intend to read from the command. The default is to read, so this parameter is optional in the example.

The next example sends an email message:

local subject = "some news"
local address = "someone@somewhere.org"

local cmd = string.format("mail -s '%s' '%s'", subject, address)
local f = io.popen(cmd, "w")
f:write([[
Nothing important to say.
-- me
]])
f:close()
(This script only works on POSIX systems, with the appropriate packages installed.) The second parameter to io.popen now is "w", meaning that we intend to write to the command.
As we can see from those two previous examples, both os.execute and io.popen are powerful functions, but they are also highly system dependent.

For extended OS access, your best option is to use an external Lua library, such as LuaFileSystem, for basic manipulation of directories and file attributes, or luaposix, which offers much of the functionality of the POSIX.1 standard.

Chapter 8. Filling some Gaps

Local Variables and Blocks
By default, variables in Lua are global. All local variables must be declared as such. Unlike global variables, a local variable has its scope limited to the block where it is declared. 
A block is the body of a control structure, the body of a function, or a chunk (the file or string where the variable is declared):

x = 10
local i = 1	-- local to the chunk

while i <= x do
    local x = i * 2	-- local to the while body
    print(x)	--> 2, 4, 6, 8, ...
　i = i + 1
end

if i > 10 then
    local x	-- local to the "then" body
    x = 20
　print(x + 2)	-- (would print 22 if test succeeded)
else
　print(x)	--> 10	(the global one)
end

print(x)	--> 10	(the global one)

Beware that this last example will not work as expected if you enter it in interactive mode. In interactive mode, each line is a chunk by itself (unless it is not a complete command). 
As soon as you enter the second line of the example (local i = 1), Lua runs it and starts a new chunk in the next line. By then, the local declaration is already out of scope. 
To solve this problem, we can delimit the whole block explicitly, bracketing it with the keywords do–end. Once you enter the do, the command completes only at the corresponding end, so Lua will not execute each line by itself.

These do blocks are useful also when we need finer control over the scope of some local variables:

local x1, x2
do
    local a2 = 2*a
    local d = (b^2 - 4*a*c)^(1/2)
    x1 = (-b + d)/a2
    x2 = (-b - d)/a2
end	-- scope of 'a2' and 'd' ends here
print(x1, x2)	-- 'x1' and 'x2' still in scope

It is good programming style to use local variables whenever possible. Local variables avoid cluttering the global environment with unnecessary names; 
they also avoid name clashes between different parts of a program. Moreover, the access to local variables is faster than to global ones. 
Finally, a local variable vanishes as soon as its scope ends, allowing the garbage collector to release its value.

Given that local variables are “better” than global ones, some people argue that Lua should use local    by default. 
However, local by default has its own set of problems (e.g., issues with accessing non-local variables). 
A better approach would be no default, that is, all variables should be declared before used. The Lua distribution comes with a module strict.lua for global-variable checks; 
it raises an error if we try to assign to a non-existent global inside a function or to use a non-existent global. It is a good habit to use it when developing Lua code.

Each local declaration can include an initial assignment, which works the same way as a conventional multiple assignment: 
extra values are thrown away, extra variables get nil. If a declaration has no initial assignment, it initializes all its variables with nil:

local a, b = 1, 10
if a < b then
    print(a)	--> 1
    local a	-- '= nil' is implicit
    print(a)	--> nil
end	-- ends the block started at 'then'
print(a, b)	--> 1	10
A common idiom in Lua is

local foo = foo

This code creates a local variable, foo, and initializes it with the value of the global variable foo. (The local foo becomes visible only after its declaration.) 
This idiom is useful to speed up the access to foo. It is also useful when the chunk needs to preserve the original value of foo even if later some other function changes the value of the global foo; 
in particular, it makes the code resistant to monkey patching. Any piece of code preceded by local print = print will use the original function print even if print is monkey patched to something else.
Some people think it is a bad practice to use declarations in the middle of a block. Quite the opposite:  by declaring a variable only when we need it, we seldom need to declare it without an initial value (and therefore we seldom forget to initialize it). 
Moreover, we shorten the scope of the variable, which increases readability.
Control Structures
Lua provides a small and conventional set of control structures, with if for conditional execution and while, repeat, and for for iteration. 
All control structures have a syntax with an explicit terminator: end terminates if, for and while structures; until terminates repeat structures.

The condition expression of a control structure can result in any value. Remember that Lua treats as true all values different from false and nil. 
(In particular, Lua treats both zero and the empty string as true.)

if then else
An if statement tests its condition and executes its then-part or its else-part accordingly. The else-part   is optional.

if a < 0 then
    a = 0
end

if a < b then
    return a
else
    return b
end

if line > MAXLINES then
    showpage()
    line = 0
end

To write nested ifs we can use elseif. It is similar to an else followed by an if, but it avoids the need for multiple ends:

if op == "+" then
    r = a + b
elseif op == "-" then
    r = a - b
elseif op == "*" then
    r = a*b
elseif op == "/" then
    r = a/b
else
　error("invalid operation")
end
Because Lua has no switch statement, such chains are somewhat common.

while

As the name implies, a while loop repeats its body while a condition is true. As usual, Lua first tests the while condition; 
if the condition is false, then the loop ends; otherwise, Lua executes the body of the loop and repeats the process.

local i = 1
while a[i] do
    print(a[i])
    i = i + 1
end

repeat

As the name implies, a repeat–until statement repeats its body until its condition is true. This statement does the test after the body, 
so that it always executes the body at least once.

-- print the first non-empty input line
local line
repeat
    line = io.read()
until line ~= ""
print(line)
Differently from most other languages, in Lua the scope of a local variable declared inside the loop includes the condition:

-- computes the square root of 'x' using Newton-Raphson method
local sqr = x / 2
repeat
    sqr = (sqr + x/sqr) / 2
    local error = math.abs(sqr^2 - x)
until error < x/10000	-- local 'error' still visible here

Numerical for
The for statement has two variants: the numerical for and the generic for. A numerical for has the following syntax:
for var = exp1, exp2, exp3 do
    something
end

This loop will execute something for each value of var from exp1 to exp2, using exp3 as the step to increment var. 
This third expression is optional; when absent, Lua assumes one as the step value. If we want a loop without an upper limit, we can use the constant math.huge:

for i = 1, math.huge do
    if (0.3*i^3 - 20*i^2 - 500 >= 0) then
        print(i)
　    break
    end
end

The for loop has some subtleties that you should learn in order to make good use of it. First, all three expressions are evaluated once, before the loop starts. 
Second, the control variable is a local variable automatically declared by the for statement, and it is visible only inside the loop. 
A typical mistake is to assume that the variable still exists after the loop ends:

for i = 1, 10 do
    print(i)
end
max = i	-- probably wrong!
If you need the value of the control variable after the loop (usually when you break the loop), you must save its value into another variable:

-- find a value in a list
local found = nil
for i = 1, #a do
    if a[i] < 0 then
        found = i	-- save value of 'i'
        break
　end
end
print(found)

Third, you should not change the value of the control variable: the effect of such changes is unpredictable. 
If you want to end a for loop before its normal termination, use break (as we did in the previous example).

Generic for
The generic for loop traverses all values returned by an iterator function. We saw some examples already, with pairs, ipairs, io.lines, etc. 
Despite its apparent simplicity, the generic for is powerful. With proper iterators, we can traverse almost anything in a readable fashion.

Of course, we can write our own iterators. Although the use of the generic for is easy, the task of writing iterator functions has its subtleties; 
hence, we will cover this topic later, in Chapter 18, Iterators and the Generic for.

Unlike the numerical for, the generic for can have multiple variables, which are all updated at each iteration. 
The loop stops when the first variable gets nil. As in the numerical loop, the loop variables are local to the loop body and you should not change their values inside each iteration.

break, return, and goto
The break and return statements allow us to jump out of a block. The goto statement allows us to jump to almost any point in a function.

We use the break statement to finish a loop. This statement breaks the inner loop (for, repeat, or while) that contains it; it cannot be used outside a loop. 
After the break, the program continues running from the point immediately after the broken loop.

A return statement returns the results from a function or simply finishes the function. There is an implicit return at the end of any function, 
so we do not need to write one for functions that end naturally, without returning any value.

For syntactic reasons, a return can appear only as the last statement of a block: in other words, as the last statement in our chunk or just before an end, an else, or an until. 
For instance, in the next example, return is the last statement of the then block:

local i = 1
while a[i] do
    if a[i] == v then
        return i
    end
    i = i + 1
end

Usually, these are the places where we use a return, because any statement following it would be unreachable. 
Sometimes, however, it may be useful to write a return in the middle of a block; for instance, we may be debugging a function and want to avoid its execution. 
In such cases, we can use an explicit do block around the statement:

function foo ()
    return	--<< SYNTAX ERROR
    -- 'return' is the last statement in the next block
    do return end	-- OK
    other statements
end

A goto statement jumps the execution of a program to a corresponding label. There has been a long going debate about goto, 
with some people arguing even today that they are harmful to programming and should be banned from programming languages. 
Nonetheless, several current languages offer goto, with good reason. They are a powerful mechanism and, when used with care, can only improve the quality of our code.

In Lua, the syntax for a goto statement is quite conventional: it is the reserved word goto followed by the label name, which can be any valid identifier. 
The syntax for a label is a little more convoluted: it has two colons followed by the label name followed by more two colons, like in ::name::. 
This convolution is intentional, to highlight labels in a program.

Lua poses some restrictions to where we can jump with a goto. First, labels follow the usual visibility rules, so we cannot jump into a block (because a label inside a block is not visible outside it). 
Second, we cannot jump out of a function. (Note that the first rule already excludes the possibility of jumping into a function.) 
Third, we cannot jump into the scope of a local variable.

A typical and well-behaved use of a goto is to simulate some construction that you learned from another language but that is absent from Lua, 
such as continue, multi-level break, multi-level continue, redo, local error handling, etc. A continue statement is simply a goto to a label at the end of a loop block; 
a redo statement jumps to the beginning of the block:

while some_condition do
::redo::
    if some_other_condition then goto continue
    elseif yet_another_condition then goto redo
    end
    some code
　::continue::
end
A useful detail in the specification of Lua is that the scope of a local variable ends on the last non-void statement of the block where the variable is defined; 
labels are considered void statements. To see the usefulness of this detail, consider the next fragment:

while some_condition do
    if some_other_condition then
        goto continue
    end
    local var = something
    some code
　::continue::
end
You may think that this goto jumps into the scope of the variable var. However, the continue label appears after the last non-void statement of the block, 
and therefore it is not inside the scope of var.
The goto is also useful for writing state machines. As an example, Figure 8.1, “An example of a state  machine with goto” shows a program that checks whether its input has an even number of zeros.

Figure 8.1. An example of a state machine with goto
::s1:: do
    local c = io.read(1)
    if c == '0' then goto s2
    elseif c == nil then print'ok'; return
    else goto s1
　end
end

::s2:: do
    local c = io.read(1)
    if c == '0' then goto s1
    elseif c == nil then print'not ok'; return
    else goto s2
　end
end

goto s1
There are better ways to write this specific program, but this technique is useful if we want to translate a finite automaton into Lua code automatically (think about dynamic code generation).
As another example, let us consider a simple maze game. The maze has several rooms, each with up to four doors: north, south, east, and west. At each step, the user enters a movement direction. 
If there is a door in this direction, the user goes to the corresponding room; otherwise, the program prints a warning. The goal is to go from an initial room to a final room.

This game is a typical state machine, where the current room is the state. We can implement this maze with one block for each room, using a goto to move from one room to another. 
Figure 8.2, “A maze game” shows how we could write a small maze with four rooms.

Figure 8.2. A maze game

goto room1	-- initial room

::room1:: do
    local move = io.read()
    if move == "south" then goto room3
    elseif move == "east" then goto room2
    else
        print("invalid move")
　    goto room1	-- stay in the same room
    end
end

::room2:: do
    local move = io.read()
    if move == "south" then goto room4
    elseif move == "west" then goto room1
    else
        print("invalid move")
        goto room2
　end
end

::room3:: do
    local move = io.read()
    if move == "north" then goto room1
    elseif move == "east" then goto room4
    else
        print("invalid move")
        goto room3
　end
end

::room4:: do
　print("Congratulations, you won!")
end

For this simple game, you may find that a data-driven program, where you describe the rooms and movements with tables, is a better design. 
However, if the game has several special situations in each room, then this state-machine design is quite appropriate.

Chapter 9. Closures
Functions in Lua are first-class values with proper lexical scoping.

What does it mean for functions to be “first-class values”? It means that, in Lua, a function is a value with the same rights as more conventional values like numbers and strings. 
A program can store functions in variables (both global and local) and in tables, pass functions as arguments to other functions, and return functions as results.

What does it mean for functions to have “lexical scoping”? It means that functions can access variables of their enclosing functions. 
(It also means that Lua properly contains the lambda calculus.)

Together, these two features give great flexibility to the language; for instance, a program can redefine a function to add new functionality or erase a function to create a secure environment 
when running a piece of untrusted code (such as code received through a network). More importantly, these features allow us to apply in Lua many powerful programming techniques from the functional-language world. 
Even if you have no interest at all in functional programming, it is worth learning a little about how to explore these techniques, because they can make your programs smaller and simpler.

Functions as First-Class Values
As we just saw, functions in Lua are first-class values. The following example illustrates what that means:

a = {p = print}	-- 'a.p' refers to the 'print' function
a.p("Hello World")	--> Hello World
print = math.sin	-- 'print' now refers to the sine function
a.p(print(1))	--> 0.8414709848079
math.sin = a.p	-- 'sin' now refers to the print function
math.sin(10, 20)	--> 10	20

If functions are values, are there expressions that create functions? Sure. In fact, the usual way to write  a function in Lua, such as

function foo(x)
    return 2*x
end

is an instance of what we call syntactic sugar; it is simply a pretty way to write the following code:

foo = function (x)
    return 2*x
end

The expression in the right-hand side of the assignment (function (x) body end) is a function constructor, in the same way that {} is a table constructor. 
Therefore, a function definition is in fact a statement that creates a value of type "function" and assigns it to a variable.

Note that, in Lua, all functions are anonymous. Like any other value, they do not have names. 
When   we talk about a function name, such as print, we are actually talking about a variable that holds that function. 
Although we often assign functions to global variables, giving them something like a name, there are several occasions when functions remain anonymous. 
Let us see some examples.

The table library provides the function table.sort, which receives a table and sorts its elements. Such a function must allow unlimited variations in the sort order: 
ascending or descending, numeric or alphabetical, tables sorted by a key, and so on. Instead of trying to provide all kinds of options, sort provides a single optional parameter, 
which is the order function: a function that takes two elements and returns whether the first must come before the second in the sorted list. 
For instance, suppose we have a table   of records like this:

network = {
{name = "grauna", IP = "210.26.30.34"},
{name = "arraial", IP = "210.26.30.23"},
{name = "lua", IP = "210.26.23.12"},
{name = "derain", IP = "210.26.23.20"},
}

If we want to sort the table by the field name, in reverse alphabetical order, we just write this:

table.sort(network, function (a,b) return (a.name > b.name) end)

See how handy the anonymous function is in this statement.

A function that takes another function as an argument, such as sort, is what we call a higher-order function. 
Higher-order functions are a powerful programming mechanism, and the use of anonymous functions to create their function arguments is a great source of flexibility. 
Nevertheless, remember that higher-order functions have no special rights; they are a direct consequence of the fact that Lua handles functions as first-class values.

To further illustrate the use of higher-order functions, we will write a naive implementation of a common higher-order function, the derivative. 
In an informal definition, the derivative of a function f is the function f'(x) = (f(x + d) - f(x)) / d when d becomes infinitesimally small. 
According to this definition, we can compute an approximation of the derivative as follows:

function derivative(f, delta)
    delta = delta or 1e-4
    return function (x)
　    return (f(x + delta) - f(x))/delta
    end
end

Given a function f, the call derivative(f) returns (an approximation of) its derivative, which is another function:

c = derivative(math.sin)
> print(math.cos(5.2), c(5.2))
-->	0.46851667130038	0.46856084325086
print(math.cos(10), c(10))
-->	-0.83907152907645	-0.83904432662041

Non-Global Functions
An obvious consequence of first-class functions is that we can store functions not only in global variables, but also in table fields and in local variables.

We have already seen several examples of functions in table fields: most Lua libraries use this mechanism (e.g., io.read, math.sin). 
To create such functions in Lua, we only have to put together what we have learned so far:

Lib = {}

Lib.foo = function (x,y) return x + y end
Lib.goo = function (x,y) return x - y end

print(Lib.foo(2, 3), Lib.goo(2, 3))	--> 5	-1

Of course, we can also use constructors:

Lib = {
foo = function (x,y) return x + y end, goo = function (x,y) return x - y end
}

Moreover, Lua offers a specific syntax to define such functions:

Lib = {}
function Lib.foo (x,y) return x + y end
function Lib.goo (x,y) return x - y end

As we will see in Chapter 21, Object-Oriented Programming, the use of functions in table fields is a key ingredient for object-oriented programming in Lua.

When we store a function into a local variable, we get a local function, that is, a function that is restricted to a given scope. 
Such definitions are particularly useful for packages: because Lua handles each chunk as a function, a chunk can declare local functions, which are visible only inside the chunk. 
Lexical scoping ensures that other functions in the chunk can use these local functions.

Lua supports such uses of local functions with a syntactic sugar for them:

local function f (params)
body
end

A subtle point arises in the definition of recursive local functions, because the naive approach does not work here. Consider the next definition:

local fact = function (n) 
    if n == 0 then return 1
    else return n*fact(n-1)	-- buggy 
    end
end

When Lua compiles the call fact(n - 1) in the function body, the local fact is not yet defined. Therefore, this expression will try to call a global fact, not the local one. 
We can solve this problem by first defining the local variable and then the function:

local fact
fact = function (n)
    if n == 0 then return 1
    else return n*fact(n-1)
    end
end

Now the fact inside the function refers to the local variable. Its value when the function is defined does not matter; by the time the function executes, fact already has the right value.

When Lua expands its syntactic sugar for local functions, it does not use the naive definition. Instead, a definition like

local function foo (params)	body	end

expands to

local foo; foo = function (params)	body	end

Therefore, we can use this syntax for recursive functions without worrying.

Of course, this trick does not work if we have indirect recursive functions. In such cases, we must use the equivalent of an explicit forward declaration:
local f	-- "forward" declaration 
local function g ()
    some code
    f()
    some code
end

function f ()
    some code
    g()
    some code
end

Beware not to write local in the last definition. Otherwise, Lua would create a fresh local variable f, leaving the original f (the one that g is bound to) undefined.
Lexical Scoping
When we write a function enclosed in another function, it has full access to local variables from the enclosing function; we call this feature lexical scoping. 
Although this visibility rule may sound obvious, it is not. Lexical scoping plus nested first-class functions give great power to a programming language, 
but many do not support the combination.

Let us start with a simple example. Suppose we have a list of student names and a table that maps names to grades; 
we want to sort the list of names according to their grades, with higher grades first. We can  do this task as follows:

names = {"Peter", "Paul", "Mary"}
grades = {Mary = 10, Paul = 7, Peter = 8}
table.sort(names, function (n1, n2)
　return grades[n1] > grades[n2]	-- compare the grades
end)

Now, suppose we want to create a function to do this task:

function sortbygrade (names, grades)
    table.sort(names, function (n1, n2)
　    return grades[n1] > grades[n2]	-- compare the grades
    end)
end

The interesting point in this last example is that the anonymous function given to sort accesses grades, which is a parameter to the enclosing function sortbygrade. 
Inside this anonymous function, grades is neither a global variable nor a local variable, but what we call a non-local variable. 
(For historical reasons, non-local variables are also called upvalues in Lua.)

Why is this point so interesting? Because functions, being first-class values, can escape the original scope of their variables. Consider the following code:

function newCounter ()
    local count = 0
    return function ()	-- anonymous function
        count = count + 1
　    return count
    end
end

c1 = newCounter()
print(c1())	--> 1
print(c1())	--> 2

In this code, the anonymous function refers to a non-local variable (count) to keep its counter. However, by the time we call the anonymous function, 
the variable count seems to be out of scope, because the function that created this variable (newCounter) has already returned. 
Nevertheless, Lua handles this situation correctly, using the concept of closure. Simply put, a closure is a function plus all it needs to access non-local variables correctly. 
If we call newCounter again, it will create a new local variable count and a new closure, acting over this new variable:

c2 = newCounter()
print(c2())	--> 1
print(c1())	--> 3
print(c2())	--> 2

So, c1 and c2 are different closures. Both are built over the same function, but each acts upon an independent instantiation of the local variable count.

Technically speaking, what is a value in Lua is the closure, not the function. The function itself is a kind of a prototype for closures. 
Nevertheless, we will continue to use the term “function” to refer to a closure whenever there is no possibility for confusion.

Closures provide a valuable tool in many contexts. As we have seen, they are useful as arguments to higher-order functions such as sort. 
Closures are valuable for functions that build other functions too, like our newCounter example or the derivative example; 
this mechanism allows Lua programs to incorporate sophisticated programming techniques from the functional world. 
Closures are useful for callback functions, too. A typical example here occurs when we create buttons in a conventional GUI toolkit. 
Each button has a callback function to be called when the user presses the button; we want different buttons to do slightly different things when pressed.

For instance, a digital calculator needs ten similar buttons, one for each digit. We can create each of them with a function like this:

function digitButton (digit)
    return Button{ label = tostring(digit),
    action = function ()
　    add_to_display(digit) 
    end
    }
end
In this example, we pretend that Button is a toolkit function that creates new buttons; label is the button label; and action is the callback function to be called when the button is pressed. 
The callback can be called a long time after digitButton did its task, but it can still access the digit variable.
Closures are valuable also in a quite different context. Because functions are stored in regular variables, we can easily redefine functions in Lua, even predefined functions. 
This facility is one of the reasons why Lua is so flexible. Frequently, when we redefine a function, we need the original function in the new implementation. 
As an example, suppose we want to redefine the function sin to operate in degrees instead of radians. This new function converts its argument and then calls the original function sin to do the real work. 
Our code could look like this:

local oldSin = math.sin
math.sin = function (x)
　return oldSin(x * (math.pi / 180))
end
A slightly cleaner way to do this redefinition is as follows:

do
    local oldSin = math.sin
    local k = math.pi / 180
    math.sin = function (x)
　    return oldSin(x * k)
    end
end
This code uses a do block to limit the scope of the local variable oldSin; following conventional visibility rules, the variable is only visible inside the block. 
So, the only way to access it is through the new function.

We can use this same technique to create secure environments, also called sandboxes. Secure environments are essential when running untrusted code, 
such as code received through the Internet by a server. For instance, to restrict the files that a program can access, we can redefine io.open using closures:
do
    local oldOpen = io.open
    local access_OK = function (filename, mode)
        check access
    end
    io.open = function (filename, mode)
        if access_OK(filename, mode) then
　        return oldOpen(filename, mode)
        else
　        return nil, "access denied"
        end
　end
end
What makes this example nice is that, after this redefinition, there is no way for the program to call the unrestricted version of function io.open except through the new, restricted version. 
It keeps the insecure version as a private variable in a closure, inaccessible from the outside. With this technique, we can build Lua sandboxes in Lua itself, with the usual benefits: simplicity and flexibility. 
Instead of a one-size-fits-all solution, Lua offers us a meta-mechanism, so that we can tailor our environment for our specific security needs. (Real sandboxes do more than protecting external files. We will return to this subject in the section called “Sandboxing”.)


A Taste of Functional Programming
To give a more concrete example of functional programming, in this section we will develop a simple system for geometric regions. 
The goal is to develop a system to represent geometric regions, where a region is a set of points. 
We want to be able to represent all kinds of shapes and to combine and modify shapes in several ways (rotation, translation, union, etc.).

To implement this system, we could start looking for good data structures to represent shapes; we could try an object-oriented approach and develop some hierarchy of shapes. 
Or we can work on a higher level of abstraction and represent our sets directly by their characteristic (or indicator) function. 
(The characteristic function of a set A is a function fA such that fA(x) is true if and only if x belongs to A.) 
Given that a geometric region is a set of points, we can represent a region by its characteristic function; that is, we represent a region by a function that, given a point, returns true if and only if the point belongs to the region.

As an example, the next function represents a disk (a circular region) with center (1.0, 3.0) and radius 4.5:

function disk1 (x, y)
    return (x - 1.0)^2 + (y - 3.0)^2 <= 4.5^2
end

With higher-order functions and lexical scoping, it is easy to define a disk factory, which creates disks with given centers and radius:

function disk (cx, cy, r)
    return function (x, y)
　    return (x - cx)^2 + (y - cy)^2 <= r^2
    end
end

A call like disk(1.0, 3.0, 4.5) will create a disk equal to disk1. The next function creates axis-aligned rectangles, given the bounds:
function rect (left, right, bottom, up)
    return function (x, y)
        return left <= x and x <= right and bottom <= x and x <= up
    end
end

In a similar fashion, we can define functions to create other basic shapes, such as triangles and non–axis-aligned rectangles. 
Each shape has a completely independent implementation, needing only a correct characteristic function.

Now let us see how to modify and combine regions. To create the complement of any region is trivial:

function complement (r)
    return function (x, y)
　    return not r(x, y)
    end
end

Union, intersection, and difference are equally simple, as we show in Figure 9.1, “Union, intersection, and difference of regions”.

Figure 9.1. Union, intersection, and difference of regions
function union (r1, r2)
    return function (x, y)
　    return r1(x, y) or r2(x, y)
    end
end

function intersection (r1, r2)
    return function (x, y)
　    return r1(x, y) and r2(x, y)
    end
end

function difference (r1, r2)
    return function (x, y)
　    return r1(x, y) and not r2(x, y)
    end
end
The following function translates a region by a given delta:

function translate (r, dx, dy)
    return function (x, y)
　    return r(x - dx, y - dy)
    end
end
To visualize a region, we can traverse the viewport testing each pixel; pixels in the region are painted  black, pixels outside it are painted white. 
To illustrate this process in a simple way, we will write a function to generate a PBM (portable bitmap) file with the drawing of a given region.
PBM files have a quite simple structure. (This structure is also highly inefficient, but our emphasis here is simplicity.) 
In its text-mode variant, it starts with a one-line header with the string "P1"; then there is one line with the width and height of the drawing, in pixels. 
Finally, there is a sequence of digits, one for each image pixel (1 for black, 0 for white), separated by optional spaces and end of lines. 
The function plot in Figure 9.2, “Drawing a region in a PBM file” creates a PBM file for a given region, mapping a virtual drawing area (-1,1], [-1,1) to the viewport area [1,M], [1,N].

Figure 9.2. Drawing a region in a PBM file
function plot (r, M, N)
    io.write("P1\n", M, " ", N, "\n")	-- header
    for i = 1, N do	-- for each line
        local y = (N - i*2)/N
        for j = 1, M do	-- for each column
            local x = (j*2 - M)/M
　        io.write(r(x, y) and "1" or "0")
        end
        io.write("\n")
    end
end


To complete our example, the following command draws a waxing crescent moon (as seen from the Southern Hemisphere):

c1 = disk(0, 0, 1)
plot(difference(c1, translate(c1, 0.3, 0)), 500, 500)

Chapter 10. Pattern Matching
Unlike several other scripting languages, Lua uses neither POSIX regex nor Perl regular expressions for pattern matching. 
The main reason for this decision is size: a typical implementation of POSIX regular expressions takes more than 4000 lines of code, 
which is more than half the size of all Lua standard libraries together. In comparison, the implementation of pattern matching in Lua has less than 600 lines. 
Of course, pattern matching in Lua cannot do all that a full POSIX implementation does. Nevertheless, pattern matching in Lua is a powerful tool, 
and includes some features that are difficult to match with standard POSIX implementations.
The Pattern-Matching Functions
The string library offers four functions based on patterns. We have already had a glimpse at find and gsub; the other two are match and gmatch (Global Match). 
Now we will see all of them in detail.
The function string.find
The function string.find searches for a pattern inside a given subject string. The simplest form of a pattern is a word, which matches only a copy of itself. 
For instance, the pattern 'hello' will search  for the substring "hello" inside the subject string. When string.find finds its pattern, it returns two values: 
the index where the match begins and the index where the match ends. If it does not find a match, it returns nil:

s = "hello world"
i, j = string.find(s, "hello")
print(i, j) --> 1 5
print(string.sub(s, i, j)) --> hello
print(string.find(s, "world")) --> 7 11
i, j = string.find(s, "l")
print(i, j) --> 3 3
print(string.find(s, "lll")) --> nil

When a match succeeds, we can call string.sub with the values returned by find to get the part of the subject string that matched the pattern. 
For simple patterns, this is necessarily the pattern itself.

The function string.find has two optional parameters. The third parameter is an index that tells where in the subject string to start the search. 
The fourth parameter, a Boolean, indicates a plain search. A plain search, as the name implies, does a plain “find substring” search in the subject, ignoring patterns:

> string.find("a [word]", "[")
stdin:1: malformed pattern (missing ']')
> string.find("a [word]", "[", 1, true)	--> 3	3
In the first call, the function complains because '[' has a special meaning in patterns. In the second call, the function treats '[' as a simple string. 
Note that we cannot pass the fourth optional parameter without the third one.

The function string.match
The function string.match is similar to find, in the sense that it also searches for a pattern in a string. However, instead of returning the positions where it found the pattern, 
it returns the part of the subject string that matched the pattern:


print(string.match("hello world", "hello"))	--> hello
For fixed patterns such as 'hello', this function is pointless. It shows its power when used with variable patterns, as in the next example:

date = "Today is 17/7/1990"
d = string.match(date, "%d+/%d+/%d+")
print(d)	--> 17/7/1990
Shortly we will discuss the meaning of the pattern '%d+/%d+/%d+' and more advanced uses for string.match.
The function string.gsub
The function string.gsub has three mandatory parameters: a subject string, a pattern, and a replacement string. 
Its basic use is to substitute the replacement string for all occurrences of the pattern inside the subject string:

s = string.gsub("Lua is cute", "cute", "great")
print(s)	--> Lua is great
s = string.gsub("all lii", "l", "x")
print(s)	--> axx xii
s = string.gsub("Lua is great", "Sol", "Sun")
print(s)	--> Lua is great
An optional fourth parameter limits the number of substitutions to be made:

s = string.gsub("all lii", "l", "x", 1)
print(s)	--> axl lii
s = string.gsub("all lii", "l", "x", 2)
print(s)	--> axx lii
Instead of a replacement string, the third argument to string.gsub can be also a function or a table, which is called (or indexed) to produce the replacement string; 
we will cover this feature in the section called “Replacements”.
The function string.gsub also returns as a second result the number of times it made the substitution.
The function string.gmatch
The function string.gmatch returns a function that iterates over all occurrences of a pattern in a string. For instance, the following example collects all words of a given string s:
s = "some string"
words = {}
for w in string.gmatch(s, "%a+") do
    words[#words + 1] = w
end
As we will discuss shortly, the pattern '%a+' matches sequences of one or more alphabetic characters (that is, words). 
So, the for loop will iterate over all words of the subject string, storing them in the list words.
Patterns
Most pattern-matching libraries use the backslash as an escape. However, this choice has some annoying consequences. 
For the Lua parser, patterns are regular strings. They have no special treatment and follow the same rules as other strings. 
Only the pattern-matching functions interpret them as patterns. Because the backslash is the escape character in Lua, we have to escape it to pass it to any function. 
Patterns are naturally hard to read, and writing "\\" instead of "\" everywhere does not help.
We could ameliorate this problem with long strings, enclosing patterns between double brackets. (Some languages recommend this practice.) 
However, the long-string notation seems cumbersome for patterns, which are usually short. Moreover, we would lose the ability to use escapes inside patterns. 
(Some pattern-matching tools work around this limitation by reimplementing the usual string escapes.)
Lua's solution is simpler: patterns in Lua use the percent sign as an escape. (Several functions in C, such as printf and strftime, adopt the same solution.) 
In general, any escaped alphanumeric character has some special meaning (e.g., '%a' matches any letter), 
while any escaped non-alphanumeric character represents itself (e.g., '%.' matches a dot).
We will start our discussion about patterns with character classes. A character class is an item in a pattern that can match any character in a specific set. 
For instance, the class %d matches any digit. Therefore, we can search for a date in the format dd/mm/yyyy with the pattern '%d%d/%d%d/%d%d%d%d':
s = "Deadline is 30/05/1999, firm"
date = "%d%d/%d%d/%d%d%d%d"
print(string.match(s, date))	--> 30/05/1999
The following table lists the predefined character classes with their meanings:

. all characters
%a letters
%c control characters
%d digits
%g printable characters except spaces
%l lower-case letters
%p punctuation characters
%s space characters
%u upper-case letters
%w alphanumeric characters
%x hexadecimal digits
An upper-case version of any of these classes represents the complement of the class. For instance, '%A' represents all non-letter characters:

print((string.gsub("hello, up-down!", "%A", "."))) --> hello..up.down.
(When printing the results of gsub, I am using extra parentheses to discard its second result, which is the number of substitutions.)
Some characters, called magic characters, have special meanings when used in a pattern. Patterns in Lua use the following magic characters:

( ) . % + - * ? [ ] ^ $
As we have seen, the percent sign works as an escape for these magic characters. So, '%?' matches a question mark and '%%' matches a percent sign itself. 
We can escape not only the magic characters, but also any non-alphanumeric character. When in doubt, play safe and use an escape.


A char-set allows us to create our own character classes, grouping single characters and classes inside square brackets. 
For instance, the char-set '[%w_]' matches both alphanumeric characters and underscores, '[01]' matches binary digits, and '[%[%]]' matches square brackets. 
To count the number of vowels in a text, we can write this code:

_, nvow = string.gsub(text, "[AEIOUaeiou]", "")
We can also include character ranges in a char-set, by writing the first and the last characters of the range separated by a hyphen. 
I seldom use this feature, because most useful ranges are predefined; for instance, '%d' substitutes '[0-9]', and '%x' substitutes '[0-9a-fA-F]'. 
However, if you need to find an octal digit, you may prefer '[0-7]' instead of an explicit enumeration like '[01234567]'.
We can get the complement of any char-set by starting it with a caret: the pattern '[^0-7]' finds any character that is not an octal digit 
and '[^\n]' matches any character different from newline. Nevertheless, remember that you can negate simple classes with its upper-case version: '%S' is simpler than '[^%s]'.
We can make patterns still more useful with modifiers for repetitions and optional parts. Patterns in Lua offer four modifiers:

+ 1 or more repetitions
* 0 or more repetitions
- 0 or more lazy repetitions
? optional (0 or 1 occurrence)
The plus modifier matches one or more characters of the original class. It will always get the longest sequence that matches the pattern. 
For instance, the pattern '%a+' means one or more letters (a word):
print((string.gsub("one, and two; and three", "%a+", "word")))
--> word, word word; word word
The pattern '%d+' matches one or more digits (an integer numeral):
       print(string.match("the number 1298 is even", "%d+"))	--> 1298
The asterisk modifier is similar to plus, but it also accepts zero occurrences of characters of the class.    A typical use is to match optional spaces between parts of a pattern. 
For instance, to match an empty parenthesis pair, such as () or ( ), we can use the pattern '%(%s*%)', where the pattern '%s*' matches zero or more spaces. 
(Parentheses have a special meaning in a pattern, so we must escape them.) As another example, the pattern '[_%a][_%w]*' matches identifiers in a Lua program: 
a sequence starting with a letter or an underscore, followed by zero or more underscores or alphanumeric characters.
Like an asterisk, the minus modifier also matches zero or more occurrences of characters of the original class. However, instead of matching the longest sequence, 
it matches the shortest one. Sometimes there is no difference between asterisk and minus, but usually they give rather different results. 
For instance, if we try to find an identifier with the pattern '[_%a][_%w]-', we will find only the first letter, because the '[_%w]-' will always match the empty sequence. 
On the other hand, suppose we want to erase comments in a C program. Many people would first try '/%*.*%*/' 
(that is, a "/*" followed by a sequence of any characters followed by "*/", written with the appropriate escapes). 
However, because the '.*' expands as far as it can, the first "/*" in the program would close only with the last "*/":
test = "int x; /* x */	int y; /* y */"
print((string.gsub(test, "/%*.*%*/", ""))) --> int x;
The pattern '.-', instead, will expand only as much as necessary to find the first "*/", so that we get the desired result:

test = "int x; /* x */	int y; /* y */"
print((string.gsub(test, "/%*.-%*/", ""))) --> int x;	int y;

The last modifier, the question mark, matches an optional character. As an example, suppose we want to find an integer in a text, where the number can contain an optional sign. 
The pattern '[+-]?%d+' does the job, matching numerals like "-12", "23", and "+1009". The character class '[+-]' matches either a plus or a minus sign; 
the following ? makes this sign optional.
Unlike some other systems, in Lua we can apply a modifier only to a character class; there is no way to group patterns under a modifier. 
For instance, there is no pattern that matches an optional word (unless the word has only one letter). Usually, we can circumvent this limitation using some of the advanced techniques that we will see in the end of this chapter.

If a pattern begins with a caret, it will match only at the beginning of the subject string. Similarly, if it ends with a dollar sign, it will match only at the end of the subject string. 
We can use these marks both to restrict the matches that we find and to anchor patterns. For instance, the next test checks whether the string s starts with a digit:

if string.find(s, "^%d") then ...

The next one checks whether that string represents an integer number, without any other leading or trailing characters:

if string.find(s, "^[+-]?%d+$") then ...

The caret and dollar signs are magic only when used in the beginning or end of the pattern. Otherwise, they act as regular characters matching themselves.

Another item in a pattern is '%b', which matches balanced strings. We write this item as '%bxy', where  x and y are any two distinct characters; 
the x acts as an opening character and the y as the closing one. For instance, the pattern '%b()' matches parts of the string that start with a left parenthesis and finish at the respective right one:

s = "a (enclosed (in) parentheses) line"
print((string.gsub(s, "%b()", "")))	--> a	line

Typically, we use this pattern as '%b()', '%b[]', '%b{}', or '%b<>', but we can use any two distinct characters as delimiters.

Finally, the item '%f[char-set]' represents a frontier pattern. It matches an empty string only if the next character is in char-set but the previous one is not:

s = "the anthem is the theme" print((string.gsub(s, "%f[%w]the%f[%W]", "one")))
--> one anthem is one theme

The pattern '%f[%w]' matches a frontier between a non-alphanumeric and an alphanumeric character, and the pattern '%f[%W]' matches a frontier between an alphanumeric and a non-alphanumeric character. 
Therefore, the given pattern matches the string "the" only as an entire word. Note that we must write the char-set inside brackets, even when it is a single class.

The frontier pattern treats the positions before the first and after the last characters in the subject string as if they had the null character (ASCII code zero). 
In the previous example, the first "the" starts with a frontier between a null character, which is not in the set '[%w]', and a t, which is.


Captures
The capture mechanism allows a pattern to yank parts of the subject string that match parts of the pattern for further use. 
We specify a capture by writing the parts of the pattern that we want to capture between parentheses.

When a pattern has captures, the function string.match returns each captured value as a separate result; in other words, it breaks a string into its captured parts.

pair = "name = Anna"
key, value = string.match(pair, "(%a+)%s*=%s*(%a+)")
print(key, value)	--> name	Anna
The pattern '%a+' specifies a non-empty sequence of letters; the pattern '%s*' specifies a possibly empty sequence of spaces. 
So, in the example above, the whole pattern specifies a sequence of letters, followed by a sequence of spaces, followed by an equals sign, again followed by spaces, plus another sequence of letters. 
Both sequences of letters have their patterns enclosed in parentheses, so that they will be captured if a match occurs. Below is a similar example:

date = "Today is 17/7/1990"
d, m, y = string.match(date, "(%d+)/(%d+)/(%d+)")
print(d, m, y)	--> 17	7	1990
In this example, we use three captures, one for each sequence of digits.

In a pattern, an item like '%n', where n is a single digit, matches only a copy of the n-th capture. 
As a typical use, suppose we want to find, inside a string, a substring enclosed between single or double quotes. 
We could try a pattern such as '["'].-["']', that is, a quote followed by anything followed by another quote; but we would have problems with strings like "it's all right". 
To solve this problem, we can capture the first quote and use it to specify the second one:

s = [[then he said: "it's all right"!]]
q, quotedPart = string.match(s, "([\"'])(.-)%1")
print(quotedPart)	--> it's all right
print(q)	--> "
The first capture is the quote character itself and the second capture is the contents of the quote (the substring matching the '.-').
A similar example is this pattern, which matches long strings in Lua:

%[(=*)%[(.-)%]%1%]
It will match an opening square bracket followed by zero or more equals signs, followed by another opening square bracket, followed by anything (the string content), 
followed by a closing square bracket, followed by the same number of equals signs, followed by another closing square bracket:

p = "%[(=*)%[(.-)%]%1%]"
s = "a = [=[[[ something ]] ]==] ]=];
print(a)"
print(string.match(s, p))	--> =	[[ something ]] ]==]
The first capture is the sequence of equals signs (only one sign in this example); the second is the string content.
The third use of captured values is in the replacement string of gsub. Like the pattern, the replacement string can also contain items like "%n", which are changed to the respective captures when the substitution is made. 
In particular, the item "%0" becomes the whole match. (By the way, a percent sign in the replacement string must be escaped as "%%".) 
As an example, the following command duplicates every letter in a string, with a hyphen between the copies:

print((string.gsub("hello Lua!", "%a", "%0-%0")))
--> h-he-el-ll-lo-o L-Lu-ua-a!
This one interchanges adjacent characters:

print((string.gsub("hello Lua", "(.)(.)", "%2%1")))
--> ehll ouLa
As a more useful example, let us write a primitive format converter, which gets a string with commands written in a LaTeX style and changes them to a format in XML style:

\command{some text}	-->	<command>some text</command>
If we disallow nested commands, the following call to string.gsub does the job:
s = [[the \quote{task} is to \em{change} that.]]
s = string.gsub(s, "\\(%a+){(.-)}", "<%1>%2</%1>")
print(s) --> the <quote>task</quote> is to <em>change</em> that.
(In the next section, we will see how to handle nested commands.) Another useful example is how to trim a string:
function trim (s)
    s = string.gsub(s, "^%s*(.-)%s*$", "%1")
    return s
end
Note the judicious use of pattern modifiers. The two anchors (^ and $) ensure that we get the whole string. Because the '.-' in the middle tries to expand as little as possible, 
the two enclosing patterns '%s*' match all spaces at both extremities.
Replacements
As we have seen already, we can use either a function or a table as the third argument to string.gsub, instead of a string. 
When invoked with a function, string.gsub calls the function every time it finds a match; the arguments to each call are the captures, 
and the value that the function returns becomes the replacement string. When invoked with a table, string.gsub looks up the table using the first capture as the key, 
and the associated value is used as the replacement string. If the result from the call or from the table lookup is nil, gsub does not change the match.
As a first example, the following function does variable expansion: it substitutes the value of the global variable varname for every occurrence of $varname in a string:
function expand (s)
　return (string.gsub(s, "$(%w+)", _G))
end

name = "Lua"; status = "great"
print(expand("$name is $status, isn't it?"))
--> Lua is great, isn't it?


(As we will discuss in detail in Chapter 22, The Environment, _G is a predefined table containing all global variables.) 
For each match with '$(%w+)' (a dollar sign followed by a name), gsub looks up the captured name in the global table _G; the result replaces the match. 
When the table does not have the key, there   is no replacement:

print(expand("$othername is $status, isn't it?"))
--> $othername is great, isn't it?
If we are not sure whether the given variables have string values, we may want to apply tostring to their values. In this case, we can use a function as the replacement value:

function expand (s)
    return (string.gsub(s, "$(%w+)", function (n) return tostring(_G[n]) end))
end

print(expand("print = $print; a = $a"))
--> print = function: 0x8050ce0; a = nil
Inside expand, for each match with '$(%w+)', gsub calls the given function with the captured name as argument; the returned string replaces the match.

The last example goes back to our format converter from the previous section. Again, we want to convert commands in LaTeX style (\example{text}) to XML style (<example>text</example>), 
but allowing nested commands this time. The following function uses recursion to do the job:

function toxml(s)
    s = string.gsub(s, "\\(%a+)(%b{})", function (tag, body)
        body = string.sub(body, 2, -2)	-- remove the brackets
        body = toxml(body)	-- handle nested commands
        return string.format("<%s>%s</%s>", tag, body, tag)
     end)
    return s
end

print(toxml("\\title{The \\bold{big} example}"))
--> <title>The <bold>big</bold> example</title>
URL encoding
Our next example will use URL encoding, which is the encoding used by HTTP to send parameters embedded in a URL. 
This encoding represents special characters (such as =, &, and +) as "%xx", where xx is the character code in hexadecimal. 
After that, it changes spaces to plus signs. For instance, it encodes the string "a+b = c" as "a%2Bb+%3D+c". 
Finally, it writes each parameter name and parameter value with an equals sign in between and appends all resulting pairs name = value with an ampersand in between. 
For instance, the values

name = "al";	query = "a+b = c"; q="yes or no"
are encoded as "name=al&query=a%2Bb+%3D+c&q=yes+or+no".
Now, suppose we want to decode this URL and store each value in a table, indexed by its corresponding name. The following function does the basic decoding:

function unescape (s)
    s = string.gsub(s, "+", " ")
    s = string.gsub(s, "%%(%x%x)", function (h) return string.char(tonumber(h, 16)) end)
    return s
end

print(unescape("a%2Bb+%3D+c"))	--> a+b = c
The first gsub changes each plus sign in the string to a space. The second gsub matches all two-digit hexadecimal numerals preceded by a percent sign and calls an anonymous function for each match. This function converts the hexadecimal numeral into a number (using tonumber with base 16) and returns the corresponding character (string.char).
To decode the pairs name=value, we use gmatch. Because neither names nor values can contain either ampersands or equals signs, we can match them with the pattern '[^&=]+':
cgi = {}
function decode(s)
    for name, value in string.gmatch(s, "([^&=]+)=([^&=]+)") do
        name = unescape(name)
        value = unescape(value)
        cgi[name] = value
　end
end
The call to gmatch matches all pairs in the form name=value. For each pair, the iterator returns the corresponding captures (as marked by the parentheses in the matching string) as the values for name and value. 
The loop body simply applies unescape to both strings and stores the pair in the cgi table.
The corresponding encoding is also easy to write. First, we write the escape function; this function encodes all special characters as a percent sign followed by the character code in hexadecimal (the format option "%02X" makes a hexadecimal number with two digits, using 0 for padding), and then changes spaces to plus signs:

function escape(s)
    s = string.gsub(s, "[&=+%%%c]", function (c) return string.format("%%%02X", string.byte(c)) end)
    s = string.gsub(s, " ", "+")
    return s
end
The encode function traverses the table to be encoded, building the resulting string:
function encode (t)
    local b = {}
    for k,v in pairs(t) do
　    b[#b + 1] = (escape(k) .. "=" .. escape(v))
    end
    -- concatenates all entries in 'b', separated by "&"
    return table.concat(b, "&")
end

t = {name = "al",	query = "a+b = c", q = "yes or no"}
print(encode(t)) --> q=yes+or+no&query=a%2Bb+%3D+c&name=al


Tab expansion
An empty capture like '()' has a special meaning in Lua. Instead of capturing nothing (a useless task), this pattern captures its position in the subject string, as a number:

print(string.match("hello", "()ll()"))	--> 3	5

(Note that the result of this example is not the same as what we get from string.find, because the position of the second empty capture is after the match.)

A nice example of the use of position captures is for expanding tabs in a string:

function expandTabs (s, tab)
    tab = tab or 8	-- tab "size" (default is 8)
    local corr = 0	-- correction
    s = string.gsub(s, "()\t", function (p)
        local sp = tab - (p - 1 + corr)%tab
        corr = corr - 1 + sp
　    return string.rep(" ", sp)
        end)
　return s end
The gsub pattern matches all tabs in the string, capturing their positions. For each tab, the anonymous function uses this position to compute the number of spaces needed to arrive at a column that is a multiple of tab: 
it subtracts one from the position to make it relative to zero and adds corr to compensate for previous tabs. 
(The expansion of each tab affects the position of the following ones.) It then updates the correction for the next tab: minus one for the tab being removed, plus sp for the spaces being added. 
Finally, it returns a string with the appropriate number of spaces to replace the tab.

Just for completeness, let us see how to reverse this operation, converting spaces to tabs. A first approach could also involve the use of empty captures to manipulate positions, 
but there is a simpler solution: at every eighth character, we insert a mark in the string. Then, wherever the mark is preceded by spaces, we replace the sequence spaces–mark by a tab:

function unexpandTabs (s, tab)
    tab = tab or 8
    s = expandTabs(s, tab)
    local pat = string.rep(".", tab)
    s = string.gsub(s, pat, "%0\1")
    s = string.gsub(s, " +\1", "\t")
    s = string.gsub(s, "\1", "")
    return s
end
The function starts by expanding the string to remove any previous tabs. Then it computes an auxiliary pattern for matching all sequences of eight characters, and uses this pattern to add a mark (the control character \1) after every eight characters. It then substitutes a tab for all sequences of one or more spaces followed by a mark. Finally, it removes the marks left (those not preceded by spaces).
Tricks of the Trade
Pattern matching is a powerful tool for manipulating strings. We can perform many complex operations with only a few calls to string.gsub. 
However, as with any power, we must use it carefully.


Pattern matching is not a replacement for a proper parser. For quick-and-dirty programs, we can do useful manipulations on source code, but it may be hard to build a product with quality. 
As a good example, consider the pattern we used to match comments in a C program: '/%*.-%*/'. If the program has a literal string containing "/*", we may get a wrong result:
test = [[char s[] = "a /* here";	/* a tricky string */]]
print((string.gsub(test, "/%*.-%*/", "<COMMENT>")))
--> char s[] = "a <COMMENT>
Strings with such contents are rare. For our own use, that pattern will probably do its job, but we should not distribute a program with such a flaw.

Usually, pattern matching is efficient enough for Lua programs: my new machine takes less than 0.2 seconds to count all words in a 4.4 MB text (850 K-words).
But we can take precautions. We should always make the pattern as specific as possible; loose patterns are slower than specific ones. 
An extreme example is '(.-)%$', to get all text in a string up to the first dollar sign. If the subject string has a dollar sign, everything goes fine, 
but suppose that the string does not contain any dollar signs. The algorithm will first try to match the pattern starting at the first position of the string. 
It will go through all the string, looking for a dollar. When the string ends, the pattern fails for the first position of the string. 
Then, the algorithm will do the whole search again, starting at the second position of the string, only to discover that the pattern does not match there, too, 
repeating the search for every position in the string. 
This will take a quadratic time, resulting in more than four minutes in my new machine for a string of 200K characters. 
We can correct this problem simply by anchoring the pattern at the first position of the string, with '^(.-)%$'. 
The anchor tells the algorithm to stop the search if it cannot find a match at the first position. 
With the anchor, the match runs in a hundredth of a second.

Beware also of empty patterns, that is, patterns that match the empty string. For instance, if we try to match names with a pattern like '%a*', we will find names everywhere:
i, j = string.find(";$%	**#$hello13", "%a*")
print(i,j)	--> 1	0
In this example, the call to string.find has correctly found an empty sequence of letters at the beginning of the string.

It never makes sense to write a pattern that ends with the minus modifier, because it will match only the empty string. 
This modifier always needs something after it to anchor its expansion. Similarly, patterns that include '.*' are tricky, 
because this construction can expand much more than we intended.
Sometimes, it is useful to use Lua itself to build a pattern. We already used this trick in our function to convert spaces to tabs. 
As another example, let us see how we can find long lines in a text, for instance lines with more than 70 characters. 
A long line is a sequence of 70 or more characters different from newline. We can match a single character different from newline with the character class '[^\n]'. 
Therefore, we can match a long line with a pattern that repeats 70 times the pattern for one character, finishing in a repetition for that pattern (to match the rest of the line). 
Instead of writing this pattern by hand, we can create it with string.rep:
pattern = string.rep("[^\n]", 70) .. "+"
As another example, suppose we want to make a case-insensitive search. A way of doing this is to change any letter x in the pattern to the class '[xX]', 
that is, a class including both the lower and the upper-case versions of the original letter. We can automate this conversion with a function:

function nocase (s)
    s = string.gsub(s, "%a", function (c) return "[" .. string.lower(c) .. string.upper(c) .. "]" end)
　return s
end

print(nocase("Hi there!"))	--> [hH][iI] [tT][hH][eE][rR][eE]!

Sometimes, we want to replace every plain occurrence of s1 with s2, without regarding any character as magic. 
If the strings s1 and s2 are literals, we can add proper escapes to magic characters while we write the strings. 
If these strings are variable values, we can use another gsub to put the escapes for us:

s1 = string.gsub(s1, "(%W)", "%%%1")
s2 = string.gsub(s2, "%%", "%%%%")
In the search string, we escape all non-alphanumeric characters (thus the upper-case W). In the replacement string, we escape only the percent sign.

Another useful technique for pattern matching is to preprocess the subject string before the real work. Suppose we want to change to upper case all quoted strings in a text, 
where a quoted string starts and ends with a double quote ("), but may contain escaped quotes ("\""):
follows a typical string: "This is \"great\"!".
One approach for handling such cases is to preprocess the text to encode the problematic sequence as something else. For instance, we could code "\"" as "\1". 
However, if the original text already contains a "\1", we are in trouble. An easy way to do the encoding and avoid this problem is to code all sequences "\x" as "\ddd", 
where ddd is the decimal representation of the character x:
function code(s)
    return (string.gsub(s, "\\(.)", function (x) return string.format("\\%03d", string.byte(x)) end))
end
Now any sequence "\ddd" in the encoded string must have come from the coding, because any "\ddd" in the original string has been coded, too. So, the decoding is an easy task:

function decode (s)
    return (string.gsub(s, "\\(%d%d%d)", function (d) return "\\" .. string.char(tonumber(d)) end))
end

Now we can complete our task. As the encoded string does not contain any escaped quote ("\""), we can search for quoted strings simply with '".-"':

s = [[follows a typical string: "This is \"great\"!".]]
s = code(s)
s = string.gsub(s, '".-"', string.upper)
s = decode(s)
print(s)	--> follows a typical string: "THIS IS \"GREAT\"!".
We can also write it like here:

print(decode(string.gsub(code(s), '".-"', string.upper)))

The applicability of pattern-matching functions to UTF-8 strings depends on the pattern. 
Literal patterns work without problems, due to the key property of UTF-8 that the encoding of any character never appears inside the encoding of any other character. 
Character classes and character sets work only for ASCII characters. For instance, the pattern '%s' works on UTF-8 strings, but it will match only the ASCII white spaces; 
it will not match extra Unicode white spaces such as a non-break space (U+00A0) or a Mongolian vowel separator (U+180E).

Judicious patterns can bring some extra power to Unicode handling. A good example is the predefined pattern utf8.charpattern, which matches exactly one UTF-8 character. 
The utf8 library defines this pattern as follows:

utf8.charpattern = [\0-\x7F\xC2-\xF4][\x80-\xBF]*
The first part is a class that matches either ASCII characters (range [0, 0x7F]) or initial bytes for multibyte sequences (range [0xC2, 0xF4]). 
The second part matches zero or more continuation bytes (range [0x80, 0xBF]).

Chapter 11. Interlude: Most Frequent Words
In this interlude we will develop a program that reads a text and prints the most frequent words in that text. 
As in the previous interlude, the program here is quite simple, but it uses some more advanced features, such as iterators and anonymous functions.

The main data structure of our program is a table that maps each word found in the text to its frequency counter. With this data structure, the program has three main tasks:

• Read the text, counting the number of occurrences of each word.

• Sort the list of words in descending order of frequencies.

• Print the first n entries in the sorted list.

To read the text, we can iterate over all its lines and, for each line, we iterate over all its words. For each word that we read, we increment its respective counter:

local counter = {}

for line in io.lines() do
    for word in string.gmatch(line, "%w+") do
        counter[word] = (counter[word] or 0) + 1
　end
end

Here, we describe a “word” using the pattern '%w+', that is, one or more alphanumeric characters.

The next step is to sort the list of words. However, as the attentive reader may have noticed already, we do not have a list of words to sort! 
Nevertheless, it is easy to create one, using the words that appear as keys in table counter:
local words = {}	-- list of all words found in the text
for w in pairs(counter) do
    words[#words + 1] = w
end
Once we have the list, we can sort it using table.sort: 
table.sort(words, function (w1, w2) 
    return counter[w1] > counter[w2] or counter[w1] == counter[w2] and w1 < w2
    end)

Remember that the order function must return true when w1 must come before w2 in the result. 
Words with larger counters come first; words with equal counters come in alphabetical order.

local counter = {}

for line in io.lines() do
    for word in string.gmatch(line, "%w+") do
        counter[word] = (counter[word] or 0) + 1
　end
end

local words = {}	-- list of all words found in the text
for w in pairs(counter) do
    words[#words + 1] = w
end

table.sort(words, function (w1, w2)
    return counter[w1] > counter[w2] or counter[w1] == counter[w2] and w1 < w2
    end)

-- number of words to print
local n = math.min(tonumber(arg[1]) or math.huge, #words)

for i = 1, n do
    io.write(words[i], "\t", counter[words[i]], "\n")
end
The last loop prints the result, which is the first n words and their respective counters. The program assumes that its first argument is the number of words to be printed; by default, it prints all words if no argument is given.

Chapter 12. Date and Time
The standard libraries offer few functions to manipulate date and time in Lua. As usual, all it offers is what is available in the standard C libraries. 
Nevertheless, despite its apparent simplicity, we can make quite a lot with this basic support.

Lua uses two representations for date and time. The first one is through a single number, usually an integer. 
Although not required by ISO C, on most systems this number is the number of seconds since some fixed date, called the epoch. 
In particular, both in POSIX and Windows systems the epoch is Jan 01, 1970, 0:00 UTC.

The second representation that Lua uses for dates and times is a table. Such date tables have the following significant fields: year, month, day, hour, min, sec, wday, yday, and isdst. 
All fields except isdst have integer values. The first six fields have obvious meanings. The wday field is the day of the week (one is Sunday); 
the yday field is the day of the year (one is January 1st). The isdst field is a Boolean, true if daylight saving is in effect. 
As an example, Sep 16, 1998, 23:48:10 (a Wednesday) corresponds to the following table:

{year = 1998, month = 9, day = 16, yday = 259, wday = 4, hour = 23, min = 48, sec = 10, isdst = false}
Date tables do not encode a time zone. It is up to the program to interpret them correctly with respect to time zones.

The Function os.time
The function os.time, when called without arguments, returns the current date and time, coded as a number:

> os.time()	--> 1439653520

This date corresponds to Aug 15, 2015, 12:45:20.1 In a POSIX system, we can use some basic arithmetic to decompose that number:

local date = 1439653520
local day2year = 365.242	-- days in a year
local sec2hour = 60 * 60	-- seconds in an hour
local sec2day = sec2hour * 24	-- seconds in a day
local sec2year = sec2day * day2year	-- seconds in a year

-- year
print(date // sec2year + 1970)	--> 2015.0

-- hour (in UTC)
print(date % sec2day // sec2hour)	--> 15

-- minutes
print(date % sec2hour // 60)	--> 45

-- seconds
print(date % 60)	--> 20

We can also call os.time with a date table, to convert the table representation to a number. The year, month, and day fields are mandatory. The hour, min, and sec fields default to noon (12:00:00) when not provided. Other fields (including wday and yday) are ignored.
> os.time({year=2015, month=8, day=15, hour=12, min=45, sec=20})
--> 1439653520
> os.time({year=1970, month=1, day=1, hour=0})	--> 10800
> os.time({year=1970, month=1, day=1, hour=0, sec=1})
--> 10801
> os.time({year=1970, month=1, day=1})	--> 54000
Note that 10800 is three hours (the time zone) in seconds and 54000 is 10800 plus 12 hours in seconds.
The Function os.date
The function os.date, despite its name, is a kind of reverse of os.time: it converts a number representing the date and time to some higher-level representation, either a date table or a string. 
Its first parameter is a format string, describing the representation we want. The second parameter is the numeric datetime; it defaults to the current date and time if not provided.

To produce a date table, we use the format string "*t". For instance, the call os.date("*t", 906000490) returns the following table:
{year = 1998, month = 9, day = 16, yday = 259, wday = 4, hour = 23, min = 48, sec = 10, isdst = false}
In general, we have that os.time(os.date("*t", t)) == t, for any valid time t. Except for isdst, the resulting fields are integers in the following ranges:
year	a full year
month	1–12
day	1–31
hour	0–23
min	0–59
sec	0–60
wday	1–7
yday	1–366
(Seconds can go up to 60 to allow for leap seconds.)

For other format strings, os.date returns a copy of the string with specific directives replaced by information about the given time and date. 
A directive consists of a percent sign followed by a letter, as in  the next example:

print(os.date("a %A in %B"))	--> a Tuesday in May
print(os.date("%d/%m/%Y", 906000490))	--> 16/09/1998

%a	abbreviated weekday name (e.g., Wed)
%A	full weekday name (e.g., Wednesday)
%b	abbreviated month name (e.g., Sep)
%B	full month name (e.g., September)
%c	date and time (e.g., 09/16/98 23:48:10)
%d	day of the month (16) [01–31]
%H	hour, using a 24-hour clock (23) [00–23]
%I	hour, using a 12-hour clock (11) [01–12]
%j	day of the year (259) [001–365]
%m	month (09) [01–12]
%M	minute (48) [00–59]
%p	either "am" or "pm" (pm)
%S	second (10) [00–60]
%w	weekday (3) [0–6 = Sunday–Saturday]
%W	week of the year (37) [00–53]
%x	date (e.g., 09/16/98)
%X	time (e.g., 23:48:10)
%y	two-digit year (98) [00–99]
%Y	full year (1998)
%z	timezone (e.g., -0300)
%%	a percent sign
For numerical values, the table shows also their range of possible values. Here are some examples, showing how to create some ISO 8601 formats:

t = 906000490
-- ISO 8601 date
print(os.date("%Y-%m-%d", t))	--> 1998-09-16
-- ISO 8601 combined date and time
print(os.date("%Y-%m-%dT%H:%M:%S", t))	--> 1998-09-16T23:48:10
-- ISO 8601 ordinal date
print(os.date("%Y-%j", t))	--> 1998-259
If the format string starts with an exclamation mark, then os.date interprets the time in UTC:
-- the Epoch
print(os.date("!%c", 0))	--> Thu Jan	1 00:00:00 1970
If we call os.date without any arguments, it uses the %c format, that is, date and time information in a reasonable format. 
Note that the representations for %x, %X, and %c change according to the locale and the system. 
If you want a fixed representation, such as dd/mm/yyyy, use an explicit format string, such as "%d/%m/%Y".


Date–Time Manipulation
When os.date creates a date table, its fields are all in the proper ranges. However, when we give a date table to os.time, its fields do not need to be normalized. 
This feature is an important tool to manipulate dates and times.
As a simple example, suppose we want to know the date 40 days from now. We can compute that date as follows:

t = os.date("*t")	-- get current time
print(os.date("%Y/%m/%d", os.time(t)))	--> 2015/08/18
t.day = t.day + 40
print(os.date("%Y/%m/%d", os.time(t)))	--> 2015/09/27
If we convert the numeric time back to a table, we get a normalized version of that date–time:

t = os.date("*t")
print(t.day, t.month) --> 26 2
t.day = t.day - 40
print(t.day, t.month) --> -14 2
t = os.date("*t", os.time(t))
print(t.day, t.month) --> 17 1
In this example, Feb -14 has been normalized to Jan 17, which is 40 days before Feb 26.
In most systems, we could also add or subtract 3456000 (40 days in seconds) to the numeric time. However, the C standard does not guarantee the correctness of this operation, 
because it does not require numeric times to denote seconds from some epoch. Moreover, if we want to add some months instead of days, the direct manipulation of seconds becomes problematic, as different months have different durations. 
The normalization method, on the other hand, has none of these problems:

t = os.date("*t")	-- get current time
print(os.date("%Y/%m/%d", os.time(t)))	--> 2015/08/18
t.month = t.month + 6	-- six months from now
print(os.date("%Y/%m/%d", os.time(t)))	--> 2016/02/18
We have to be careful when manipulating dates. Normalization works in a somewhat obvious way, but it may have some non-obvious consequences. 
For instance, if we compute one month after March 31, that would give April 31, which is normalized to May 1 (one day after April 30). That sounds quite natural. 
However, if we take one month back from that result (May 1), we arrive on April 1, not the original March 31. 
Note that this mismatch is a consequence of the way our calendar works; it has nothing to do with Lua.
To compute the difference between two times, there is the function os.difftime. It returns the difference, in seconds, between two given numeric times. 
For most systems, this difference is exactly the result of subtracting on time from the other. Unlike the subtraction, however, the behavior of os.difftime is guaranteed in any system. The next example computes the number of days passed between the release of Lua 5.2 and Lua 5.3:

local t5_3 = os.time({year=2015, month=1, day=12})
local t5_2 = os.time({year=2011, month=12, day=16})
local d = os.difftime(t5_3, t5_2)
print(d // (24 * 3600))	--> 1123.0
With difftime, we can express dates as number of seconds since any arbitrary epoch:
> myepoch = os.time{year = 2000, month = 1, day = 1, hour = 0}
> now = os.time{year = 2015, month = 11, day = 20}
> os.difftime(now, myepoch)	--> 501336000.0
Using normalization, it is easy to convert that number of seconds back to a legitimate numeric time: 
we create a table with the epoch and set its seconds as the number we want to convert, as in the next example.

> T = {year = 2000, month = 1, day = 1, hour = 0}
> T.sec = 501336000
> os.date("%d/%m/%Y", os.time(T))	--> 20/11/2015
We can also use os.difftime to compute the running time of a piece of code. For this task, however, it is better to use os.clock. 
The function os.clock returns the number of seconds of CPU time used by the program. Its typical use is to benchmark a piece of code:

local x = os.clock()
local s = 0
for i = 1, 100000 do
    s = s + i
end
print(string.format("elapsed time: %.2f\n", os.clock() - x))
Unlike os.time, os.clock usually has sub-second precision, so its result is a float. The exact precision depends on the platform; in POSIX systems, it is typically one microsecond.

Chapter 13. Bits and Bytes
Lua handles binary data similarly to text. A string in Lua can contain any bytes, and almost all library functions that handle strings can handle arbitrary bytes. 
We can even do pattern matching on binary data. On top of that, Lua 5.3 introduced extra facilities to manipulate binary data: 
besides integer numbers, it brought bitwise operators and functions to pack and unpack binary data. 
In this chapter, we will cover these and other facilities for handling binary data in Lua.
Bitwise Operators
Starting with version 5.3, Lua offers a standard set of bitwise operators on numbers. Unlike arithmetic operations, bitwise operators only work on integer values. 
The bitwise operators are & (bitwise AND), | (bitwise OR), ~ (bitwise exclusive-OR), >> (logical right shift), << (left shift), and the unary ~ (bitwise NOT). 
(Note that, in several languages, the exclusive-OR operator is denoted by ^. In Lua, ^ means exponentiation.)

> string.format("%x", 0xff & 0xabcd)	--> cd
> string.format("%x", 0xff | 0xabcd)	--> abff
> string.format("%x", 0xaaaa ~ -1)	--> ffffffffffff5555
> string.format("%x", ~0)	--> ffffffffffffffff
(Several examples in this chapter will use string.format to show results in hexadecimal.)
All bitwise operators work on all bits of integers. In Standard Lua, that means 64 bits. That can be a problem when implementing algorithms that assume 32-bit integers (e.g., the cryptographic hash SHA-2). 
However, it is not difficult to perform 32-bit integer manipulation. Except for the right-shift operation, all bitwise operations on 64 bits agree with the same operations on 32 bits, 
if we simply ignore the higher half bits. The same is true for addition, subtraction, and multiplication. 
So, all we have to do to operate on 32-bit integers is to erase the higher 32 bits of an integer before a right shift. (We seldom do divisions on that kind of computations.)
Both shift operators fill with zeros the vacant bits. This is usually called logical shifts. Lua does not offer an arithmetic right shift, which fills vacant bits with the signal bit. 
We can perform the equivalent to arithmetic shifts with a floor division by an appropriate power of two. (For instance, x // 16 is the same as an arithmetic shift by four.)
Negative displacements shift in the other direction, that is, a >> n is the same as a << -n:
> string.format("%x", 0xff << 12)	--> ff000
> string.format("%x", 0xff >> -12)	--> ff000
If the displacement is equal to or larger than the number of bits in the integer representation (64 in Standard Lua, 32 in Small Lua), the result is zero, as all bits are shifted out of the result:
> string.format("%x", -1 << 80)	--> 0
Unsigned Integers
The representation of integers uses one bit to store the signal. Therefore, the maximum integer that we can represent with 64-bit integers is 2^63 - 1, instead of 2^64 - 1. 
Usually, this difference is irrelevant, as 2^63 -   1 is quite large already. However, sometimes we cannot waste a bit for the signal, 
because we are either handling external data with unsigned integers or implementing some algorithm that needs integers with all their 64 bits. 
Moreover, in Small Lua the difference can be quite significant. For instance, if we use a 32- bit signed integer as a position in a file, we are limited to 2 GB files; 
an unsigned integer doubles that limit.

Lua does not offer explicit support for unsigned integers. Nevertheless, with some care, it is not difficult to handle unsigned integers in Lua, as we will see now.
We can write constants larger than 2^63 - 1 directly, despite appearances:
> x = 13835058055282163712	-- 3 << 62
> x	--> -4611686018427387904
The problem here is not the constant, but the way Lua prints it: the standard way to print numbers interprets them as signed integers. 
We can use the %u or %x options in string.format to see integers as unsigned:
> string.format("%u", x)	--> 13835058055282163712
> string.format("0x%X", x)	--> 0xC000000000000000
Due to the way signed integers are represented (two's complement), the operations of addition, subtraction, and multiplication work the same way for signed and unsigned integers:

> string.format("%u", x)	--> 13835058055282163712
> string.format("%u", x + 1)	--> 13835058055282163713
> string.format("%u", x - 1)	--> 13835058055282163711
(With such a large value, multiplying x even by two would overflow, so we did not include that operation in the example.)
Order operators work differently for signed and unsigned integers. The problem appears when we compare two integers with a difference in the higher bit. 
For signed integers, the integer with that bit set is the smaller, because it represents a negative number:

> 0x7fffffffffffffff < 0x8000000000000000	--> false
This result is clearly incorrect if we regard both integers as unsigned. So, we need a different operation to compare unsigned integers. 
Lua 5.3 provides math.ult (unsigned less than) for that need:
> math.ult(0x7fffffffffffffff, 0x8000000000000000)	--> true
Another way to do the comparison is to flip the signal bit of both operands before doing a signed comparison:
> mask = 0x8000000000000000
> (0x7fffffffffffffff ~ mask) < (0x8000000000000000 ~ mask)
--> true
Unsigned division is also different from its signed version. 

function udiv(n, d)
    if d < 0 then
        if math.ult(n, d) then return 0
        else return 1
        end
    end
    local q = ((n >> 1) // d) << 1
    local r = n - q * d
    if not math.ult(r, d) then q = q + 1 end
    return q
end

Converting an unsigned integer to/from a float needs some adjustments. To convert an unsigned integer to a float, we can convert it as a signed integer and correct the result with a modulo operator:

> u = 11529215046068469760	-- an example
> f = (u + 0.0) % 2^64
> string.format("%.0f", f)	--> 11529215046068469760
The value of u + 0.0 is -6917529027641081856, because the standard conversion sees u as a signed integer. 
The modulo operation brings the value back to the range of unsigned integers. (In real code we do not need the addition, because the modulo with a float would do the conversion anyway.)
To convert from a float to an unsigned integer, we can use the following code:

> f = 0xA000000000000000.0	-- an example
> u = math.tointeger(((f + 2^63) % 2^64) - 2^63)
> string.format("%x", u)	--> a000000000000000
The addition transforms a value greater than 2^63 in a value greater than 2^64. The modulo operator then projects this value to the range [0,2^63), and the subtraction makes it a “negative” value (that is, a value with the highest bit set). 
For a value smaller than 2^63, the addition keeps it smaller than 2^64, the modulo operator does not affect it, and the subtraction restores its original value.
Packing and Unpacking Binary Data
Lua 5.3 also introduced functions for converting between binary data and basic values (numbers and strings). 
The function string.pack “packs” values into a binary string; string.unpack extracts those values from the string.
Both string.pack and string.unpack get as their first argument a format string, which describes how the data is packed. 
Each letter in this string describes how to pack/unpack one value; see the following example:

> s = string.pack("iii", 3, -27, 450)
> #s	--> 12
> string.unpack("iii", s)	--> 3	-27	450	13
This call to string.pack creates a string with the binary codes of three integers (according to the description "iii"), each encoding its corresponding argument. 
The string length will be three times the native size of an integer (3 times 4 bytes in my machine). 
The call to string.unpack decodes three integers (again according to "iii") from the given string and returns the decoded values.
The function string.unpack also returns the position in the string after the last item read, to simplify iterations. (This explains the 13 in the results of the last example.) 
Accordingly, it accepts an optional third argument, which tells where to start reading. For instance, the next example prints all strings packed inside a given string:


s = "hello\0Lua\0world\0"
local i = 1
while i <= #s do
    local res
    res, i = string.unpack("z", s, i)
   print(res)
end
--> hello
--> Lua
--> world
As we will see, the z option means a zero-terminated string, so that the call to unpack extracts the string at position i from s and returns that string plus the next position for the loop.
There are several options for coding an integer, each corresponding to a native integer size: b (char), h (short), i (int), and l (long); the option j uses the size of a Lua integer. 
To use a fixed, machine-in- dependent size, we can suffix the i option with a number from one to 16. For instance, i7 will produce seven-byte integers. All sizes check for overflows:

> x = string.pack("i7", 1 << 54)
> string.unpack("i7", x)	--> 18014398509481984	8
> x = string.pack("i7", -(1 << 54))
> string.unpack("i7", x)	--> -18014398509481984	8
> x = string.pack("i7", 1 << 55)
stdin:1: bad argument #2 to 'pack' (integer overflow)
We can pack and unpack integers wider than native Lua integers but, when unpacking, their actual values must fit into Lua integers:
> x = string.pack("i12", 2^61)
> string.unpack("i12", x)	--> 2305843009213693952	13
> x = "aaaaaaaaaaaa"	-- fake a large 12-byte number
> string.unpack("i12", x)
stdin:1: 12-byte integer does not fit into Lua Integer
Each integer option has an upper-case version corresponding to an unsigned integer of the same size:

> s = "\xFF"
> string.unpack("b", s) --> -1 2
> string.unpack("B", s) --> 255 2
Moreover, unsigned integers have an extra option T for size_t. (The size_t type in ISO C is an unsigned integer larger enough to hold the size of any object.)
We can pack strings in three representations: zero-terminated strings, fixed-length strings, and strings with explicit length. 
Zero-terminated strings use the z option. For fixed-length strings, we use the option cn, where n is the number of bytes in the packed string. 
The last option for strings stores the string preceded by its length. In that case, the option has the format sn, where n is the size of the unsigned integer used to store the length. 
For instance, the option s1 stores the string length in one byte:
s = string.pack("s1", "hello")
for i = 1, #s do
    print((string.unpack("B", s, i)))
end
--> 5	(length)
--> 104	('h')
--> 101	('e')
--> 108	('l')
--> 108	('l')
--> 111	('o')
Lua raises an error if the length does not fit into the given size. We can also use a pure s as the option; in that case, the length is stored as a size_t, which is large enough to hold the length of any string.   
(In 64-bit machines, size_t usually is an eight-byte unsigned integer, which may be a waste of space for small strings.)
For floating-point numbers, there are three options: f for single precision, d for double precision, and n for a Lua float.
The format string also has options to control the endianess and the alignment of the binary data. By default, a format uses the machine's native endianess. 
The > option turns all subsequent encodings in that format to big endian, or network byte order:

s = string.pack(">i4", 1000000)
for i = 1, #s do
    print((string.unpack("B", s, i)))
end
--> 0
--> 15
--> 66
--> 64
The < option turns to little endian:
s = string.pack("<i2 i2", 500, 24)
for i = 1, #s do
    print((string.unpack("B", s, i)))
end
--> 244
--> 1
--> 24
--> 0
Finally, the = option turns back to the default machine's native endianess.
For alignment, the !n option forces data to align at indices that are multiples of n. More specifically, if the item is smaller than n, it is aligned at its own size; 
otherwise, it is aligned at n. For instance, suppose we start the format string with !4. Then, one-byte integers will be written in indices multiple of one (that is, any index), 
two-byte integers will be written in indices multiple of two, and four-byte or larger integers will be written in indices multiple of four. 
The ! option (without a number) sets the alignment to the machine's native alignment.
The function string.pack does the alignment by adding zeros to the resulting string until the index has a proper value. 
The function string.unpack simply skips the padding when reading the string. Alignment only works for powers of two: 
if we set the alignment to four and try to manipulate a three- byte integer, Lua will raise an error.
Any format string works as if prefixed by "=!1", which means native endianess and no alignment (as every index is a multiple of one). 
We can change the endianess and the alignment at any point during  the translation.
If needed, we can add padding manually. The option x means one byte of padding; string.pack adds a zero byte to the resulting string; string.unpack skips one byte from the subject string.
Binary files
The functions io.input and io.output always open a file in text mode. In POSIX, there is no difference between binary files and text files. 
In some systems like Windows, however, we must open binary files in a special way, using the letter b in the mode string of io.open.

Typically, we read binary data either with the "a" pattern, that reads the whole file, or with the pattern n, that reads n bytes. (Lines make no sense in a binary file.) 
As a simple example, the following program converts a text file from Windows format to POSIX format —that is, it translates sequences of carriage return–newlines to newlines:

local inp = assert(io.open(arg[1], "rb"))
local out = assert(io.open(arg[2], "wb"))

local data = inp:read("a")
data = string.gsub(data, "\r\n", "\n")
out:write(data)

assert(out:close())

It cannot use the standard I/O streams (stdin/stdout), because these streams are open in text mode. 
Instead, it assumes that the names of the input file and the output file are arguments to the program. We can call this program with the following command line:

> lua prog.lua file.dos file.unix

As another example, the following program prints all strings found in a binary file:

local f = assert(io.open(arg[1], "rb"))
local data = f:read("a")
local validchars = "[%g%s]"
local pattern = "(" .. string.rep(validchars, 6) .. "+)\0"
for w in string.gmatch(data, pattern) do
　print(w)
end
The program assumes that a string is any zero-terminated sequence of six or more valid characters, where a valid character is any character accepted by the pattern validchars. 
In our example, this pattern comprises the printable characters. We use string.rep and concatenation to create a pattern that matches all sequences of six or more validchars ended by a zero. 
The parentheses in the pattern capture the string without the zero.

Our last example is a program to make a dump of a binary file, showing its contents in hexadecimal. 

local f = assert(io.open(arg[1], "rb"))

local blocksize = 16
for bytes in f:lines(blocksize) do
    for i = 1, #bytes do
        local b = string.unpack("B", bytes, i)
        io.write(string.format("%02X ", b))
    end
    io.write(string.rep("   ", blocksize - #bytes))
    bytes = string.gsub(bytes, "%c", ".")
　io.write(" ", bytes, "\n")
end
Again, the first program argument is the input file name; the output is regular text, so it can go to the standard output. 
The program reads the file in chunks of 16 bytes. For each chunk, it writes the hexadecimal representation of each byte, 
and then it writes the chunk as text, changing control characters to dots. We use string.rep to fill with blanks the last line (which in general will not have exactly 16 bytes), keeping the alignment.

Chapter 14. Data Structures
We can represent all structures that other languages offer —arrays, records, lists, queues, sets— with tables in Lua. Moreover, Lua tables implement all these structures efficiently.

In more traditional languages, such as C and Pascal, we implement most data structures with arrays and lists (where lists = records + pointers). 
Although we can implement arrays and lists using Lua tables (and sometimes we do this), tables are more powerful than arrays and lists; 
many algorithms are simplified to the point of triviality with the use of tables. For instance, we seldom write a search in Lua, because tables offer direct access to any type.

It takes a while to learn how to use tables efficiently. Here, we will see how to implement typical data structures with tables and cover some examples of their uses. 
We will start with arrays and lists, not because we need them for the other structures, but because most programmers are already familiar with them. 
(We have already seen the basics of this material in Chapter 5, Tables, but I will repeat it here for completeness.) 
Then we will continue with more advanced examples, such as sets, bags, and graphs.

Arrays
We implement arrays in Lua simply by indexing tables with integers. Therefore, arrays do not have a fixed size, but grow as needed. 
Usually, when we initialize the array we define its size indirectly. For instance, after the following code, any attempt to access a field outside the range 1–1000 will return nil, instead   of zero:

local a = {}	-- new array
for i = 1, 1000 do
    a[i] = 0
end

The length operator (#) uses this fact to find the size of an array:

print(#a)	--> 1000

We can start an array at index zero, one, or any other value:

-- create an array with indices from -5 to 5
a = {}
for i = -5, 5 do
    a[i] = 0
end

However, it is customary in Lua to start arrays with index one. The Lua libraries adhere to this convention; so does the length operator. 
If our arrays do not start with one, we will not be able to use these facilities.

We can use a constructor to create and initialize arrays in a single expression:

squares = {1, 4, 9, 16, 25, 36, 49, 64, 81}

Such constructors can be as large as we need. In Lua, it is not uncommon data-description files with constructors with a few million elements.


Matrices and Multi-Dimensional Arrays
There are two main ways to represent matrices in Lua. The first one is with a jagged array (an array of arrays), that is, a table wherein each element is another table. 
For instance, we can create a matrix of zeros with dimensions N by M with the following code:
local mt = {}	-- create the matrix
for i = 1, N do
    local row = {}	-- create a new row
    mt[i] = row
    for j = 1, M do
        row[j] = 0
　end
end
Because tables are objects in Lua, we have to create each row explicitly to build a matrix. On the one hand, this is certainly more verbose than simply declaring a matrix, as we do in C. On the other hand, it gives us more flexibility. 
For instance, we can create a triangular matrix by changing the inner loop in the previous example to for j=1,i do ... end. With this code, the triangular matrix uses only half the memory of the original one.

The second way to represent a matrix is by composing the two indices into a single one. Typically, we do this by multiplying the first index by a suitable constant and then adding the second index. 
With this approach, the following code would create our matrix of zeros with dimensions N by M:
local mt = {}	-- create the matrix
for i = 1, N do
    local aux = (i - 1) * M
    for j = 1, M do
　    mt[aux + j] = 0
    end
end

Quite often, applications use a sparse matrix, a matrix wherein most elements are zero or nil. For instance, we can represent a graph by its adjacency matrix, 
which has the value x in position (m,n) when there is a connection with cost x between nodes m and n. When these nodes are not connected, the value in position (m,n) is nil. 
To represent a graph with ten thousand nodes, where each node has about five neighbors,  we will need a matrix with a hundred million entries (a square matrix with 10000 columns and 10000 rows), 
but approximately only fifty thousand of them will not be nil (five non-nil columns for each row, corresponding to the five neighbors of each node). 
Many books on data structures discuss at length how to implement such sparse matrices without wasting 800 MB of memory, 
but we seldom need these techniques when programming in Lua. Because we represent arrays with tables, they are naturally sparse. 
With our first representation (tables of tables), we will need ten thousand tables, each one with about five elements, with a grand total of fifty thousand entries. 
With the second representation, we will have a single table, with fifty thousand entries in it. Whatever the representation, we need space only for the non-nil elements.

We cannot use the length operator over sparse matrices, because of the holes (nil values) between active entries. This is not a big loss; even if we could use it, we probably would not. 
For most operations, it would be quite inefficient to traverse all those empty entries. Instead, we can use pairs to traverse only the non- nil elements. 
As an example, let us see how to do matrix multiplication with sparse matrices represented by jagged arrays.

Suppose we want to multiply a matrix a[M,K] by a matrix b[K,N], producing the matrix c[M,N]. The usual matrix-multiplication algorithm goes like this:

for i = 1, M do
    for j = 1, N do
        c[i][j] = 0
        for k = 1, K do
　        c[i][j] = c[i][j] + a[i][k] * b[k][j]
        end
    end
end
The two outer loops traverse the entire resulting matrix, and for each element, the inner loop computes its value.

For sparse matrices with jagged arrays, this inner loop is a problem. Because it traverses a column of b, instead of a row, we cannot use something like pairs here: 
the loop has to visit each row looking whether that row has an element in that column. Instead of visiting only a few non-zero elements, the loop visits all zero elements, too. 
(Traversing a column can be an issue in other contexts, too, because of its loss of spatial locality.)

The following algorithm is quite similar to the previous one, but it reverses the order of the two inner loops. With this simple change, it avoids traversing columns:

-- assumes 'c' has zeros in all elements
for i = 1, M do
    for k = 1, K do
        for j = 1, N do
　        c[i][j] = c[i][j] + a[i][k] * b[k][j]
        end
    end
end
Now, the middle loop traverses the row a[i], and the inner loop traverses the row b[k]. Both can use pairs, visiting only the non-zero elements. 
The initialization of the resulting matrix c is not an issue here, because an empty sparse matrix is naturally filled with zeros.

Figure 14.1. Multiplication of sparse matrices

function mult (a, b)
    local c = {}	-- resulting matrix
    for i = 1, #a do
        local resultline = {}	-- will be 'c[i]'
        for k, va in pairs(a[i]) do	-- 'va' is a[i][k]
            for j, vb in pairs(b[k]) do	-- 'vb' is b[k][j]
                local res = (resultline[j] or 0) + va * vb
                resultline[j] = (res ~= 0) and res or nil
            end
        end
　    c[i] = resultline
    end
　return c
end
Figure 14.1, “Multiplication of sparse matrices” shows the complete implementation of the above algorithm, using pairs and taking care of sparse entries. 
This implementation visits only the non-nil elements, and the result is naturally sparse. Moreover, the code deletes resulting entries that by chance evaluate to zero.


Linked Lists
Because tables are dynamic entities, it is easy to implement linked lists in Lua. We represent each node with a table (what else?); 
links are simply table fields that contain references to other tables. For instance, let us implement a singly-linked list, 
where each node has two fields, value and next. A simple variable is the list root:

list = nil

To insert an element at the beginning of the list, with a value v, we do this:

list = {next = list, value = v}

To traverse the list, we write this:

local l = list
while l do
    visit l.value
　l = l.next
end

We can also implement easily other kinds of lists, such as doubly-linked lists or circular lists. However, we seldom need those structures in Lua, 
because usually there is a simpler way to represent our data without using linked lists. For instance, we can represent a stack with an (unbounded) array.

Queues and Double-Ended Queues
A simple way to implement queues in Lua is with functions insert and remove from the table library. 
As we saw in the section called “The Table Library”, these functions insert and remove elements in any position of an array, moving other elements to accommodate the operation. 
However, these moves can be expensive for large structures. A more efficient implementation uses two indices, one for the first element and another for the last. 
With that representation, we can insert or remove an element at both ends in constant time, as shown in Figure 14.2, “A double-ended queue”.


Figure 14.2. A double-ended queue
function listNew ()
　return {first = 0, last = -1}
end

function pushFirst (list, value)
    local first = list.first - 1
    list.first = first
　list[first] = value
end

function pushLast (list, value)
    local last = list.last + 1
    list.last = last
　list[last] = value
end

function popFirst (list)
    local first = list.first
    if first > list.last then
        error("list is empty")
    end
    local value = list[first]
    list[first] = nil	-- to allow garbage collection
    list.first = first + 1
　return value
end

function popLast (list)
    local last = list.last
    if list.first > last then
        error("list is empty")
    end
    local value = list[last]
    list[last] = nil	-- to allow garbage collection
    list.last = last - 1
　return value
end
If we use this structure in a strict queue discipline, calling only pushLast and popFirst, both first and last will increase continually. 
However, because we represent arrays in Lua with tables, we can index them either from 1 to 20 or from 16777201 to 16777220. 
With 64-bit integers, such a queue can run for thirty thousand years, doing ten million insertions per second, before it has problems with overflows.
Reverse Tables
As I said, before, we seldom do searches in Lua. Instead, we use what we call an index table or a reverse table.
Suppose we have a table with the names of the days of the week:

days = {"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"}
Now we want to translate a name into its position in the week. We can search the table, looking for the given name. 
A more efficient approach, however, is to build a reverse table, say revDays, which has the names as indices and the numbers as values. This table would look like this:


revDays = {["Sunday"] = 1, ["Monday"] = 2,
["Tuesday"] = 3, ["Wednesday"] = 4,
["Thursday"] = 5, ["Friday"] = 6,
["Saturday"] = 7}
Then, all we have to do to find the order of a name is to index this reverse table:

x = "Tuesday"
print(revDays[x])	--> 3
Of course, we do not need to declare the reverse table manually. We can build it automatically from the original one:

revDays = {}
for k,v in pairs(days) do
    revDays[v] = k
end
The loop will do the assignment for each element of days, with the variable k getting the keys (1, 2, ...) and v the values ("Sunday", "Monday", ...).
Sets and Bags
Suppose we want to list all identifiers used in a program source; for that, we need to filter the reserved words out of our listing. 
Some C programmers could be tempted to represent the set of reserved words as an array of strings and search this array to know whether a given word is in the set. 
To speed up the search, they could even use a binary tree to represent the set.

In Lua, an efficient and simple way to represent such sets is to put the set elements as indices in a table. 
Then, instead of searching the table for a given element, we just index the table and test whether the result is nil. 
In our example, we could write the following code:

reserved = {
["while"] = true,	["if"] = true,
["else"] = true,	["do"] = true,
}

for w in string.gmatch(s, "[%a_][%w_]*") do
    if not reserved[w] then
　    do something with 'w'	-- 'w' is not a reserved word
    end
end
(In the definition of reserved, we cannot write while = true, because while is not a valid name in Lua. Instead, we use the notation ["while"] = true.)
We can have a clearer initialization using an auxiliary function to build the set:

function Set (list)
    local set = {}
    for _, l in ipairs(list) do
        set[l] = true
    end
    return set
end

reserved = Set{"while", "end", "function", "local", }

We can also use another set to collect the identifiers:

local ids = {}
for w in string.gmatch(s, "[%a_][%w_]*") do
    if not reserved[w] then
　    ids[w] = true
    end
end

-- print each identifier once
for w in pairs(ids) do
    print(w)
end
Bags, also called multisets, differ from regular sets in that each element can appear multiple times. 
An easy representation for bags in Lua is similar to the previous representation for sets, but with a counter associated with each key.
To insert an element, we increment its counter:
function insert (bag, element)
    bag[element] = (bag[element] or 0) + 1
end
To remove an element, we decrement its counter:

function remove (bag, element)
    local count = bag[element]
　bag[element] = (count and count > 1) and count - 1 or nil
end
We only keep the counter if it already exists and it is still greater than zero.

String Buffers
 Suppose we are building a string piecemeal, for instance reading a file line by line. Our typical code could look like this:

local buff = ""
for line in io.lines() do
    buff = buff .. line .. "\n"
end
Despite its innocent look, this code in Lua can cause a huge performance penalty for large files: for instance, it takes more than 30 seconds to read a 4.5 MB file on my new machine.

Why is that? To understand what happens, let us imagine that we are in the middle of the read loop; each line has 20 bytes and we have already read some 2500 lines, so buff is a string with 50 kB. 
When Lua concatenates buff..line.."\n", it allocates a new string with 50020 bytes and copies the 50000 bytes from buff into this new string. 
That is, for each new line, Lua moves around 50 kB of memory, and growing. The algorithm is quadratic. After reading 100 new lines (only 2 kB), Lua has already moved more than 5 MB of memory. 
When Lua finishes reading 350 kB, it has moved around more than 50 GB. (This problem is not peculiar to Lua: other languages wherein strings are immutable values present a similar behavior, Java being a famous example.)

Before we continue, we should remark that, despite all I said, this situation is not a common problem. For small strings, the above loop is fine. 
To read an entire file, Lua provides the io.read("a") option, which reads the file at once. However, sometimes we must face this problem. 
Java offers the StringBuffer class to ameliorate the problem. In Lua, we can use a table as the string buffer. 
The key to this approach is the function table.concat, which returns the concatenation of all the strings of a given list. Using concat, we can write our previous loop as follows:

local t = {}
for line in io.lines() do
    t[#t + 1] = line .. "\n"
end
local s = table.concat(t)

This algorithm takes less than 0.05 seconds to read the same file that took more than half a minute to read with the original code. 
(Nevertheless, for reading a whole file it is still better to use io.read with the "a" option.)
We can do even better. The function concat accepts an optional second argument, which is a separator to be inserted between the strings. 
Using this separator, we do not need to insert a newline after each line:

local t = {}
for line in io.lines() do
    t[#t + 1] = line
end
s = table.concat(t, "\n") .. "\n"

The function inserts the separator between the strings, but we still have to add the last newline. 
This last concatenation creates a new copy of the resulting string, which can be quite long. There is no option to make concat insert this extra separator, 
but we can deceive it, inserting an extra empty string in t:

t[#t + 1] = ""
s = table.concat(t, "\n")

Now, the extra newline that concat adds before this empty string is at the end of the resulting string, as we wanted.

Graphs
Like any decent language, Lua allows multiple implementations for graphs, each one better adapted to some particular algorithms. 
Here we will see a simple object-oriented implementation, where we represent nodes as objects (actually tables, of course) and arcs as references between nodes.

We will represent each node as a table with two fields: name, with the node's name; and adj, with the set of nodes adjacent to this one. 
Because we will read the graph from a text file, we need a way to find  a node given its name. So, we will use an extra table mapping names to nodes. 
Given a name, function name2node returns the corresponding node:

local function name2node (graph, name)
    local node = graph[name]
    if not node then
        -- node does not exist; create a new one
        node = {name = name, adj = {}}
        graph[name] = node
    end
　return node
end

function readgraph ()
    local graph = {}
    for line in io.lines() do
        -- split line in two names
        local namefrom, nameto = string.match(line, "(%S+)%s+(%S+)")
        -- find corresponding nodes
        local from = name2node(graph, namefrom)
        local to = name2node(graph, nameto)
        -- adds 'to' to the adjacent set of 'from'
        from.adj[to] = true
    end
　return graph
end
It reads a file where each line has two node names, meaning that there is an arc from the first node to the second. 
For each line, the function uses string.match to split the line in two names, finds the nodes corresponding to these names (creating the nodes if needed), and connects the nodes.

function findpath(curr, to, path, visited)
    path = path or {}
    visited = visited or {}
    if visited[curr] then	-- node already visited?
        return nil	-- no path here
    end
    visited[curr] = true	-- mark node as visited
    path[#path + 1] = curr	-- add it to path
    if curr == to then	-- final node?
        return path
    end
    -- try all adjacent nodes
    for node in pairs(curr.adj) do
        local p = findpath(node, to, path, visited)
        if p then
            return p
        end
    end
　table.remove(path)	-- remove node from path
end
The function findpath searches for a path between two nodes using a depth-first traversal. Its first parameter is the current node; the second is its goal; 
the third parameter keeps the path from the origin to the current node; the last parameter is a set with all the nodes already visited, to avoid loops. 
Note how the algorithm manipulates nodes directly, without using their names. For instance, visited is a set of nodes, not of node names. Similarly, path is a list of nodes.
To test this code, we add a function to print a path and some code to put it all to work:

function printpath (path)
    for i = 1, #path do
　    print(path[i].name)
    end
end

g = readgraph()
a = name2node(g, "a")
b = name2node(g, "b")
p = findpath(a, b)
if p then
    printpath(p)
end

Chapter 15. Data Files and Serialization
When dealing with data files, it is usually much easier to write the data than to read it back. When we write a file, we have full control of what is going on. 
When we read a file, on the other hand, we do not know what to expect. Besides all the kinds of data that a correct file can contain, 
a robust program should also handle bad files gracefully. Therefore, coding robust input routines is always difficult. 
In this chapter, we will see how we can use Lua to eliminate all code for reading data from our programs, simply by writing the data in an appropriate format. 
More specifically, we write data as Lua programs that, when run, rebuild the data.
Data description has been one of the main applications of Lua since its creation in 1993. At that time, the main alternative for a textual data-description language would be SGML. 
For many people (including us), SGML is bloated and complex. In 1998, some people simplified it to create XML, which in our view is still bloated and complex. 
Other people shared our view, and some of them created JSON (in 2001). JSON is based on Javascript and quite similar to restricted Lua data files. 
On the one hand, JSON has a big advantage of being an international standard, and several languages (including Lua) have libraries to manipulate JSON files. 
On the other hand, Lua files are trivial to read and more flexible.
Using a full programming language for data description is surely flexible, but it brings two problems. One is security, as “data” files can run amok inside our program. 
We can solve that by running the file in a sandbox, which we will discuss in the section called “Sandboxing”.
The other problem is performance. Lua not only runs fast, but it also compiles fast. For instance, in my new machine, Lua 5.3 reads, compiles, and runs a program with ten million assignments in four seconds, using 240 MB. 
For comparison, Perl 5.18 takes 21 seconds and 6 GB, Python 2.7 and Python 3.4 trash the machine, Node.js 0.10.25 gives an “out of memory” error after eight seconds, and Rhino 1.7 also gives an “out of memory” error, after six minutes.
Data Files
Table constructors provide an interesting alternative for file formats. With a little extra work when writing data, reading becomes trivial. 
The technique is to write our data file as Lua code that, when run, rebuilds the data into the program. 
With table constructors, these chunks can look remarkably like a plain data file.
Let us see an example to make things clear. If our data file is in a predefined format, such as CSV (Comma-Separated Values) or XML, we have little choice. 
However, if we are going to create the file for our own use, we can use Lua constructors as our format. In this format, we represent each data record as a Lua constructor. 
Instead of writing in our data file something like
Donald E. Knuth,Literate Programming,CSLI,1992
Jon Bentley,More Programming Pearls,Addison-Wesley,1990
we write this:
Entry{"Donald E. Knuth", "Literate Programming", "CSLI", 1992}
Entry{"Jon Bentley", "More Programming Pearls", "Addison-Wesley", 1990}
Remember that Entry{code} is the same as Entry({code}), that is, a call to some function Entry with a table as its single argument. 
So, that previous piece of data is a Lua program. To read that file, we only need to run it, with a sensible definition for Entry. 
For instance, the following program counts the number of entries in a data file:

local count = 0
function Entry()
    count = count + 1
end
dofile("data")
print("number of entries: " .. count)
The next program collects in a set the names of all authors found in the file, and then prints them:

local authors = {}	-- a set to collect authors
function Entry(b)
    authors[b[1]] = true
end
dofile("data")
for name in pairs(authors) do
    print(name)
end

Note the event-driven approach in these program fragments: the function Entry acts as a callback function, which is called during the dofile for each entry in the data file.
When file size is not a big concern, we can use name-value pairs for our representation:
Entry{ author = "Donald E. Knuth", title = "Literate Programming", publisher = "CSLI", year = 1992}
Entry{author = "Jon Bentley", title = "More Programming Pearls", year = 1990, publisher = "Addison-Wesley",}
This format is what we call a self-describing data format, because each piece of data has attached to it a short description of its meaning. 
Self-describing data are more readable (by humans, at least) than CSV or other compact notations; they are easy to edit by hand, when necessary; 
and they allow us to make small modifications in the basic format without having to change the data file. 
For instance, if we add a new field we need only a small change in the reading program, so that it supplies a default value when the field is absent.

With the name-value format, our program to collect authors becomes this:

local authors = {}	-- a set to collect authors
function Entry(b)
    authors[b.author] = true
end
dofile("data")
for name in pairs(authors) do
    print(name)
end
Now the order of fields is irrelevant. Even if some entries do not have an author, we have to adapt only the function Entry:
function Entry(b)
    authors[b.author or "unknown"] = true
end

Serialization
Frequently we need to serialize some data, that is, to convert the data into a stream of bytes or characters, so that we can save it into a file or send it through a network connection. 
We can represent serialized data as Lua code in such a way that, when we run the code, it reconstructs the saved values into the reading program.
Usually, if we want to restore the value of a global variable, our chunk will be something like varname = exp, where exp is the Lua code to create the value. 
The varname is the easy part, so let us see how to write the code that creates a value. For a numeric value, the task is easy:

function serialize(o)
    if type(o) == "number" then
        io.write(tostring(o))
    else
        other cases
　end
end
By writing a float in decimal format, however, we risk losing some precision. We can use a hexadecimal format to avoid this problem. 
With format ("%a"), the read float will have exactly the same bits of the original one. Moreover, since Lua 5.3 we should distinguish between integers and floats, 
so that they can be restored with the correct subtype:

local fmt = {integer = "%d", float = "%a"}

function serialize(o)
    if type(o) == "number" then
        io.write(string.format(fmt[math.type(o)], o))
    else
        other cases
    end
end
For a string value, a naive approach would be something like this:

if type(o) == "string" then
    io.write("'", o, "'")
end
However, if the string contains special characters (such as quotes or newlines) the resulting code will not be a valid Lua program.
You may be tempted to solve this problem changing quotes:

if type(o) == "string" then
    io.write("[[", o, "]]")
end
Beware of code injection! If a malicious user manages to direct your program to save something like     " ]]..os.execute('rm *')..[[ " 
(for instance, she can supply this string as her address), your final chunk will be like this one:

varname = [[ ]]..os.execute('rm *')..[[ ]]
You will have a bad surprise trying to load this “data”.
A simple way to quote a string in a secure way is with the option "%q" from string.format. This option was designed to save the string in a way that it can be safely read back by Lua. 
It surrounds the string with double quotes and properly escapes double quotes, newlines, and some other characters inside the string:

a = 'a "problematic" \\string'
print(string.format("%q", a))	--> "a \"problematic\" \\string"
Using this feature, our serialize function now looks like this:
function serialize(o)
    if type(o) == "number" then
        io.write(string.format(fmt[math.type(o)], o))
    elseif type(o) == "string" then
        io.write(string.format("%q", o))
    else
        other cases
    end
end
Lua 5.3.3 extended the format option "%q" to work also with numbers (plus nil and Booleans), again writing them in a proper way to be read back by Lua. 
(In particular, it formats floats in hexadecimal, to ensure full precision.) Thus, since that version, we can simplify and extend serialize even more:
function serialize(o)
    local t = type(o)
    if t == "number" or t == "string" or t == "boolean" or t == "nil" then
　    io.write(string.format("%q", o))
    else
        other cases
　end
end
Another way to save strings is the notation [=[...]=] for long strings. However, this notation is mainly intended for hand-written code, where we do not want to change a literal string in any way. 
In automatically generated code, it is easier to escape problematic characters, as the option "%q" from string.format does.
If you nevertheless want to use the long-string notation for automatically generated code, you must take care of some details. 
The first one is that you must choose a proper number of equals signs. A good proper number is one more than the maximum that appears in the original string. 
Because strings containing long sequences of equals signs are common (e.g., comments delimiting parts of a source code), 
we should limit our attention to sequences of equals signs enclosed by square bracket. The second detail is that Lua always ignores a newline at the beginning of a long string; 
a simple way to avoid this problem is to add always a newline to be ignored.

function quote (s)
    -- find maximum length of sequences of equals signs
    local n = -1
    for w in string.gmatch(s, "]=*%f[%]]") do
　n = math.max(n, #w - 1)	-- -1 to remove the ']' end

    -- produce a string with 'n' plus one equals signs
    local eq = string.rep("=", n + 1)

    -- build quoted string
　return string.format(" [%s[\n%s]%s] ", eq, s, eq)
end

It takes an arbitrary string and returns it formatted as a long string. The call to gmatch creates an iterator to traverse all occurrences of the pattern ']=*%f[%]]' 
(that is, a closing square bracket followed by a sequence of zero or more equals signs followed by a frontier with a closing square bracket) in the string s. 
For each occurrence, the loop updates n with the maximum number of equals signs so far. After the loop, we use string.rep to replicate an equals sign n + 1 times, 
which is one more than the maximum occurring in the string. Finally, string.format encloses s with pairs of brackets with the correct number of equals signs in between and adds extra spaces around the quoted string plus a newline at the beginning of the enclosed string.

(We might be tempted to use the simpler pattern ']=*]', which does not use a frontier pattern for the second square bracket, but there is a subtlety here. 
Suppose the subject is "]=]==]". The first match is "]=]". After it, what is left in the string is "==]", and so there is no other match; 
in the end of the loop, n would be one instead of two. The frontier pattern does not consume the bracket, so that it remains in the subject for the following matches.)

Saving tables without cycles
Our next (and harder) task is to save tables. There are several ways to save them, according to what assumptions we make about the table structure. 
No single algorithm seems appropriate for all cases. Simple tables not only can use simpler algorithms, but also the output can be shorter and clearer.
Our first attempt is in Figure 15.2, “Serializing tables without cycles”.

Figure 15.2. Serializing tables without cycles
function serialize (o)
    local t = type(o)
    if t == "number" or t == "string" or t == "boolean" or t == "nil" then
　    io.write(string.format("%q", o))
    elseif t == "table" then
        io.write("{\n")
        for k,v in pairs(o) do
            io.write("    ", k, " = ")
            serialize(v)
            io.write(",\n")
        end
        io.write("}\n")
    else
　    error("cannot serialize a " .. type(o))
    end
end
Despite its simplicity, that function does a reasonable job. It even handles nested tables (that is, tables within other tables), as long as the table structure is a tree —that is, 
there are no shared subtables and no cycles. (A small aesthetic improvement would be to indent nested tables; see Exercise 15.1.)
The previous function assumes that all keys in a table are valid identifiers. If a table has numeric keys, or string keys that are not syntactic valid Lua identifiers, we are in trouble. 
A simple way to solve this difficulty is to use the following code to write each key:

io.write(string.format(" [%s] = ", serialize(k)))
With this change, we improve the robustness of our function, at the cost of the aesthetics of the resulting file. Consider the next call:

serialize{a=12, b='Lua', key='another "one"'}

The result of this call using the first version of serialize is this:

{
    a = 12,
    b = "Lua",
    key = "another \"one\"",
}

Compare it with the result using the second version:

{
    ["a"] = 12,
    ["b"] = "Lua",
    ["key"] = "another \"one\"",
}

We can have both robustness and aesthetics by testing for each case whether it needs the square brackets; again, we will leave this improvement as an exercise.

Saving tables with cycles
To handle tables with generic topology (i.e., with cycles and shared subtables) we need a different approach. Constructors cannot create such tables, so we will not use them. 
To represent cycles we need names, so our next function will get as arguments the value to be saved plus its name. Moreover, we must keep track of the names of the tables already saved, 
to reuse them when we detect a cycle. We will use an extra table for this tracking. This table will have previously saved tables as indices and their names  as the associated values.

function basicSerialize(o)
    -- assume 'o' is a number or a string
    return string.format("%q", o)
end

function save(name, value, saved)
    saved = saved or {}	-- initial value
    io.write(name, " = ")
    if type(value) == "number" or type(value) == "string" then
        io.write(basicSerialize(value), "\n")
    elseif type(value) == "table" then
        if saved[value] then	-- value already saved?
            io.write(saved[value], "\n")	-- use its previous name
        else
            saved[value] = name	-- save name for next time
            io.write("{}\n")	-- create a new table
            for k,v in pairs(value) do	-- save its fields
                k = basicSerialize(k)
                local fname = string.format("%s[%s]", name, k)
                save(fname, v, saved)
            end
        end
    else
　    error("cannot save a " .. type(value))
    end
end
We keep the restriction that the tables we want to save have only strings and numbers as keys. The function basicSerialize serializes these basic types, returning the result. 
The next function, save, does the hard work. The saved parameter is the table that keeps track of tables already saved. As an example, suppose we build a table like this:
a = {x=1, y=2; {3,4,5}}
a[2] = a	-- cycle
a.z = a[1]	-- shared subtable
The call save("a", a) will save it as follows:
a = {}
a[1] = {}
a[1][1] = 3
a[1][2] = 4
a[1][3] = 5
a[2] = a
a["y"] = 2
a["x"] = 1
a["z"] = a[1]
The actual order of these assignments may vary, as it depends on a table traversal. Nevertheless, the algorithm ensures that any node needed in a new definition is already defined.
If we want to save several values with shared parts, we can make the calls to save them using the same saved table. 
For instance, assume the following two tables:

a = {{"one", "two"}, 3}
b = {k = a[1]}
If we save them independently, the result will not have common parts. However, if we use the same saved table for both calls to save, then the result will share common parts:
local t = {}
save("a", a, t)
save("b", b, t)

--> a = {}
--> a[1] = {}
--> a[1][1] = "one"
--> a[1][2] = "two"
--> a[2] = 3
--> b = {}
--> b["k"] = a[1]
As is usual in Lua, there are several other alternatives. Among them, we can save a value without giving it a global name (instead, the chunk builds a local value and returns it), 
we can use the list syntax when possible (see the exercises for this chapter), and so on. Lua gives you the tools; you build the mechanisms.

Chapter 16. Compilation, Execution, and Errors

Compilation
Previously, we introduced dofile as a kind of primitive operation to run chunks of Lua code, but dofile is actually an auxiliary function: the function loadfile does the hard work. 
Like dofile, loadfile loads a Lua chunk from a file, but it does not run the chunk. Instead, it only compiles the chunk and returns the compiled chunk as a function. 
Moreover, unlike dofile, loadfile does not raise errors, but instead returns error codes. We could define dofile as follows:

function dofile (filename)
    local f = assert(loadfile(filename))
    return f()
end

Note the use of assert to raise an error if loadfile fails.

For simple tasks, dofile is handy, because it does the complete job in one call. However, loadfile is more flexible. 
In case of error, loadfile returns nil plus the error message, which allows us to handle the error in customized ways. 
Moreover, if we need to run a file several times, we can call loadfile once and call its result several times. 
This approach is much cheaper than several calls to dofile, because it compiles the file only once. 
(Compilation is a somewhat expensive operation when compared to other tasks in the language.)

The function load is similar to loadfile, except that it reads its chunk from a string or from a function, not from a file. For instance, consider the next line:

f = load("i = i + 1")

After this code, f will be a function that executes i = i + 1 when invoked:

i = 0
f();
print(i)	--> 1
f();
print(i)	--> 2

The function load is powerful; we should use it with care. It is also an expensive function (when compared to some alternatives) and can result in incomprehensible code. 
Before you use it, make sure that there is no simpler way to solve the problem at hand.

If we want to do a quick-and-dirty dostring (i.e., to load and run a chunk), we can call the result from load directly:
load(s)()
However, if there is any syntax error, load will return nil and the final error message will be something like “attempt to call a nil value”. 
For clearer error messages, it is better to use assert:
assert(load(s))()
Usually, it does not make sense to use load on a literal string. For instance, the next two lines are roughly equivalent:

f = load("i = i + 1")

f = function () i = i + 1 end
However, the second line is much faster, because Lua compiles the function together with its enclosing chunk. In the first line, the call to load involves a separate compilation.
Because load does not compile with lexical scoping, the two lines in the previous example may not be truly equivalent. To see the difference, let us change the example a little:

i = 32
local i = 0
f = load("i = i + 1; print(i)")
g = function () i = i + 1; print(i) end
f()	--> 33
g()	--> 1
The function g manipulates the local i, as expected, but f manipulates a global i, because load always compiles its chunks in the global environment.

The most typical use of load is to run external code (that is, pieces of code that come from outside our program) or dynamically-generated code. 
For instance, we may want to plot a function defined by the user; the user enters the function code and then we use load to evaluate it. 
Note that load expects a chunk, that is, statements. If we want to evaluate an expression, we can prefix the expression with return, 
so that we get a statement that returns the value of the given expression. See the example:

print "enter your expression:"
local line = io.read()
local func = assert(load("return " .. line))
print("the value of your expression is " .. func())
Because the function returned by load is a regular function, we can call it several times:
print "enter function to be plotted (with variable 'x'):"
local line = io.read()
local f = assert(load("return " .. line))
for i = 1, 20 do
    x = i	-- global 'x' (to be visible from the chunk)
    print(string.rep("*", f()))
end
We can call load also with a reader function as its first argument. A reader function can return the chunk in parts; load calls the reader successively until it returns nil, 
which signals the chunk's end. As an example, the next call is equivalent to loadfile:

f = load(io.lines(filename, "*L"))
As we saw in Chapter 7, The External World, the call io.lines(filename, "*L") returns a function that, at each call, returns a new line from the given file. 
So, load will read the chunk from the file line by line. The following version is similar, but slightly more efficient:

f = load(io.lines(filename, 1024))
Here, the iterator returned by io.lines reads the file in blocks of 1024 bytes.
Lua treats any independent chunk as the body of an anonymous variadic function. 
For instance, load("a = 1") returns the equivalent of the following expression:
function (...) a = 1 end
Like any other function, chunks can declare local variables:

f = load("local a = 10; print(a + 20)")
f()	--> 30
Using these features, we can rewrite our plot example to avoid the use of a global variable x:
print "enter function to be plotted (with variable 'x'):"
local line = io.read()
local f = assert(load("local x = ...; return " .. line))
for i = 1, 20 do
    print(string.rep("*", f(i)))
end
In this code, we append the declaration "local x = ..." at the beginning of the chunk to declare x as a local variable. 
We then call f with an argument i that becomes the value of the vararg expression (...).
The functions load and loadfile never raise errors. In case of any kind of error, they return nil plus an error message:

print(load("i i")) --> nil	[string "i i"]:1: '=' expected near 'i'
Moreover, these functions never have any kind of side effect, that is, they do not change or create variables, do not write to files, etc. 
They only compile the chunk to an internal representation and return the result as an anonymous function. A common mistake is to assume that loading a chunk defines functions. 
In Lua, function definitions are assignments; as such, they happen at runtime, not at compile time. For instance, suppose we have a file foo.lua like this:
-- file 'foo.lua'
function foo(x)
    print(x)
end
We then run the command

f = loadfile("foo.lua")
This command compiles foo but does not define it. To define it, we must run the chunk:
f = loadfile("foo.lua")
print(foo)	--> nil
f()	-- run the chunk
foo("ok")	--> ok


This behavior may sound strange, but it becomes clear if we rewrite the file without the syntax sugar:

-- file 'foo.lua'
foo = function (x)
    print(x)
end
In a production-quality program that needs to run external code, we should handle any errors reported when loading a chunk. 
Moreover, we may want to run the new chunk in a protected environment, to avoid unpleasant side effects. We will discuss environments in detail in Chapter 22, The Environment.
Precompiled Code
As I mentioned in the beginning of this chapter, Lua precompiles source code before running it. Lua also allows us to distribute code in precompiled form.
The simplest way to produce a precompiled file —also called a binary chunk in Lua jargon— is with   the luac program that comes in the standard distribution. 
For instance, the next call creates a new file prog.lc with a precompiled version of a file prog.lua:
$ luac -o prog.lc prog.lua
The Lua interpreter can execute this new file just like normal Lua code, performing exactly as it would with the original source:
$ lua prog.lc
Lua accepts precompiled code mostly anywhere it accepts source code. In particular, both loadfile and load accept precompiled code.
We can write a minimal luac directly in Lua:
p = loadfile(arg[1])
f = io.open(arg[2], "wb")
f:write(string.dump(p))
f:close()
The key function here is string.dump: it receives a Lua function and returns its precompiled code as a string, properly formatted to be loaded back by Lua.
The luac program offers some other interesting options. In particular, option -l lists the opcodes that the compiler generates for a given chunk. 

Code in precompiled form is not always smaller than the original, but it loads faster. Another benefit is that it gives a protection against accidental changes in sources. 
Unlike source code, however, maliciously corrupted binary code can crash the Lua interpreter or even execute user-provided machine code. 
When running usual code, there is nothing to worry about. However, you should avoid running untrusted code in precompiled form. 
The function load has an option exactly for this task.

Besides its required first argument, load has three more arguments, all of them optional. The second is a name for the chunk, used only in error messages. 
The fourth argument is an environment, which we will discuss in Chapter 22, The Environment. The third argument is the one we are interested here; 
it controls what kinds of chunks can be loaded. If present, this argument must be a string: the string "t" allows only textual (normal) chunks; 
"b" allows only binary (precompiled) chunks; "bt", the default, allows both formats.

Errors

Any unexpected condition that Lua encounters raises an error. Errors occur when a program tries to add values that are not numbers, 
call values that are not functions, index values that are not tables, and so on. (We can modify this behavior using metatables, as we will see later.) 
We can also explicitly raise an error calling the function error, with an error message as an argument. Usually, this function is the appropriate way to signal errors in our code:

print "enter a number:"
n = io.read("n")
if not n then
    error("invalid input")
end

This construction of calling error subject to some condition is so common that Lua has a built-in function just for this job, called assert:

print "enter a number:"
n = assert(io.read("*n"), "invalid input")

The function assert checks whether its first argument is not false and simply returns this argument;  if the argument is false, assert raises an error. 
Its second argument, the message, is optional. Beware, however, that assert is a regular function. As such, Lua always evaluates its arguments before calling the function. 
If we write something like

n = io.read()
assert(tonumber(n), "invalid input: " .. n .. " is not a number")

Lua will always do the concatenation, even when n is a number. It may be wiser to use an explicit test in such cases.

When a function finds an unexpected situation (an exception), it can assume two basic behaviors: 
it can return an error code (typically nil or false) or it can raise an error, calling error. There are no fixed rules for choosing between these two options, 
but I use the following guideline: an exception that is easily avoided should raise an error; otherwise, it should return an error code.

For instance, let us consider math.sin. How should it behave when called on a table? Suppose it returns an error code. 
If we need to check for errors, we would have to write something like this:

local res = math.sin(x)
if not res then	-- error?
    error-handling code
end
However, we could as easily check this exception before calling the function:

if not tonumber(x) then	-- x is not a number?
    error-handling code
end
Frequently we check neither the argument nor the result of a call to sin; if the argument is not a number, it means that probably there is something wrong in our program. 
In such situations, the simplest and most practical way to handle the exception is to stop the computation and issue an error message.

On the other hand, let us consider io.open, which opens a file. How should it behave when asked to open a file that does not exist? 
In this case, there is no simple way to check for the exception before calling the function. In many systems, the only way of knowing whether a file exists is by trying to open it. 
Therefore, if io.open cannot open a file because of an external reason (such as “file does not exist” or “permission denied”), it returns false, plus a string with the error message. 
In this way, we have a chance to handle the situation in an appropriate way, for instance by asking the user for another file name:

local file, msg
repeat
    print "enter a file name:"
    local name = io.read()
    if not name then
        return
    end
    file, msg = io.open(name, "r")
　if not file then
        print(msg)
    end
until file
If we do not want to handle such situations, but still want to play safe, we simply use assert to guard the operation:

file = assert(io.open(name, "r"))
--> stdin:1: no-file: No such file or directory

This is a typical Lua idiom: if io.open fails, assert will raise an error. Notice how the error message, which is the second result from io.open, goes as the second argument to assert.
Error Handling and Exceptions
For many applications, we do not need to do any error handling in Lua; the application program does this handling. 
All Lua activities start from a call by the application, usually asking Lua to run a chunk. If there is any error, this call returns an error code, so that the application can take appropriate actions. 
In the case of the stand-alone interpreter, its main loop just prints the error message and continues showing the prompt and running the given commands.

However, if we want to handle errors inside the Lua code, we should use the function pcall (protected call) to encapsulate our code.

Suppose we want to run a piece of Lua code and to catch any error raised while running that code. Our first step is to encapsulate that piece of code in a function; 
more often than not, we use an anonymous function for that. Then, we call that function through pcall:


local ok, msg = pcall(function ()
    some code
    if unexpected_condition then
        error()
    end
    some code
    print(a[i])	-- potential error: 'a' may not be a table
    some code
    end)

if ok then	-- no errors while running protected code
    regular code
else	-- protected code raised an error: take appropriate action
    error-handling code
end

The function pcall calls its first argument in protected mode, so that it catches any errors while the function is running. 
The function pcall never raises any error, no matter what. If there are no errors, pcall returns true, plus any values returned by the call. 
Otherwise, it returns false, plus the error message.

Despite its name, the error message does not have to be a string; a better name is error object, because pcall will return any Lua value that we pass to error:

local status, err = pcall(function () error({code=121}) end)
print(err.code)	--> 121

These mechanisms provide all we need to do exception handling in Lua. We throw an exception with error and catch it with pcall. The error message identifies the kind of error.

Error Messages and Tracebacks
Although we can use a value of any type as an error object, usually error objects are strings describing what went wrong. 
When there is an internal error (such as an attempt to index a non-table value), Lua generates the error object, which in that case is always a string; 
otherwise, the error object is the value passed to the function error. Whenever the object is a string, Lua tries to add some information about the location where the error happened:

local status, err = pcall(function () error("my error") end)
print(err)	--> stdin:1: my error

The location information gives the chunk's name (stdin, in the example) plus the line number (1, in the example).

The function error has an additional second parameter, which gives the level where it should report the error. 
We use this parameter to blame someone else for the error. For instance, suppose we write a function whose first task is to check whether it was called correctly:

function foo(str)
    if type(str) ~= "string" then
        error("string expected")
    end
    regular code
end

Then, someone calls this function with a wrong argument:

foo({x=1})

As it is, Lua points its finger to foo —after all, it was it who called error— and not to the real culprit, the caller. 
To correct this problem, we inform error that the error it is reporting occurred on level two in the calling hierarchy (level one is our own function):

function foo (str)
    if type(str) ~= "string" then
        error("string expected", 2)
    end
    regular code
end

Frequently, when an error happens, we want more debug information than only the location where the error occurred. 
At least, we want a traceback, showing the complete stack of calls leading to the error. When pcall returns its error message, it destroys part of the stack (the part that goes from it to the error point). 
Consequently, if we want a traceback, we must build it before pcall returns. To do this, Lua provides the function xpcall. It works like pcall, but its second argument is a message handler function. 
In case of error, Lua calls this message handler before the stack unwinds, so that it can use the debug library to gather any extra information it wants about the error. 
Two common message handlers are debug.debug, which gives us a Lua prompt so that we can inspect by ourselves what was going on when the error happened; 
and debug.traceback, which builds an extended error message with a traceback. The latter is the function that the stand-alone interpreter uses to build its error messages.

Chapter 17. Modules and Packages
Starting in version 5.1, Lua has defined a set of policies for modules and packages (a package being a collection of modules). 
These policies do not demand any extra facility from the language; programmers can implement them using what we have seen so far. 
Programmers are free to use different policies. Of course, alternative implementations may lead to programs that cannot use foreign modules and modules that cannot be used by foreign programs.
From the point of view of the user, a module is some code (either in Lua or in C) that can be loaded through the function require and that creates and returns a table. 
Everything that the module exports, such as functions and constants, it defines inside this table, which works as a kind of namespace.
As an example, all standard libraries are modules. We can use the mathematical library like this:

local m = require "math"
print(m.sin(3.14))	--> 0.0015926529164868
However, the stand-alone interpreter preloads all standard libraries with code equivalent to this:

math = require "math"
string = require "string"
...
This preloading allows us to write the usual notation math.sin, without bothering to require the module math.
An obvious benefit of using tables to implement modules is that we can manipulate modules like any other table and use the whole power of Lua to create extra facilities. 
In most languages, modules are not first-class values (that is, they cannot be stored in variables, passed as arguments to functions, etc.); 
those languages need special mechanisms for each extra facility they want to offer for modules. In Lua, we get extra facilities for free.
For instance, there are several ways for a user to call a function from a module. The usual way is this:

local mod = require "mod"
mod.foo()
The user can set any local name for the module:

local m = require "mod"
m.foo()
She can also provide alternative names for individual functions:

local m = require "mod"
local f = m.foo
f()
She can also import only a specific function:

local f = require "mod".foo	-- (require("mod")).foo
f()
The nice thing about these facilities is that they involve no special support from Lua. They use what the language already offers.
The Function require
Despite its central role in the implementation of modules in Lua, require is a regular function, with no special privileges. 
To load a module, we simply call it with a single argument, the module name. Remember that, when the single argument to a function is a literal string, 
the parentheses are optional, and it is customary to omit them in regular uses of require. Nevertheless, the following uses are all correct, too:

local m = require('math')

local modname = 'math'
local m = require(modname)
The function require tries to keep to a minimum its assumptions about what a module is. For it, a module is just any code that defines some values, 
such as functions or tables containing functions. Typically, that code returns a table comprising the module functions. 
However, because this action is done by the module code, not by require, some modules may choose to return other values or even to have side effects (e.g., by creating global variables).

The first step of require is to check in the table package.loaded whether the module is already loaded. If so, require returns its corresponding value. 
Therefore, once a module is loaded, other calls requiring the same module simply return the same value, without running any code again.

If the module is not loaded yet, require searches for a Lua file with the module name. (This search  is guided by the variable package.path, which we will discuss later.) 
If it finds such a file, it loads   it with loadfile. The result is a function that we call a loader. (The loader is a function that, when called, loads the module.)

If require cannot find a Lua file with the module name, it searches for a C library with that name. (In that case, the search is guided by the variable package.cpath.) 
If it finds a C library, it loads it with the low-level function package.loadlib, looking for a function called luaopen_modname. 
The loader in this case is the result of loadlib, which is the C function luaopen_modname represented as a Lua function.

No matter whether the module was found in a Lua file or a C library, require now has a loader for  it. To finally load the module, require calls the loader with two arguments: 
the module name and  the name of the file where it got the loader. (Most modules just ignore these arguments.) 
If the loader returns any value, require returns this value and stores it in the package.loaded table, to return the same value in future calls for this same module. 
If the loader returns no value, and the table entry package.loaded[@rep{modname}] is still empty, require behaves as if the module returned true. 
Without this correction, a subsequent call to require would run the module again.
To force require into loading the same module twice, we can erase the library entry from package.loaded:

package.loaded.modname = nil
The next time the module is required, require will do all its work again.

A common complaint against require is that it cannot pass arguments to the module being loaded. 
For instance, the mathematical module might have an option for choosing between degrees and radians:

-- bad code
local math = require("math", "degree")
The problem here is that one of the main goals of require is to avoid loading a module multiple times. 
Once a module is loaded, it will be reused by whatever part of the program that requires it again. 
There would be a conflict if the same module were required with different parameters. 
In case you really want your module to have parameters, it is better to create an explicit function to set them, like here:

local mod = require "mod"
mod.init(0, 0)
If the initialization function returns the module itself, we can write that code like this:

local mod = require "mod".init(0, 0)
In any case, remember that the module itself is loaded only once; it is up to it to handle conflicting initializations.
Renaming a module
Usually, we use modules with their original names, but sometimes we must rename a module to avoid name clashes. 
A typical situation is when we need to load different versions of the same module, for instance for testing. Lua modules do not have their names fixed internally, 
so usually it is enough to rename the .lua file. However, we cannot edit the object code of a C library to correct the name of   its luaopen_* function. 
To allow for such renamings, require uses a small trick: if the module name contains a hyphen, require strips from the name its suffix after the hyphen when creating the luaopen_* function name. 
For instance, if a module is named mod-v3.4, require expects its open function to be named luaopen_mod, instead of luaopen_mod-v3.4 (which would not be a valid C name anyway). 
So, if we need to use two modules (or two versions of the same module) named mod, we can rename one of them to mod-v1, for instance. 
When we call m1 = require "mod-v1", require will find the renamed file mod-v1 and, inside this file, the function with the original name luaopen_mod.
Path searching
When searching for a Lua file, the path that guides require is a little different from typical paths. A typical path is a list of directories wherein to search for a given file. 
However, ISO C (the abstract platform where Lua runs) does not have the concept of directories. Therefore, the path used by require is a list of templates, 
each of them specifying an alternative way to transform a module name (the argument to require) into a file name. 
More specifically, each template in the path is a file name containing optional question marks. 
For each template, require substitutes the module name for each question mark and checks whether there is a file with the resulting name; 
if not, it goes to the next template. The templates in a path are separated by semicolons, a character seldom used for file names in most operating systems. 
For instance, consider the following path:

?;?.lua;c:\windows\?;/usr/local/lua/?/?.lua
With this path, the call require "sql" will try to open the following Lua files:
sql
sql.lua
c:\windows\sql
/usr/local/lua/sql/sql.lua

The function require assumes only the semicolon (as the component separator) and the question mark; 
everything else, including directory separators and file extensions, is defined by the path itself.
The path that require uses to search for Lua files is always the current value of the variable package.path. 
When the module package is initialized, it sets this variable with the value of the environment variable LUA_PATH_5_3; 
if this environment variable is undefined, Lua tries the environment variable LUA_PATH. If both are unefined, Lua uses a compiled-defined default path. 
When using the value of an environment variable, Lua substitutes the default path for any substring ";;". 
For instance, if we set LUA_PATH_5_3 to "mydir/?.lua;;", the final path will be the template "mydir/?.lua" followed by the default path.
The path used to search for a C library works exactly in the same way, but its value comes from the variable package.cpath, instead of package.path. 
Similarly, this variable gets its initial value from the environment variables LUA_CPATH_5_3 or LUA_CPATH. A typical value for this path in POSIX is like this:
./?.so;/usr/local/lib/lua/5.2/?.so
Note that the path defines the file extension. The previous example uses .so for all templates; in Windows, a typical path would be more like this one:

.\?.dll;C:\Program Files\Lua502\dll\?.dll
The function package.searchpath encodes all those rules for searching libraries. It takes a module name and a path, and looks for a file following the rules described here. 
It returns either the name of the first file that exists or nil plus an error message describing all files it unsuccessfully tried to open, as in the next example:
> path = ".\\?.dll;C:\\Program Files\\Lua502\\dll\\?.dll"
> print(package.searchpath("X", path))
nil
	no file '.\X.dll'
	no file 'C:\Program Files\Lua502\dll\X.dll'

function search(modname, path)
    modname = string.gsub(modname, "%.", "/")
    local msg = {}
    for c in string.gmatch(path, "[^;]+") do
        local fname = string.gsub(c, "?", modname)
        local f = io.open(fname)
        if f then
            f:close()
            return fname
        else
            msg[#msg + 1] = string.format("\n\tno file '%s'", fname);
        end
    end
　return nil, table.concat(msg)	-- not found
end

The first step is to substitute the directory separator, assumed to be a slash in this example, for any dots. (As we will see later, a dot has a special meaning in a module name.) 
Then the function loops over all components of the path, wherein each component is a maximum expansion of non-semicolon characters. 
For each component, the function substitutes the module name for the question marks to get the final file name, and then it checks whether there is such a file. 
If so, the function closes the file and returns its name. Otherwise, it stores the failed name for a possible error message. 
(Note the use of a string buffer to avoid creating useless long strings.) If no file is found, then it returns nil plus the final error message.

Searchers
In reality, require is a little more complex than we have described. The search for a Lua file and the search for a C library are just two instances of a more general concept of searchers. 
A searcher is simply a function that takes the module name and returns either a loader for that module or nil if it cannot find one.

The array package.searchers lists the searchers that require uses. When looking for a module, require calls each searcher in the list passing the module name, until one of them finds a loader for the module. 
If the list ends without a positive response, require raises an error.

The use of a list to drive the search for a module allows great flexibility to require. For instance, if we want to store modules compressed in zip files, we only need to provide a proper searcher function for that and add it to the list. 
In its default configuration, the searcher for Lua files and the searcher for C libraries that we described earlier are respectively the second and the third elements in the list. 
Before them, there is the preload searcher.

The preload searcher allows the definition of an arbitrary function to load a module. It uses a table, called package.preload, to map module names to loader functions. 
When searching for a module name, this searcher simply looks for the given name in the table. If it finds a function there, it returns this function as the module loader. 
Otherwise, it returns nil. This searcher provides a generic method to handle some non-conventional situations. 
For instance, a C library statically linked to Lua can register its luaopen_ function into the preload table, so that it will be called only when (and if) the user requires that module. 
In this way, the program does not waste resources opening the module if it is not used.

The default content of package.searchers includes a fourth function that is relevant only for submodules. We will discuss it at the section called “Submodules and Packages”.

The Basic Approach for Writing Modules in Lua
The simplest way to create a module in Lua is really simple: we create a table, put all functions we want to export inside it, and return this table. 

local M = {}	-- the module

-- creates a new complex number
local function new(r, i)
    return {r=r, i=i}
end

M.new = new	-- add 'new' to the module

-- constant 'i'
M.i = new(0, 1)

function M.add (c1, c2)
    return new(c1.r + c2.r, c1.i + c2.i)
end

function M.sub (c1, c2)
    return new(c1.r - c2.r, c1.i - c2.i)
end

function M.mul (c1, c2)
    return new(c1.r*c2.r - c1.i*c2.i, c1.r*c2.i + c1.i*c2.r)
end

local function inv(c)
    local n = c.r^2 + c.i^2
    return new(c.r/n, -c.i/n)
end

function M.div (c1, c2)
    return M.mul(c1, inv(c2))
end

function M.tostring(c)
    return string.format("(%g,%g)", c.r, c.i)
end

return M
Note how we define new and inv as private functions simply by declaring them local to the chunk.
Some people do not like the final return statement. One way of eliminating it is to assign the module table directly into package.loaded:
local M = {}
package.loaded[...] = M
as before, without the return statement
Remember that require calls the loader passing the module name as the first argument. So, the vararg expression ... in the table index results in that name. 
After this assignment, we do not need to return M at the end of the module: if a module does not return a value, require will return the current value of package.loaded[modname] (if it is not nil). 
Anyway, I find it clearer to write the final return. If we forget it, any trivial test with the module will detect the error.

Another approach to write a module is to define all functions as locals and build the returning table at the end.

local function new(r, i)
    return {r=r, i=i}
end

-- defines constant 'i'
local i = complex.new(0, 1)

other functions follow the same pattern

return {
new	= new,
i	= i,
add	= add,
sub	= sub,
mul	= mul,
div	= div, 
tostring = tostring,
}

What are the advantages of this approach? We do not need to prefix each name with M. or something similar; there is an explicit export list; 
and we define and use exported and internal functions in the same way inside the module. What are the disadvantages? 
The export list is at the end of the module instead of at the beginning, where it would be more useful as a quick documentation; 
and the export list is somewhat redundant, as we must write each name twice. (This last disadvantage may become an advantage, as it allows functions to have different names inside and outside the module, but I think programmers seldom do this.)

Anyway, remember that no matter how we define a module, users should be able to use it in a standard way:

local cpx = require "complex"
print(cpx.tostring(cpx.add(cpx.new(3,4), cpx.i))) --> (3,5)

Later, we will see how we can use some advanced Lua features, such as metatables and environments, for writing modules. 
However, except for a nice technique to detect global variables created by mistake, I use only the basic approach in my modules.

Submodules and Packages
Lua allows module names to be hierarchical, using a dot to separate name levels. For instance, a module named mod.sub is a submodule of mod. 
A package is a complete tree of modules; it is the unit of distribution in Lua.

When  we  require  a  module  called  mod.sub,  the  function  require will  query  first  the  table package.loaded and then the table package.preload, 
using the original module name "mod.sub" as the key. Here, the dot is just a character like any other in the module name.
However, when searching for a file that defines that submodule, require translates the dot into another character, 
usually the system's directory separator (e.g., a slash for POSIX or a backslash for Windows). After the translation, require searches for the resulting name like any other name. 
For instance, assume the slash as the directory separator and the following path:

./?.lua;/usr/local/lua/?.lua;/usr/local/lua/?/init.lua
The call require "a.b" will try to open the following files:
./a/b.lua
/usr/local/lua/a/b.lua
/usr/local/lua/a/b/init.lua
This behavior allows all modules of a package to live in a single directory. For instance, if a package has modules p, p.a, and p.b, their respective files can be p/init.lua, p/a.lua, and p/b.lua, with the directory p within some appropriate directory.
The directory separator used by Lua is configured at compile time and can be any string (remember,  Lua knows nothing about directories). For instance, systems without hierarchical directories can use an underscore as the “directory separator”, 
so that require "a.b" will search for a file a_b.lua.
Names in C cannot contain dots, so a C library for submodule a.b cannot export a function luaopen_a.b. Here, require translates the dot into another character, an underscore. 
So, a C library named a.b should name its initialization function luaopen_a_b.
As an extra facility, require has one more searcher for loading C submodules. When it cannot find either a Lua file or a C file for a submodule, this last searcher searches again the C path, but this time looking for the package name. 
For example, if the program requires a submodule a.b.c this searcher will look for a. If it finds a C library for this name, then require looks into this library for an appropriate open function, luaopen_a_b_c in this example. 
This facility allows a distribution to put several submodules together, each with its own open function, into a single C library.

From the point of view of Lua, submodules in the same package have no explicit relationship. Requiring a module does not automatically load any of its submodules; 
similarly, requiring a submodule does not automatically load its parent. Of course, the package implementer is free to create these links if she wants. 
For instance, a particular module may start by explicitly requiring one or all of its submodules.

Chapter 18. Iterators and the Generic for
We have been using the generic for for several tasks through the book, such as reading the lines of a file or traversing the matches of a pattern over a subject. 
However, we still do not know how to create our own iterators. In this chapter, we will fill this gap. 
Starting with simple iterators, we will learn how to use all the power of the generic for to write all kinds of iterators.

Iterators and Closures
An iterator is any construction that allows us to iterate over the elements of a collection. In Lua, we typically represent iterators by functions: 
each time we call the function, it returns the “next” element from the collection. A typical example is io.read: each time we call it, it returns the next line of the standard input file, 
returning nil when there are no more lines to be read.

Any iterator needs to keep some state between successive calls, so that it knows where it is and how to proceed from there. 
For io.read, C keeps that state in its stream structure. For our own iterators, closures provide an excellent mechanism for keeping state. 
Remember that a closure is a function that accesses one or more local variables from its enclosing environment. 
These variables keep their values across successive calls to the closure, allowing the closure to remember where it is along a traversal. 
Of course, to create a new closure we must also create its non-local variables. Therefore, a closure construction typically involves two functions: 
the closure itself and a factory, the function that creates the closure plus its enclosing variables.

As an example, let us write a simple iterator for a list. Unlike ipairs, this iterator does not return the index of each element, only its value:

function values(t)
    local i = 0
    return function () i = i + 1; return t[i] end
end

In this example, values is the factory. Each time we call this factory, it creates a new closure (the iterator itself). 
This closure keeps its state in its external variables t and i, which are also created by values. Each time we call the iterator, it returns a next value from the list t. 
After the last element the iterator returns nil, which signals the end of the iteration.

We can use this iterator in a while loop:

t = {10, 20, 30}
iter = values(t)	-- creates the iterator
while true do
    local element = iter()	-- calls the iterator
    if element == nil then
        break
    end
    print(element)
end

However, it is easier to use the generic for. After all, it was designed for this kind of iteration:

t = {10, 20, 30}
for element in values(t) do
　print(element)
end
The generic for does all the bookkeeping for an iteration loop: it keeps the iterator function internally, so that we do not need the iter variable; 
it calls the iterator for each new iteration; and it stops the loop when the iterator returns nil. (In the next section, we will see that the generic for does even more than that.)

As a more advanced example, Figure 18.1, “Iterator to traverse all words from the standard input” shows an iterator to traverse all the words from the standard input.

Figure 18.1. Iterator to traverse all words from the standard input

function allwords ()
    local line = io.read()	-- current line
    local pos = 1	-- current position in the line
    return function ()	-- iterator function
        while line do	-- repeat while there are lines
            local w, e = string.match(line, "(%w+)()", pos)
            if w then	-- found a word?
                pos = e	-- next position is after this word
　            return w	-- return the word
            else
                line = io.read()	-- word not found; try next line
                pos = 1	-- restart from first position
　        end
        end
　    return nil	-- no more lines: end of traversal
    end
end
To do this traversal, we keep two values: the contents of the current line (variable line), and where we are on this line (variable pos). 
With this data, we can always generate the next word. The main part of the iterator function is the call to string.match, 
which searches for a word in the current line starting at the current position. It describes a “word” using the pattern '%w+', which matches one or more alphanumeric characters. 
If it finds a word, it captures and returns the word and the position of the first character after it (with an empty capture). 
The function then updates the current position and returns this word. Otherwise, the iterator reads a new line and repeats the search. 
If there are no more lines, it returns nil to signal the end of the iteration.

Despite its complexity, the use of allwords is straightforward:

for word in allwords() do
    print(word)
end

This is a common situation with iterators: they may not be easy to write, but they are easy to use. This   is not a big problem; more often than not, end users programming in Lua do not define iterators, but just use those provided by the application.

The Semantics of the Generic for
One drawback of those previous iterators is that we need to create a new closure to initialize each new loop. For many situations, this is not a real problem. 
For instance, in the allwords iterator, the cost of creating one single closure is negligible compared to the cost of reading a whole file. 
However, in some situations this overhead can be inconvenient. In such cases, we can use the generic for itself to keep the iteration state. 
In this section, we will see the facilities that the generic for offers to hold state.

We saw that the generic for keeps the iterator function internally, during the loop. Actually, it keeps three values: the iterator function, an invariant state, and a control variable. 
Let us see the details now.

The syntax for the generic for is as follows:

for var-list in exp-list do
    body
end

Here, var-list is a list of one or more variable names, separated by commas, and exp-list is a list of one or more expressions, also separated by commas. 
Usually the expression list has only one element, a call to an iterator factory. In the next code, for instance, the list of variables is k,v and the list of expressions has the single element pairs(t):

for k, v in pairs(t) do
    print(k, v)
end

We call the first (or only) variable in the list the control variable. Its value is never nil during the loop, because when it becomes nil the loop ends.

The first thing the for does is to evaluate the expressions after the in. These expressions should result in the three values kept by the for: 
the iterator function, the invariant state, and the initial value for the control variable. Like in a multiple assignment, 
only the last (or the only) element of the list can result in more than one value; and the number of values is adjusted to three, extra values being discarded or nils added as needed. 
For instance, when we use simple iterators, the factory returns only the iterator function, so the invariant state and the control variable get nil.

After this initialization step, the for calls the iterator function with two arguments: the invariant state and the control variable. 
From the standpoint of the for construct, the invariant state has no meaning at all. The for only passes the state value from the initialization step to all calls to the iterator function. 
Then the for assigns the values returned by the iterator function to the variables declared by its variable list. 
If the first returned value (the one assigned to the control variable) is nil, the loop terminates. Otherwise, the for executes its body and calls the iteration function again, repeating the process.

More precisely, a construction like

for var_1, ..., var_n in explist do
    block
end

is equivalent to the following code:

do
    local _f, _s, _var = explist
    while true do
        local var_1, ... , var_n = _f(_s, _var)
        _var = var_1
        if _var == nil then
            break
        end
        block
　end
end

So, if our iterator function is f, the invariant state is s, and the initial value for the control variable is a0, 
the control variable will loop over the values a1 = f(s, a0), a2 = f(s, a1), and so on, until ai is nil. 
If the for has other variables, they simply get the extra values returned by each call to f.


Stateless Iterators
As the name implies, a stateless iterator is an iterator that does not keep any state by itself. Therefore, we can use the same stateless iterator in multiple loops, avoiding the cost of creating new closures.

As we just saw, the for loop calls its iterator function with two arguments: the invariant state and the control variable. A stateless iterator generates the next element for the iteration using only these two values. 
A typical example of this kind of iterator is ipairs, which iterates over all elements of a sequence:

a = {"one", "two", "three"}
for i, v in ipairs(a) do
    print(i, v)
end
The whole state of the iteration comprises the table being traversed (the invariant state, which does not change during the loop), plus the current index (the control variable). 
Both ipairs (the factory) and the iterator are quite simple; we could write them in Lua as follows:

local function iter (t, i)
    i = i + 1
    local v = t[i]
    if v then
　    return i, v
    end
end

function ipairs (t)
    return iter, t, 0
end

When Lua calls ipairs(t) in a for loop, it gets three values: the function iter as the iterator, the table t as the invariant state, and zero as the initial value for the control variable. 
Then, Lua calls iter(t, 0), which results in 1,t[1] (unless t[1] is already nil). In the second iteration, Lua calls iter(t, 1), which results in 2,t[2], and so on, until the first nil element.

The function pairs, which iterates over all elements of a table, is similar, except that its iterator function is next, which is a primitive function in Lua:

function pairs(t)
    return next, t, nil
end

The call next(t, k), where k is a key of the table t, returns a next key in the table, in an arbitrary order, plus the value associated with this key as a second return value. 
The call next(t, nil) returns a first pair. When there are no more pairs, next returns nil.
We might use next directly, without calling pairs: 
for k, v in next, t do
    loop body
end

Remember that the for loop adjusts its expression list to three results, so that it gets next, t, and nil; this is exactly what it gets when it calls pairs(t).

Another interesting example of a stateless iterator is one to traverse a linked list. (Linked lists are not frequent in Lua, but sometimes we need them.) 
A first thought could be to use only the current node as the control variable, so that the iterator function could return its next node:

local function getnext (node)
    return node.next
end

function traverse (list)
    return getnext, nil, list
end
However, this implementation would skip the first node. Instead, we can use the following code:

local function getnext (list, node)
    if not node then
　    return list
    else
　    return node.next
    end
end

function traverse (list)
    return getnext, list, nil
end
The trick here is to use the first node as the invariant state (the second value returned by traverse), besides the current node as the control variable. 
The first time the iterator function getnext is called, node will be nil, and so the function will return list as the first node. 
In subsequent calls, node will not be nil, and so the iterator will return node.next, as expected.
Traversing Tables in Order
A common confusion happens when programmers try to order the entries of a table. In a table, the entries form a set, and have no order whatsoever. 
If we want to order them, we have to copy the keys to an array and then sort the array.
We saw an example of this technique in the “Most Frequent Words” program, in Chapter 11, Interlude: Most Frequent Words. 
Let us see here another example. Suppose that we read a source file and build a table that gives, for each function name, the line where this function is defined; something like this:

lines = { ["luaH_set"] = 10,
["luaH_get"] = 24,
["luaH_present"] = 48,
}
Now we want to print these function names in alphabetical order. If we traverse this table with pairs, the names appear in an arbitrary order. 
We cannot sort them directly, because these names are keys of the table. However, when we put them into an array, then we can sort them. 
First, we must create an array with these names, then sort it, and finally print the result:

a = {}
for n in pairs(lines) do
    a[#a + 1] = n
end
table.sort(a)

for _, n in ipairs(a) do
    print(n)
end
Some people get confused here. After all, for Lua, arrays also have no order (they are tables, after all). But we know how to count! 
So, we impose the order, when we access the array with ordered indices. That is why we should always traverse arrays with ipairs, rather than pairs. 
The first function imposes the key order 1, 2, etc., whereas the latter uses the natural arbitrary order of the table (which may not be what we need, even though usually it is).
Now we are ready to write an iterator that traverses a table following the order of its keys:

function pairsByKeys(t, f)
    local a = {}
    for n in pairs(t) do	-- create a list with all keys
        a[#a + 1] = n
    end
    table.sort(a, f)	-- sort the list
    local i = 0	-- iterator variable
    return function ()	-- iterator function
        i = i + 1
　    return a[i], t[a[i]]	-- return key, value
    end
end
The factory function pairsByKeys first collects the keys into an array, then it sorts the array, and finally it returns the iterator function. 
At each step, the iterator returns the next key and value from the original table, following the order in the array a. 
An optional parameter f allows the specification of an alternative order.

With this function, it is easy to solve our initial problem of traversing a table in order:

for name, line in pairsByKeys(lines) do
    print(name, line)
end
As usual, all the complexity is hidden inside the iterator.

True Iterators
The name “iterator” is a little misleading, because our iterators do not iterate: what iterates is the for loop. Iterators only provide the successive values for the iteration. 
Maybe a better name would be “generator” — which generates elements for the iteration— but “iterator” is already well established in other languages, such as Java.

However, there is another way to build iterators wherein iterators actually do the iteration. When we use such iterators, we do not write a loop; 
instead, we simply call the iterator with an argument that describes what the iterator must do at each iteration. 
More specifically, the iterator receives as argument a function that it calls inside its loop.

As a concrete example, let us rewrite once more the allwords iterator using this style:
function allwords(f)
    for line in io.lines() do
        for word in string.gmatch(line, "%w+") do
            f(word)	-- call the function
        end
　end
end
To use this iterator, we must supply the loop body as a function. If we want only to print each word, we simply use print:
allwords(print)
Often, we use an anonymous function as the body. For instance, the next code fragment counts how many times the word “hello” appears in the input file:

local count = 0
allwords(function (w) if w == "hello" then count = count + 1 end end)
print(count)
The same task, written with the previous iterator style, is not very different:

local count = 0
for w in allwords() do
　if w == "hello" then count = count + 1 end
end
print(count)
True iterators were popular in older versions of Lua, when the language did not have the for statement. How do they compare with generator-style iterators? 
Both styles have approximately the same overhead: one function call per iteration. On the one hand, it is easier to write the iterator with true iterators 
(although we can recover this easiness with coroutines, as we will see in the section called “Coroutines as Iterators”). 
On the other hand, the generator style is more flexible. First, it allows two or more parallel iterations. 
(For instance, consider the problem of iterating over two files comparing them word by word.) Second, it allows the use of break and return inside the iterator body. 
With a true iterator, a return returns from the anonymous function, not from the function doing the iteration. For these reasons, overall I usually prefer generators.

Chapter 19. Interlude: Markov Chain Algorithm
Our next complete program is an implementation of the Markov chain algorithm, described by Kernighan & Pike in their book The Practice of Programming (Addison-Wesley, 1999).
The program generates pseudo-random text based on what words can follow a sequence of n previous words in a base text. For this implementation, we will assume that n is two.
The first part of the program reads the base text and builds a table that, for each prefix of two words, gives a list of the words that follow that prefix in the text. 
After building the table, the program uses it to generate random text, wherein each word follows two previous words with the same probability as in the base text. 
As a result, we have text that is very, but not quite, random. For instance, when applied to this book, 
the output of the program has pieces like this: “Constructors can also traverse a table constructor, 
then the parentheses in the following line does the whole file in a field n to store the contents of each function, 
but to show its only argument. If you want to find the maximum element in an array can return both the maximum value and continues showing the prompt and running the code. 
The following words are reserved and cannot be used to convert between degrees and radians.”

To use a two-word prefix as a key in tables, we will represent it by the two words concatenated with a space in between:

function prefix (w1, w2)
    return w1 .. " " .. w2
end
We use the string NOWORD (a newline) to initialize the prefix words and to mark the end of the text. 
For instance, for the text "the more we try the more we do" the table of following words would be like this:

{ ["\n \n"] = {"the"},
["\n the"] = {"more"},
["the more"] = {"we", "we"},
["more we"] = {"try", "do"},
["we try"] = {"the"},
["try the"] = {"more"},
["we do"] = {"\n"},
}
The program keeps its table in the variable statetab. To insert a new word in a list in this table, we use the following function:

function insert (prefix, value)
    local list = statetab[prefix]
    if list == nil then
　    statetab[prefix] = {value}
    else
　    list[#list + 1] = value
    end
end
It first checks whether that prefix already has a list; if not, it creates a new one with the new value. Otherwise, it inserts the new value at the end of the existing list.

To build the statetab table, we keep two variables, w1 and w2, with the last two words read. We read the words using the iterator allwords, from the section called “Iterators and Closures”, 
but we adapted the definition of “word” to include optional punctuation marks, such as commas and periods (see Figure 19.1, “Auxiliary definitions for the Markov program”). 
For each new word read, we add it to the list associated with w1–w2 and then update w1 and w2.

After building the table, the program starts to generate a text with MAXGEN words. First, it re-initializes variables w1 and w2. 
Then, for each prefix, it chooses a next word randomly from the list of valid next words, prints this word, and updates w1 and w2. 

function allwords ()
    local line = io.read()	-- current line
    local pos = 1	-- current position in the line
    return function ()	-- iterator function
        while line do	-- repeat while there are lines
            local w, e = string.match(line, "(%w+[,;.:]?)()", pos)
            if w then		-- found a word?
                pos = e	-- update next position
　            return w	-- return the word
            else
                line = io.read()	-- word not found; try next line
                pos = 1	-- restart from first position
　        end
        end
        return nil	-- no more lines: end of traversal
    end
end

function prefix (w1, w2)
    return w1 .. " " .. w2
end

local statetab = {}

function insert (prefix, value)
    local list = statetab[prefix]
    if list == nil then
　    statetab[prefix] = {value}
    else
　    list[#list + 1] = value
    end
end

local MAXGEN = 200
local NOWORD = "\n"

-- build table
local w1, w2 = NOWORD, NOWORD
for nextword in allwords() do
    insert(prefix(w1, w2), nextword)
    w1 = w2; w2 = nextword;
end
insert(prefix(w1, w2), NOWORD)

-- generate text
w1 = NOWORD; w2 = NOWORD	-- reinitialize
for i = 1, MAXGEN do
    local list = statetab[prefix(w1, w2)]
    -- choose a random item from list
    local r = math.random(#list)
    local nextword = list[r]
    if nextword == NOWORD then return end
    io.write(nextword, " ")
　w1 = w2; w2 = nextword
end

Chapter 20. Metatables and Metamethods
Usually, each value in Lua has a quite predictable set of operations. We can add numbers, we can concatenate strings, we can insert key–value pairs into tables, and so on. 
However, we cannot add tables, we cannot compare functions, and we cannot call a string. Unless we use metatables.

Metatables allow us to change the behavior of a value when confronted with an unknown operation. 
For instance, using metatables, we can define how Lua computes the expression a + b, where a and b are tables. 
Whenever Lua tries to add two tables, it checks whether either of them has a metatable and whether this metatable has an add field. 
If Lua finds this field, it calls the corresponding value —the so-called metamethod, which should be a function— to compute the sum.

We can think about metatables as a restricted kind of classes, in object-oriented terminology. Like classes, metatables define the behavior of its instances. 
However, metatables are more restricted than classes, because they can only give behavior to a predefined set of operations; also, metatables do not have inheritance. 
Nevertheless, we will see in Chapter 21, Object-Oriented Programming how to build a quite complete class system on top of metatables.

Each value in Lua can have a metatable. Tables and userdata have individual metatables; values of other types share one single metatable for all values of that type. 
Lua always creates new tables without metatables:

t = {}
print(getmetatable(t))	--> nil
We can use setmetatable to set or change the metatable of a table:
t1 = {}
setmetatable(t, t1)
print(getmetatable(t) == t1)	--> true
From Lua, we can set the metatables only of tables; to manipulate the metatables of values of other types we must use C code or the debug library. 
(The main reason for this restriction is to curb excessive use of type- wide metatables. Experience with older versions of Lua has shown that those global settings frequently lead to non-reusable code.) 
The string library sets a metatable for strings; all other types by default have no metatable:

print(getmetatable("hi"))	--> table: 0x80772e0
print(getmetatable("xuxu"))	--> table: 0x80772e0
print(getmetatable(10))	--> nil
print(getmetatable(print))	--> nil
Any table can be the metatable of any value; a group of related tables can share a common metatable, which describes their common behavior; 
a table can be its own metatable, so that it describes its own individual behavior. Any configuration is valid.
Arithmetic Metamethods
In this section, we will introduce a running example to explain the basics of metatables. Suppose we have a module that uses tables to represent sets, with functions to compute set union, intersection, and the like, as shown in Figure 20.1, “A simple module for sets”.

local Set = {}

-- create a new set with the values of a given list
function Set.new (l)
    local set = {}
    for _, v in ipairs(l)
        do set[v] = true
    end
    return set
end

function Set.union(a, b)
    local res = Set.new{}
    for k in pairs(a) do
        res[k] = true
    end
    for k in pairs(b) do
        res[k] = true
    end
    return res
end

function Set.intersection(a, b)
    local res = Set.new{}
    for k in pairs(a) do
        res[k] = b[k]
    end
　return res
end

-- presents a set as a string
function Set.tostring(set)
    local l = {}	-- list to put all elements from the set
    for e in pairs(set) do
　    l[#l + 1] = tostring(e)
    end
　return "{" .. table.concat(l, ", ") .. "}"
end

return Set

Now, we want to use the addition operator to compute the union of two sets. For that, we will arrange for all tables representing sets to share a metatable. 
This metatable will define how they react to the addition operator. Our first step is to create a regular table, which we will use as the metatable for sets:

local mt = {}	-- metatable for sets

The next step is to modify Set.new, which creates sets. The new version has only one extra line, which sets mt as the metatable for the tables that it creates:

function Set.new(l)	-- 2nd version
    local set = {}
    setmetatable(set, mt)
    for _, v in ipairs(l) do
        set[v] = true
    end
    return set
end

After that, every set we create with Set.new will have that same table as its metatable:

s1 = Set.new{10, 20, 30, 50}
s2 = Set.new{30, 1}
print(getmetatable(s1))	--> table: 0x00672B60
print(getmetatable(s2))	--> table: 0x00672B60
Finally, we add to the metatable the metamethod add, a field that describes how to perform the addition:
mt.add = Set.union
After that, whenever Lua tries to add two sets, it will call Set.union, with the two operands as arguments.
With the metamethod in place, we can use the addition operator to do set unions:

s3 = s1 + s2
print(Set.tostring(s3))	--> {1, 10, 20, 30, 50}
Similarly, we may set the multiplication operator to perform set intersection:

mt.mul = Set.intersection

print(Set.tostring((s1 + s2)*s1))	--> {10, 20, 30, 50}
For each arithmetic operator there is a corresponding metamethod name. Besides addition and multiplication, 
there are metamethods for subtraction ( sub), float division ( div), floor division ( idiv), negation (unm), modulo (mod), and exponentiation (pow). 
Similarly, there are metamethods for  all bitwise operations: bitwise AND (  band), OR (   bor), exclusive OR (   bxor), NOT (   bnot),  left shift ( shl), and right shift ( shr). 
We may define also a behavior for the concatenation operator, with the field concat.
When we add two sets, there is no question about what metatable to use. However, we may write an expression that mixes two values with different metatables, for instance like this:

s = Set.new{1,2,3}
s = s + 8
When looking for a metamethod, Lua performs the following steps: 
if the first value has a metatable with the required metamethod, Lua uses this metamethod, independently of the second value; 
otherwise, if the second value has a metatable with the required metamethod, Lua uses it; otherwise, Lua raises an error. 
Therefore, the last example will call Set.union, as will the expressions 10 + s and "hello" + s (because both numbers and strings do not have a metamethod add).
Lua does not care about these mixed types, but our implementation does. If we run the s = s + 8 example, we will get an error inside the function Set.union:
bad argument #1 to 'pairs' (table expected, got number)
If we want more lucid error messages, we must check the type of the operands explicitly before attempting to perform the operation, for instance with code like this:

function Set.union (a, b)
    if getmetatable(a) ~= mt or getmetatable(b) ~= mt then
        error("attempt to 'add' a set with a non-set value", 2)
    end
end
as before
Remember that the second argument to error (2, in this example) sets the source location in the error message to the code that called the operation.


Relational Metamethods
Metatables also allow us to give meaning to the relational operators, through the metamethods eq (equal to),   lt (less than), and    le (less than or equal to). 
There are no separate metamethods for the other three relational operators: Lua translates a ~= b to not (a == b), a > b to b < a, and a >= b to b <= a.
In older versions, Lua translated all order operators to a single one, by translating a <= b to not (b< a). 
However, this translation is incorrect when we have a partial order, that is, when not all elements in our type are properly ordered. 
For instance, most machines do not have a total order for floating-point numbers, because of the value Not a Number (NaN). 
According to the IEEE 754 standard, NaN represents undefined values, such as the result of 0/0. The standard specifies that any comparison that involves NaN should result in false. 
This means that NaN <= x is always false, but x < NaN is also false. It also means that the translation from a <= b to not (b < a) is not valid in this case.
In our example with sets, we have a similar problem. An obvious (and useful) meaning for <= in sets is set containment: a <= b means that a is a subset of b. 
With this meaning, it is possible that a <= b and b < a are both false. Therefore, we must implement both le (less or equal, the subset relation) and lt (less than, the proper subset relation):
mt.le = function (a, b)
    for k in pairs(a) do
        if not b[k] then
            return false
        end
    end
　return true
end

mt.lt = function (a, b)
    return a <= b and not (b <= a)
end
Finally, we can define set equality through set containment:

mt. eq = function (a, b)
    return a <= b and b <= a
end
After these definitions, we are ready to compare sets:

s1 = Set.new{2, 4}
s2 = Set.new{4, 10, 2}
print(s1 <= s2)	--> true
print(s1 < s2)	--> true
print(s1 >= s1)	--> true
print(s1 > s1)	--> false
print(s1 == s2 * s1)	--> true
The equality comparison has some restrictions. If two objects have different basic types, the equality operation results in false, without even calling any metamethod. 
So, a set will always be different from a number, no matter what its metamethod says.
Library-Defined Metamethods
So far, all the metamethods we have seen are for the Lua core. It is the virtual machine who detects that the values involved in an operation have metatables with metamethods for that particular operation. 
However, because metatables are regular tables, anyone can use them. So, it is a common practice for libraries to define and use their own fields in metatables.
The function tostring provides a typical example. As we saw earlier, tostring represents tables in a rather simple format:

print({})	--> table: 0x8062ac0
The function print always calls tostring to format its output. However, when formatting any value, tostring first checks whether the value has a tostring metamethod. 
In this case, tostring calls the metamethod to do its job, passing the object as an argument. Whatever this metamethod returns is the result of tostring.
In our example with sets, we have already defined a function to present a set as a string. So, we need only to set the tostring field in the metatable:
mt.tostring = Set.tostring
After that, whenever we call print with a set as its argument, print calls tostring that calls Set.tostring:
s1 = Set.new{10, 4, 5}
print(s1)	--> {4, 5, 10}
The functions setmetatable and getmetatable also use a metafield, in this case to protect metatables. 
Suppose we want to protect our sets, so that users can neither see nor change their metatables. 
If we set a metatable field in the metatable, getmetatable will return the value of this field, whereas setmetatable will raise an error:
mt.metatable = "not your business"

s1 = Set.new{}
print(getmetatable(s1))	--> not your business
setmetatable(s1, {})
stdin:1: cannot change protected metatable
Since Lua 5.2, pairs also have a metamethod, so that we can modify the way a table is traversed and add a traversal behavior to non-table objects. 
When an object has a __pairs metamethod, pairs will call it to do all its work.
Table-Access Metamethods
The metamethods for arithmetic, bitwise, and relational operators all define behavior for otherwise erroneous situations; they do not change the normal behavior of the language. 
Lua also offers a way to change the behavior of tables for two normal situations, the access and modification of absent fields in a table.
The __index metamethod
We saw earlier that, when we access an absent field in a table, the result is nil. This is true, but it is not the whole truth. 
Actually, such accesses trigger the interpreter to look for an __index metamethod: if there is no such method, as usually happens, then the access results in nil; 
otherwise, the metamethod will provide the result.
The archetypal example here is inheritance. Suppose we want to create several tables describing windows. 
Each table must describe several window parameters, such as position, size, color scheme, and the like. 
All these parameters have default values and so we want to build window objects giving only the non-default parameters. 
A first alternative is to provide a constructor that fills in the absent fields. A second alternative is to arrange for the new windows to inherit any absent field from a prototype window. 
First, we declare the prototype:

-- create the prototype with default values
prototype = {x = 0, y = 0, width = 100, height = 100}
Then, we define a constructor function, which creates new windows sharing a metatable:

local mt = {}	-- create a metatable
-- declare the constructor function
function new(o)
    setmetatable(o, mt)
    return o
end
Now, we define the __index metamethod:
mt.__index = function (_, key)
    return prototype[key]
end
After this code, we create a new window and query it for an absent field:

w = new{x=10, y=20}
print(w.width)	--> 100
Lua detects that w does not have the requested field, but has a metatable with an  __index field. 
So,  Lua calls this __index metamethod, with arguments w (the table) and "width" (the absent key). 
The metamethod then indexes the prototype with the given key and returns the result.
The use of the __index metamethod for inheritance is so common that Lua provides a shortcut. 
Despite being called a method, the __index metamethod does not need to be a function: it can be a table, instead. 
When it is a function, Lua calls it with the table and the absent key as its arguments, as we have just seen. 
When it is a table, Lua redoes the access in this table. Therefore, in our previous example, we could declare __index simply like this:
mt.__index = prototype
Now, when Lua looks for the metatable's __index field, it finds the value of prototype, which is a table. Consequently, Lua repeats the access in this table, that is, 
it executes the equivalent of prototype["width"]. This access then gives the desired result.
The use of a table as an __index metamethod provides a fast and simple way of implementing single inheritance. A function, although more expensive, provides more flexibility: 
we can implement multiple inheritance, caching, and several other variations. We will discuss these forms of inheritance in Chapter 21, Object-Oriented Programming, when we will cover object-oriented programming.
When we want to access a table without invoking its __index metamethod, we use the function rawget. The call rawget(t, i) does a raw access to table t, that is, a primitive access without considering metatables. 
Doing a raw access will not speed up our code (the overhead of a function call kills any gain we could have), but sometimes we need it, as we will see later.
The __newindex metamethod
The __newindex metamethod does for table updates what index does for table accesses. When we assign a value to an absent index in a table, 
the interpreter looks for a __newindex metamethod: if there is one, the interpreter calls it instead of making the assignment. 
Like __index, if the metamethod is a table, the interpreter does the assignment in this table, instead of in the original one. 
Moreover, there is a raw function that allows us to bypass the metamethod: the call rawset(t, k, v) does the equivalent to t[k] = v without invoking any metamethod.
The combined use of the __index and __newindex metamethods allows several powerful constructs in Lua, such as read-only tables, tables with default values, and inheritance for object-oriented programming. 
In this chapter, we will see some of these uses. Object-oriented programming has its own chapter, later.
Tables with default values
The default value of any field in a regular table is nil. It is easy to change this default value with metatables:

function setDefault(t, d)
    local mt = { __index = function () return d end}
    setmetatable(t, mt)
end

tab = {x=10, y=20}
print(tab.x, tab.z)	--> 10	nil
setDefault(tab, 0)
print(tab.x, tab.z)	--> 10	0
After the call to setDefault, any access to an absent field in tab calls its __index metamethod, which returns zero (the value of d for this metamethod).
The function setDefault creates a new closure plus a new metatable for each table that needs a default value. This can be expensive if we have many tables that need default values. 
However, the metatable has the default value d wired into its metamethod, so we cannot use a single metatable for tables with different default values. 
To allow the use of a single metatable for all tables, we can store the default value of each table in the table itself, using an exclusive field. 
If we are not worried about name clashes, we can use a key like "___" for our exclusive field:
local mt = { __index = function (t) return t.___ end}
function setDefault (t, d)
    t.___ = d
    setmetatable(t, mt)
end
Note that now we create the metatable mt and its corresponding metamethod only once, outside SetDefault.
If we are worried about name clashes, it is easy to ensure the uniqueness of the special key. All we need is a new exclusive table to use as the key:

local key = {}	-- unique key
local mt = { __index = function (t) return t[key] end}
function setDefault (t, d)
    t[key] = d
    setmetatable(t, mt)
end
An alternative approach for associating each table with its default value is a technique I call dual representation, which uses a separate table where the indices are the tables and the values are their default values. 
However, for the correct implementation of this approach, we need a special breed of table called weak tables, and so we will not use it here; we will return to the subject in Chapter 23, Garbage.


Another alternative is to memorize metatables in order to reuse the same metatable for tables with the same default. However, that needs weak tables too, so that again we will have to wait until Chapter 23, Garbage.
Tracking table accesses
Suppose we want to track every single access to a certain table. Both __index and __newindex are relevant only when the index does not exist in the table. 
So, the only way to catch all accesses to a table is to keep it empty. If we want to monitor all accesses to a table, we should create a proxy for the real table. 
This proxy is an empty table, with proper metamethods that track all accesses and redirect them to the original table. 

function track(t)
    local proxy = {}
    local mt = {
        __index = function (_, k)
            print("*access to element " .. tostring(k))
            return t[k]	-- access the original table
        end, 
        __newindex = function (_, k, v)
            print("*update of element " .. tostring(k) .. " to " .. tostring(v))
            t[k] = v	-- update original table
        end, 
        __pairs = function ()
            return function (_, k)
                local nextkey, nextvalue = next(t, k)
                if nextkey ~= nil then
                    print("*traversing element " .. tostring(nextkey))
                end
                return nextkey, nextvalue
            end
        end, 
        __len = function () return #t end
    }

    setmetatable(proxy, mt)

    return proxy
end
The following example illustrates its use:

> t = {}	-- an arbitrary table
> t = track(t)
> t[2] = "hello" --> *update of element 2 to hello
> print(t[2]) --> *access to element 2
hello
The metamethods __index and __newindex follow the guidelines that we set, tracking each access and then redirecting it to the original table. 
The __pairs metamethod allows us to traverse the proxy as if it were the original table, tracking the accesses along the way. 
Finally, the __len metamethod gives  the length operator through the proxy:

t = track({10, 20})
print(#t)	--> 2
for k, v in pairs(t) do
    print(k, v)
end
--> *traversing element 1
--> 1 10
--> *traversing element 2
--> 2 20
If we want to monitor several tables, we do not need a different metatable for each one. Instead, we can somehow map each proxy to its original table and share a common metatable for all proxies. 
This problem is similar to the problem of associating tables to their default values, which we discussed in the previous section, and allows the same solutions. 
For instance, we can keep the original table in a proxy's field, using an exclusive key, or we can use a dual representation to map each proxy to its corresponding table.
Read-only tables
It is easy to adapt the concept of proxies to implement read-only tables. All we have to do is to raise an error whenever we track any attempt to update the table. 
For the __index metamethod, we can use a table —the original table itself— instead of a function, as we do not need to track queries; 
it is simpler and rather more efficient to redirect all queries to the original table. This use demands a new metatable for each read-only proxy, with index pointing to the original table:

function readOnly(t)
    local proxy = {}
    local mt = {
        __index = t,
        __newindex = function (t, k, v)
　        error("attempt to update a read-only table", 2)
        end
    }
    setmetatable(proxy, mt)
    return proxy
end
As an example of use, we can create a read-only table for weekdays:

days = readOnly{"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"}

print(days[1])	--> Sunday
days[2] = "Noday"
--> stdin:1: attempt to update a read-only table

Chapter 21. Object-Oriented Programming

Objects have their own operations. Tables also can have operations, as in the following fragment:

Account = {balance = 0}
function Account.withdraw(v)
    Account.balance = Account.balance - v
end

This definition creates a new function and stores it in field withdraw of the object Account. Then, we can call it like here:

Account.withdraw(100.00)

This kind of function is almost what we call a method. However, the use of the global name Account inside the function is a horrible programming practice. 
First, this function will work only for this particular object. Second, even for this particular object, the function will work only as long as the object is stored in that particular global variable. 
If we change the object's name, withdraw does not work any more:

a, Account = Account, nil
a.withdraw(100.00)	-- ERROR!

Such behavior violates the principle that objects have independent life cycles.

A more principled approach is to operate on the receiver of the operation. For that, our method would need an extra parameter with the value of the receiver. This parameter usually has the name self or this:

function Account.withdraw (self, v)
    self.balance = self.balance - v
end

Now, when we call the method we have to specify the object that it has to operate on:

a1 = Account; Account = nil
...
a1.withdraw(a1, 100.00)	-- OK

With the use of a self parameter, we can use the same method for many objects:

a2 = {balance=0, withdraw = Account.withdraw}
...
a2.withdraw(a2, 260.00)

This use of a self parameter is a central point in any object-oriented language. Most OO languages have this mechanism hidden from the programmer, 
so that she does not have to declare this parameter (although she still can use the name self or this inside a method). Lua also can hide this parameter, with the colon operator. 
Using it, we can rewrite the previous method call as a2:withdraw(260.00) and the previous definition as here:

function Account:withdraw(v)
    self.balance = self.balance - v
end

The effect of the colon is to add an extra argument in a method call and to add an extra hidden parameter in a method definition. 
The colon is only a syntactic facility, although a convenient one; there is nothing really new here. 
We can define a function with the dot syntax and call it with the colon syntax, or vice- versa, as long as we handle the extra parameter correctly:

Account = { balance=0,
    withdraw = function (self, v)
　    self.balance = self.balance - v
    end
}

function Account:deposit (v)
    self.balance = self.balance + v
end

Account.deposit(Account, 200.00)
Account:withdraw(100.00)

Classes

So far, our objects have an identity, state, and operations on this state. They still lack a class system, inheritance, and privacy. Let us tackle the first problem: 
how can we create several objects with similar behavior? Specifically, how can we create several accounts?

Most object-oriented languages offer the concept of class, which works as a mold for the creation of objects. In such languages, each object is an instance of a specific class. 
Lua does not have the concept of class; the concept of metatables is somewhat similar, but using it as a class would not lead us too far. 
Instead, we can emulate classes in Lua following the lead from prototype-based languages like Self. (Javascript also followed that path.) 
In these languages, objects have no classes. Instead, each object may have a prototype, which is a regular object where the first object looks up any operation that it does not know about. 
To represent a class in such languages, we simply create an object to be used exclusively as a prototype for other objects (its instances). 
Both classes and prototypes work as a place to put behavior to be shared by several objects.

In Lua, we can implement prototypes using the idea of inheritance that we saw in the section called “The __index metamethod”. 
More specifically, if we have two objects A and B, all we have to do to make B a prototype for A is this:

setmetatable(A, { __index = B})

After that, A looks up in B for any operation that it does not have. To see B as the class of the object A is not much more than a change in terminology.

Let us go back to our example of a bank account. To create other accounts with behavior similar to Account, 
we arrange for these new objects to inherit their operations from Account, using the __index metamethod.

local mt = { __index = Account}

function Account.new(o)
    o = o or {}	-- create table if user does not provide one
    setmetatable(o, mt)
　return o
end

After this code, what happens when we create a new account and call a method on it, like this?

a = Account.new{balance = 0}
a:deposit(100.00)

When we create the new account, a, it will have mt as its metatable. When we call a:deposit(100.00), we are actually calling a.deposit(a, 100.00); the colon is only syntactic sugar. 
However, Lua cannot find a "deposit" entry in the table a; hence, Lua looks into the __index entry of the metatable. The situation now is more or less like this:

getmetatable(a).__index.deposit(a, 100.00)

The metatable of a is mt, and mt.__index is Account. Therefore, the previous expression evaluates to this one:

Account.deposit(a, 100.00)

That is, Lua calls the original deposit function, but passing a as the self parameter. So, the new account a inherited the function deposit from Account. 
By the same mechanism, it inherits all fields from Account.

We can make two small improvements on this scheme. The first one is that we do not need to create a new table for the metatable role; 
instead, we can use the Account table itself for that purpose. The second one is that we can use the colon syntax for the new method, too. 
With these two changes, method new becomes like this:

function Account:new(o)
   o = o or {}
    self.__index = self
    setmetatable(o, self)
    return o
end

Now, when we call Account:new(), the hidden parameter self gets Account as its value, we make Account.__index also equal to Account, and set Account as the metatable for the new object. 
It may seem that we do not gained much with the second change (the colon syntax); the advantage of using self will become apparent when we introduce class inheritance, in the next section.
The inheritance works not only for methods, but also for other fields that are absent in the new account. Therefore, a class can provide not only methods, but also constants and default values for its instance fields. 
Remember that, in our first definition of Account, we provided a field balance with value 0. So, if we create a new account without an initial balance, it will inherit this default value:

b = Account:new()
print(b.balance)	--> 0

When we call the deposit method on b, it runs the equivalent of the following code, because self is b:

b.balance = b.balance + v

The expression b.balance evaluates to zero and the method assigns an initial deposit to b.balance. Subsequent accesses to b.balance will not invoke the __index metamethod, 
because now b has its own balance field.

Inheritance
Because classes are objects, they can get methods from other classes, too. This behavior makes inheritance (in the usual object-oriented meaning) quite easy to implement in Lua.

Let us assume we have a base class like Account, in Figure 21.1, “the Account class”.

Figure 21.1. the Account class
Account = {balance = 0}
function Account:new(o)
    o = o or {}
    self.__index = self
    setmetatable(o, self)
    return o
end

function Account:deposit(v)
    self.balance = self.balance + v
end

function Account:withdraw(v)
    if v > self.balance then
        error"insufficient funds"
    end
    self.balance = self.balance - v
end

From this class, we want to derive a subclass SpecialAccount that allows the customer to withdraw more than his balance. 
We start with an empty class that simply inherits all its operations from its base class:

SpecialAccount = Account:new()

Up to now, SpecialAccount is just an instance of Account. The magic happens now:

s = SpecialAccount:new{limit=1000.00}

SpecialAccount inherits new from Account, like any other method. This time, however, when new executes, its self parameter will refer to SpecialAccount. 
Therefore, the metatable of s will be SpecialAccount, whose value at field __index is also SpecialAccount. So, s inherits from SpecialAccount, which inherits from Account. 
Later, when we evaluate s:deposit(100.00), Lua cannot find a deposit field in s, so it looks into SpecialAccount; it cannot find a deposit field there, too, so it looks into Account; 
there it finds the original implementation for a deposit.

What makes a SpecialAccount special is that we can redefine any method inherited from its superclass. All we have to do is to write the new method:

function SpecialAccount:withdraw(v)
    if v - self.balance >= self:getLimit() then
        error"insufficient funds"
    end
　    self.balance = self.balance - v
end

function SpecialAccount:getLimit ()
    return self.limit or 0
end

Now, when we call s:withdraw(200.00), Lua does not go to Account, because it finds the new withdraw method in SpecialAccount first. 
As s.limit is 1000.00 (remember that we set this field when we created s), the program does the withdrawal, leaving s with a negative balance.

An interesting aspect of objects in Lua is that we do not need to create a new class to specify a new behavior. 
If only a single object needs a specific behavior, we can implement that behavior directly in the object. 
For instance, if the account s represents some special client whose limit is always 10% of her balance, we can modify only this single account:

function s:getLimit ()
    return self.balance * 0.10
end

After this declaration, the call s:withdraw(200.00) runs the withdraw method from SpecialAccount, but when withdraw calls self:getLimit, it is this last definition that it invokes.

Multiple Inheritance
Because objects are not primitive in Lua, there are several ways to do object-oriented programming in Lua. 
The approach that we have seen, using the __index metamethod, is probably the best combination    of simplicity, performance, and flexibility. 
Nevertheless, there are other implementations, which may be more appropriate for some particular cases. Here we will see an alternative implementation that allows multiple inheritance in Lua.

The key to this implementation is the use of a function for the metafield __index. Remember that, when a table's metatable has a function in the __index field, 
Lua will call this function whenever it cannot find a key in the original table. Then, __index can look up for the missing key in how many parents it wants.

Multiple inheritance means that a class does not have a unique superclass. Therefore, we should not use a (super)class method to create subclasses. 
Instead, we will define an independent function for this purpose, createClass, which has as arguments all superclasses of the new class. 
This function creates a table to represent the new class and sets its metatable with an __index metamethod that does the multiple inheritance. 
Despite the multiple inheritance, each object instance still belongs to one single class, where it looks for all its methods. 
Therefore, the relationship between classes and superclasses is different from the relationship between instances and classes. 
Particularly, a class cannot be the metatable for its instances and for its subclasses at the same time. 
we keep the class as the metatable for its instances, and create another table to be the metatable of the class.

-- look up for 'k' in list of tables 'plist'
local function search(k, plist)
    for i = 1, #plist do
        local v = plist[i][k]
        if v then
            return v
        end
    end
end

function createClass(...)
    local c = {}	-- new class
    local parents = {...}	-- list of parents

    -- class searches for absent methods in its list of parents
    setmetatable(c, { __index = function (t, k) return search(k, parents) end})

    -- prepare 'c' to be the metatable of its instances
    c.__index = c

    -- define a new constructor for this new class
    function c:new(o)
        o = o or {}
        setmetatable(o, c)
        return o
    end

　return c	-- return new class
end
Let us illustrate the use of createClass with a small example. Assume our previous class Account and another class, Named, with only two methods: setname and getname.
Named = {}
function Named:getname ()
    return self.name
end

function Named:setname(n)
    self.name = n
end
To create a new class NamedAccount that is a subclass of both Account and Named, we simply call createClass:
NamedAccount = createClass(Account, Named)
To create and to use instances, we do as usual:

account = NamedAccount:new{name = "Paul"}
print(account:getname())	--> Paul
Now let us follow how Lua evaluates the expression account:getname(); more specifically, let us follow the evaluation of account["getname"]. 
Lua cannot find the field "getname" in account; so, it looks for the field __index on the account's metatable, which is NamedAccount in our example. 
But NamedAccount also cannot provide a "getname" field, so Lua looks for the field __index of NamedAccount's metatable. 
Because this field contains a function, Lua calls it. This function then looks for "getname" first in Account, without success, and then in Named, where it finds a non-nil value, 
which is the final result of the search.

Of course, due to the underlying complexity of this search, the performance of multiple inheritance is not the same as single inheritance. 
A simple way to improve this performance is to copy inherited methods into the subclasses. Using this technique, the __index metamethod for classes would be like this:

setmetatable(c, { __index = function (t, k)
    local v = search(k, parents)
    t[k] = v	-- save for next access
    return v
    end})

With this trick, accesses to inherited methods are as fast as to local methods, except for the first access. 
The drawback is that it is difficult to change method definitions after the program has started, because these changes do not propagate down the hierarchy chain.

Privacy
Many people consider privacy (also called information hiding) to be an integral part of an object-oriented language: the state of each object should be its own internal affair. 
In some object-oriented languages, such as C++ and Java, we can control whether a field (also called an instance variable) or a method is visible outside the object. 
Smalltalk, which popularized object-oriented languages, makes all variables private and all methods public. 
Simula, the first ever object-oriented language, did not offer any kind of protection.

The standard implementation of objects in Lua, which we have shown previously, does not offer privacy mechanisms. 
Partly, this is a consequence of our use of a general structure (tables) to represent objects. Moreover, Lua avoids redundancy and artificial restrictions. 
If you do not want to access something that lives inside an object, just do not do it. A common practice is to mark all private names with an underscore at the end. 
You immediately feel the smell when you see a marked name being used in public.

Nevertheless, another aim of Lua is to be flexible, offering the programmer meta-mechanisms that enable her to emulate many different mechanisms. 
Although the basic design for objects in Lua does not offer privacy mechanisms, we can implement objects in a different way, to have access control. 
Although programmers do not use this implementation frequently, it is instructive to know about it, both because it explores some interesting aspects of Lua and 
because it is a good solution for more specific problems.

The basic idea of this alternative design is to represent each object through two tables: one for its state and another for its operations, or its interface. 
We access the object itself through the second table, that is, through the operations that compose its interface. 
To avoid unauthorized access, the table representing the state of an object is not kept in a field of the other table; instead, it is kept only in the closure of the methods. 
For instance, to represent our bank account with this design, we could create new objects running the following factory function:

function newAccount(initialBalance)
    local self = {balance = initialBalance}
    local withdraw = function (v)
　    self.balance = self.balance - v
    end
    local deposit = function (v)
　    self.balance = self.balance + v
    end
    local getBalance = function ()
        return self.balance
    end

    return {
    withdraw = withdraw,
    deposit = deposit, 
    getBalance = getBalance
    }
end

First, the function creates a table to keep the internal object state and stores it in the local variable self. Then, the function creates the methods of the object. 
Finally, the function creates and returns the external object, which maps method names to the actual method implementations. 
The key point here is that these methods do not get self as an extra parameter; instead, they access self directly. 
Because there is no extra argument, we do not use the colon syntax to manipulate such objects. We call their methods just like regular functions:

acc1 = newAccount(100.00)
acc1.withdraw(40.00)
print(acc1.getBalance())	--> 60

This design gives full privacy to anything stored in the self table. After the call to newAccount returns, there is no way to gain direct access to this table. 
We can access it only through the functions created inside newAccount. Although our example puts only one instance variable into the private table, 
we can store all private parts of an object in this table. We can also define private methods: they are like public methods, but we do not put them in the interface. 
For instance, our accounts may give an extra credit of 10% for users with balances above a certain limit, but we do not want the users to have access to the details of that computation. 
We can implement this functionality as follows:

function newAccount(initialBalance)
    local self = { balance = initialBalance, LIM = 10000.00, }
    local extra = function ()
        if self.balance > self.LIM then
            return self.balance*0.10
        else
　        return 0 
        end
    end
    local getBalance = function () 
        return self.balance + extra()
    end
    local withdraw = function (v)
　    self.balance = self.balance - v
    end
    local deposit = function (v)
　    self.balance = self.balance + v
    end

    return {
    withdraw = withdraw,
    deposit = deposit, 
    getBalance = getBalance
    }
end

Again, there is no way for any user to access the function extra directly.


The Single-Method Approach
A particular case of the previous approach for object-oriented programming occurs when an object has  a single method. In such cases, we do not need to create an interface table; 
instead, we can return this single method as the object representation. If this sounds a little weird, it is worth remembering iterators like io.lines or string.gmatch. 
An iterator that keeps state internally is nothing more than a single-method object.

Another interesting case of single-method objects occurs when this single-method is actually a dispatch method that performs different tasks based on a distinguished argument. 
A prototypical implementation for such an object is as follows:

function newObject(value)
    return function(action, v)
        if action == "get" then
            return value
        elseif action == "set" then
            value = v
        else
            error("invalid action")
　    end
    end
end
Its use is straightforward:

d = newObject(0)
print(d("get"))	--> 0
d("set", 10)
print(d("get"))	--> 10
This unconventional implementation for objects is quite effective. The syntax d("set", 10), although peculiar, is only two characters longer than the more conventional d:set(10). 
Each object uses one single closure, which is usually cheaper than one table. There is no inheritance, but we have full privacy: 
the only way to access an object state is through its sole method.

Tcl/Tk uses a similar approach for its widgets. The name of a widget in Tk denotes a function (a widget command) that can perform all kinds of operations over the widget, 
according to its first argument.
Dual Representation
Another interesting approach for privacy uses a dual representation. Let us start seeing what a dual representation is.

Usually, we associate attributes to tables using keys, like this:

table[key] = value0
However, we can use a dual representation: we can use a table to represent a key, and use the object itself as a key in that table:

key = {}
...
key[table] = value
A key ingredient here is the fact that we can index tables in Lua not only with numbers and strings, but with any value —in particular with other tables.

As an example, in our Account implementation, we could keep the balances of all accounts in a table balance, instead of keeping them in the accounts themselves. 
Our withdraw method would become like this:

function Account.withdraw(self, v)
    balance[self] = balance[self] - v
end

What we gain here? Privacy. Even if a function has access to an account, it cannot directly access its balance unless it also has access to the table balance. 
If the table balance is kept in a local inside the module Account, only functions inside the module can access it and, therefore, only those functions can manipulate account balances.

Before we go on, I must discuss a big naivety of this implementation. Once we use an account as a key in the balance table, that account will never become garbage for the garbage collector. 
It will be anchored there until some code explicitly removes it from that table. 
That may not be a problem for bank accounts (as an account usually has to be formally closed before going away), 
but for other scenarios that could  be a big drawback. In the section called “Object Attributes”, we will see how to solve this problem. For now, we will ignore it.

Figure 21.3, “Accounts using a dual representation” shows again an implementation for accounts, this time using a dual representation.

Figure 21.3. Accounts using a dual representation

local balance = {}
Account = {}
function Account:withdraw(v)
    balance[self] = balance[self] - v
end

function Account:deposit(v)
    balance[self] = balance[self] + v
end

function Account:balance ()
    return balance[self]
end

function Account:new(o)
    o = o or {}	-- create table if user does not provide one
    setmetatable(o, self)
    self.__index = self
    balance[o] = 0	-- initial balance
    return o
end

We use this class just like any other one:

a = Account:new{}
a:deposit(100.00)
print(a:balance())

However, we cannot tamper with an account balance. By keeping the table balance private to the module, this implementation ensures its safety.

Inheritance works without modifications. This approach has a cost quite similar to the standard one, both in terms of time and of memory. 
New objects need one new table and one new entry in each private table being used. The access balance[self] can be slightly slower than self.balance, 
because the latter uses a local variable while the first uses an external variable. Usually this difference is negligible. 
As we will see later, it also demands some extra work from the garbage collector.

Chapter 22. The Environment
Global variables are a necessary evil of most programming languages. On one hand, the use of global variables can easily lead to complex code, entangling apparently unrelated parts of a program. 
On the other hand, the judicious use of global variables can better express truly global aspects of a program; moreover, global constants are innocuous, 
but dynamic languages like Lua have no way to distinguish constants from variables. An embedded language like Lua adds another ingredient to this mix: 
a global variable is a variable that is visible in the whole program, but Lua has no clear concept of a program, having instead pieces of code (chunks) called by the host application.

Lua solves this conundrum by not having global variables, but going to great lengths to pretend it has. 
In a first approximation, we can think that Lua keeps all its global variables in a regular table, called the global environment. 
Later in this chapter, we will see that Lua can keep its “global” variables in several environments. For now, we will stick to that first approximation.

The use of a table to store global variables simplifies the internal implementation of Lua, because there is no need for a different data structure for global variables. 
Another advantage is that we can manipulate this table like any other table. To help such manipulations, Lua stores the global environment itself in the global variable _G. 
(As a result, _G._G is equal to _G.) For instance, the following code prints the names of all the variables defined in the global environment:

for n in pairs(_G) do
    print(n)
end

Global Variables with Dynamic Names
Usually, assignment is enough for accessing and setting global variables. However, sometimes we need some form of meta-programming, 
such as when we need to manipulate a global variable whose name is stored in another variable or is somehow computed at run time. 
To get the value of such a variable, some programmers are tempted to write something like this:

value = load("return " .. varname)()

If varname is x, for example, the concatenation will result in "return x", which when run achieves the desired result. 
However, this code involves the creation and compilation of a new chunk, which is somewhat expensive. 
We can accomplish the same effect with the following code, which is more than an order of magnitude more efficient than the previous one:

value = _G[varname]
Because the environment is a regular table, we can simply index it with the desired key (the variable name). 
In a similar way, we can assign a value to a global variable whose name is computed dynamically by writing _G[varname] = value. 
Beware, however some programmers get a little excited with these facilities and end up writing code like _G["a"] = _G["b"], which is just a complicated way to write a = b.

A generalization of the previous problem is to allow fields in the dynamic name, such as "io.read" or "a.b.c.d". If we write _G["io.read"], clearly we will not get the field read from the table io. 
But we can write a function getfield such that getfield("io.read") returns the expected result. This function is mainly a loop, which starts at _G and evolves field by field:

function getfield(f)
    local v = _G	-- start with the table of globals
    for w in string.gmatch(f, "[%a_][%w_]*") do
        v = v[w]
    end
    return v
end

We rely on gmatch to iterate over all identifiers in f.

The corresponding function to set fields is a little more complex. An assignment like a.b.c.d = v is equivalent to the following code:

local temp = a.b.c
temp.d = v

That is, we must retrieve up to the last name and then handle this last name separately. 

function setfield(f, v)
    local t = _G
    for w, d in string.gmatch(f, "([%a_][%w_]*)(%.?)") do
        if d == "." then
            t[w] = t[w] or {}
            t = t[w]
        else
            t[w] = v
        end
    end
end

The pattern there captures the field name in the variable w and an optional following dot in the variable d. If a field name is not followed by a dot, then it is the last name.

With the previous functions in place, the next call creates a global table t, another table t.x, and assigns 10 to t.x.y:

setfield("t.x.y", 10)

print(t.x.y)	--> 10
print(getfield("t.x.y"))	--> 10

Global-Variable Declarations
Global variables in Lua do not need declarations. Although this behavior is handy for small programs,  in larger programs a simple typo can cause bugs that are difficult to find. 
However, we can change this behavior if we like. Because Lua keeps its global variables in a regular table, we can use metatables to detect when Lua accesses non-existent variables.

A first approach simply detects any access to absent keys in the global table:

setmetatable(_G, {
    __newindex = function (_, n)
        error("attempt to write to undeclared variable " .. n, 2)
    end,
    __index = function (_, n)
        error("attempt to read undeclared variable " .. n, 2)
    end,
})

After this code, any attempt to access a non-existent global variable will trigger an error:

> print(a)
stdin:1: attempt to read undeclared variable a

But how do we declare new variables? One option is to use rawset, which bypasses the metamethod:

function declare (name, initval)
    rawset(_G, name, initval or false)
end

(The or with false ensures that the new global always gets a value different from nil.)

A simpler option is to restrict assignments to new global variables only inside functions, allowing free assignments in the outer level of a chunk.

To check whether an assignment is in the main chunk, we must use the debug library. 
The call debug.getinfo(2, "S") returns a table whose field what tells whether the function that called the metamethod is a main chunk, a regular Lua function, or a C function. 
(We will see debug.getinfo in more detail in the section called “Introspective Facilities”.) 
Using this function, we can rewrite the __newindex metamethod like this:

__newindex = function(t, n, v)
    local w = debug.getinfo(2, "S").what
    if w ~= "main" and w ~= "C" then
　    error("attempt to write to undeclared variable " .. n, 2)
    end
　rawset(t, n, v)
end

This new version also accepts assignments from C code, as this kind of code usually knows what it is doing.

If we need to test whether a variable exists, we cannot simply compare it to nil because, if it is nil, the access will raise an error. 
Instead, we use rawget, which avoids the metamethod:

if rawget(_G, var) == nil then
-- 'var' is undeclared
...
end

As it is, our scheme does not allow global variables with nil values, as they would be automatically considered undeclared.
 But it is not difficult to correct this problem. All we need is an auxiliary table that keeps the names of declared variables. 
Whenever a metamethod is called, it checks in this table whether the variable is undeclared. The code can be like the one in Figure 22.2, “Checking global-variable declaration”.


Figure 22.2. Checking global-variable declaration
local declaredNames = {}

setmetatable(_G, {
    __newindex = function (t, n, v)
        if not declaredNames[n] then
            local w = debug.getinfo(2, "S").what
            if w ~= "main" and w ~= "C" then
　            error("attempt to write to undeclared variable "..n, 2)
            end
　        declaredNames[n] = true
        end
　    rawset(t, n, v)
    end, 
    __index = function (_, n)
        if not declaredNames[n] then
　        error("attempt to read undeclared variable "..n, 2)
        else
　        return nil
        end
    end,
})
Now, even an assignment like x = nil is enough to declare a global variable.
The overhead for both solutions is negligible. With the first solution, the metamethods are never called during normal operation. 
In the second, they can be called, but only when the program accesses a variable holding a nil.
The Lua distribution comes with a module strict.lua that implements a global-variable check that uses essentially the code in Figure 22.2, “Checking global-variable declaration”. 
It is a good habit to use it when developing Lua code.
Non-Global Environments
In Lua, global variables do not need to be truly global. As I already hinted, Lua does not even have global variables. That may sound strange at first, as we have been using global variables all along this text. 
As  I said, Lua goes to great lengths to give the programmer an illusion of global variables. Now we will see how Lua builds this illusion.
First, let us forget about global variables. Instead, we will start with the concept of free names. A free name is a name that is not bound to an explicit declaration, that is, 
it does not occur inside the scope of a corresponding local variable. For instance, both x and y are free names in the following chunk, but z is not:
local z = 10
x = y + z
Now comes the important part: The Lua compiler translates any free name x in the chunk to _ENV.x. So, the previous chunk is fully equivalent to this one:

local z = 10
_ENV.x = _ENV.y + z

But what is this new _ENV variable?
_ENV cannot be a global variable; we just said that Lua has no global variables. Again, the compiler does the trick. 
I already mentioned that Lua treats any chunk as an anonymous function. Actually, Lua compiles our original chunk as the following code:

local _ENV = some value
return function (...)
    local z = 10
　_ENV.x = _ENV.y + z
end
That is, Lua compiles any chunk in the presence of a predefined upvalue (an external local variable) called _ENV. 
So, any variable is either local, if it is a bounded name, or a field in _ENV, which itself is a local variable (an upvalue).
The initial value for _ENV can be any table. (Actually, it does not need to be a table; more about that later.) Any such table is called an environment. 
To preserve the illusion of global variables, Lua keeps internally a table that it uses as a global environment. 
Usually, when we load a chunk, the function load initializes this predefined upvalue with that global environment. So, our original chunk becomes equivalent to this one:

local _ENV = the global environment
return function (...)
    local z = 10
　_ENV.x = _ENV.y + z
end
The result of all these arrangements is that the x field of the global environment gets the value of the y field plus 10.
At first sight, this may seem a rather convoluted way to manipulate global variables. I will not argue that it is the simplest way, but it offers a flexibility that is difficult to achieve with a simpler implementation.
Before we go on, let us summarize the handling of global variables in Lua:
The compiler creates a local variable _ENV outside any chunk that it compiles.
The compiler translates any free name var to _ENV.var.
The function load (or loadfile) initializes the first upvalue of a chunk with the global environment, which is a regular table kept internally by Lua.
After all, it is not that complicated.
Some people get confused because they try to infer extra magic from these rules. There is no extra magic. In particular, the first two rules are done entirely by the compiler. 
Except for being predefined by the compiler, _ENV is a plain regular variable. Outside the compiler, the name _ENV has no special meaning at all to Lua. 
Similarly, the translation from x to _ENV.x is a plain syntactic translation, with no hidden meanings. 
In particular, after the translation, _ENV will refer to whatever _ENV variable is visible at that point in the code, following the standard visibility rules.
Using _ENV
In this section, we will see some ways to explore the flexibility brought by _ENV. Keep in mind that we must run most examples in this section as a single chunk. 
If we enter code line by line in interactive mode, each line becomes a different chunk and therefore each will have a distinct _ENV variable. 
To run a piece of code as a single chunk, we can either run it from a file or enclose it in a do--end block.

Because _ENV is a regular variable, we can assign to and access it as any other variable. The assignment _ENV = nil will invalidate any direct access to global variables in the rest of the chunk. 
This can be useful to control what variables our code uses:

local print, sin = print, math.sin
_ENV = nil
print(13)	--> 13
print(sin(13))	--> 0.42016703682664
print(math.cos(13))	-- error!
Any assignment to a free name (a “global variable”) will raise a similar error. We can write the _ENV explicitly to bypass a local declaration:
a = 13	-- global
local a = 12
print(a)	--> 12	(local)
print(_ENV.a)	--> 13	(global)
We can do the same with _G:
a = 13	-- global
local a = 12
print(a)		--> 12	(local)
print(_G.a)	--> 13	(global)
Usually, _G and _ENV refer to the same table but, despite that, they are quite different entities. _ENV is a local variable, and all accesses to “global variables” in reality are accesses to it. 
_G is a global variable with no special status whatsoever. By definition, _ENV always refers to the current environment; _G usually refers to the global environment, provided it is visible and no one changed its value.

The main use for _ENV is to change the environment used by a piece of code. Once we change the environment, all global accesses will use the new table:

-- change current environment to a new empty table
_ENV = {}
a = 1	-- create a field in _ENV
print(a)
--> stdin:4: attempt to call global 'print' (a nil value)
If the new environment is empty, we have lost all our global variables, including print. So, we should first populate it with some useful values, for instance with the global environment:

a = 15	-- create a global variable
_ENV = {g = _G}	-- change current environment
a = 1	-- create a field in _ENV
g.print(_ENV.a, g.a)	--> 1	15
Now, when we access the “global” g (which lives in _ENV, not in the global environment) we get the global environment, wherein Lua will find the function print.
We can rewrite the previous example using the name _G instead of g:
a = 15	-- create a global variable
_ENV = {_G = _G}	-- change current environment
a = 1	-- create a field in _ENV
_G.print(_ENV.a, _G.a)	--> 1	15
The only special status of _G happens when Lua creates the initial global table and makes its field _G points to itself. Lua does not care about the current value of this variable. 
Nevertheless, it is customary to use this same name whenever we have a reference to the global environment, as we did in the rewritten example.

Another way to populate our new environment is with inheritance:

a = 1
local newgt = {}	-- create new environment
setmetatable(newgt, { __index = _G})
_ENV = newgt	-- set it
print(a)	--> 1
In this code, the new environment inherits both print and a from the global one. However, any assignment goes to the new table. 
There is no danger of changing a variable in the global environment by mistake, although we still can change them through _G:
-- continuing the previous chunk
a = 10
print(a, _G.a)	--> 10	1
_G.a = 20
print(_G.a)	--> 20
Being a regular variable, _ENV follows the usual scoping rules. In particular, functions defined inside a chunk access _ENV as they access any other external variable:
_ENV = {_G = _G}
local function foo ()
    _G.print(a)	-- compiled as '_ENV._G.print(_ENV.a)'
end
a = 10
foo()	--> 10
_ENV = {_G = _G, a = 20}
foo()	--> 20
If we define a new local variable called _ENV, references to free names will bind to that new variable:
a = 2
do
    local _ENV = {print = print, a = 14}
    print(a)	--> 14
end
print(a)	--> 2	(back to the original _ENV)
Therefore, it is not difficult to define a function with a private environment:

function factory (_ENV)
    return function ()
        return a
    end
end

f1 = factory{a = 6}
f2 = factory{a = 7}
print(f1())	--> 6
print(f2())	--> 7

The factory function creates simple closures that return the value of their “global” a. When the closure is created, its visible _ENV variable is the parameter _ENV of the enclosing factory function; 
therefore, each closure will use its own external variable (as an upvalue) to access its free names.

Using the usual scoping rules, we can manipulate environments in several other ways. For instance, we may have several functions sharing a common environment, or a function that changes the environment that it shares with other functions.
Environments and Modules
In the section called “The Basic Approach for Writing Modules in Lua”, when we discussed how to write modules, I mentioned that one drawback of those methods was that it was all too easy to pollute the global space, 
for instance by forgetting a local in a private declaration. Environments offer an interesting technique for solving that problem. 
Once the module main chunk has an exclusive environment, not only all its functions share this table, but also all its global variables go to this table. 
We can declare all public functions as global variables and they will go to a separate table automatically. All the module has to do is to assign this table to the _ENV variable. 
After that, when we declare a function add, it goes to M.add:
local M = {}
_ENV = M
function add (c1, c2)
    return new(c1.r + c2.r, c1.i + c2.i)
end
Moreover, we can call other functions from the same module without any prefix. In the previous code, add gets new from its environment, that is, it calls M.new.
This method offers a good support for modules, with little extra work for the programmer. It needs no prefixes at all. 
There is no difference between calling an exported function and a private one. If the programmer forgets a local, he does not pollute the global namespace; 
instead, a private function simply becomes public.

Nevertheless, currently I still prefer the original basic method. It may need more work, but the resulting code states clearly what it does. 
To avoid creating a global by mistake, I use the simple method of assigning nil to _ENV. After that, any assignment to a global name will raise an error. 
This approach has the extra advantage that it works without changes in older versions of Lua. 
(In Lua 5.1, the assignment to _ENV will not prevent errors, but it will not cause any harm, either.)

To access other modules, we can use one of the methods we discussed in the previous section. For instance, we can declare a local variable that holds the global environment:

local M = {}
local _G = _G
_ENV = nil
We then prefix global names with _G and module names with M.
A more disciplined approach is to declare as locals only the functions we need or, at most, the modules we need:

-- module setup
local M = {}

-- Import Section:
-- declare everything this module needs from outside
local sqrt = math.sqrt
local io = io

-- no more external access after this point
_ENV = nil
This technique demands more work, but it documents the module dependencies better.
_ENV and load
As I mentioned earlier, load usually initializes the _ENV upvalue of a loaded chunk with the global environment. 
However, load has an optional fourth parameter that allows us to give a different initial value for _ENV. (The function loadfile has a similar parameter.)
For an initial example, consider that we have a typical configuration file, defining several constants and functions to be used by a program; it can be something like this:

-- file 'config.lua'
width = 200
height = 300
...
We can load it with the following code:

env = {}
loadfile("config.lua", "t", env)()
The whole code in the configuration file will run in the empty environment env, which works as a kind of sandbox. 
In particular, all definitions will go into this environment. The configuration file has no way to affect anything else, even by mistake. 
Even malicious code cannot do much damage. It can do a denial of service (DoS) attack, by wasting CPU time and memory, but nothing else.
Sometimes, we may want to run a chunk several times, each time with a different environment table. In that case, the extra argument to load is not useful. 
Instead, we have two other options.The first option is to use the function debug.setupvalue, from the debug library. As its name implies,
setupvalue allows us to change any upvalue of a given function. The next fragment illustrates its use:
f = load("b = 10; return a")
env = {a = 20}
debug.setupvalue(f, 1, env)
print(f())	--> 20
print(env.b)	--> 10
The first argument in the call to setupvalue is the function, the second is the upvalue index, and the third is the new value for the upvalue. 
For this kind of use, the second argument is always one: when a function represents a chunk, Lua assures that it has only one upvalue and that this upvalue is _ENV.
A small drawback of this option is its dependence on the debug library. This library breaks some usual assumptions about programs. 
For instance, debug.setupvalue breaks Lua's visibility rules, which ensures that we cannot access a local variable from outside its lexical scope.
Another option to run a chunk with several different environments is to twist the chunk a little when loading it. Imagine that we add the following line just before the chunk:

_ENV = ...;
Remember that Lua compiles any chunk as a variadic function. So, that extra line of code will assign to the _ENV variable the first argument passed to the chunk, 
thereby setting that argument as the environment. The following code snippet illustrates the idea, using the function loadwithprefix that you implemented in Exercise 16.1:

prefix = "_ENV = ...;"
f = loadwithprefix(prefix, io.lines(filename, "*L"))
...
env1 = {}
f(env1)
env2 = {}
f(env2)

Chapter 23. Garbage

Weak Tables
As we said, a garbage collector cannot guess what we consider garbage. A typical example is a stack,  implemented with an array and an index to the top. 
We know that the valid part of the array goes only up to the top, but Lua does not. If we pop an element by simply decrementing the top, 
the object left in the array is not garbage to Lua. Similarly, any object stored in a global variable is not garbage to Lua, even if our program will never use it again. 
In both cases, it is up to us (i.e., our program) to assign nil to these positions so that they do not lock an otherwise disposable object.

However, simply cleaning our references is not always enough. Some constructions need extra collaboration between the program and the collector. 
A typical example happens when we want to keep a list of all live objects of some kind (e.g., files) in our program. 
This task seems simple: all we have to do is to insert each new object into the list. However, once the object is part of the list, it will never be collected! 
Even if nothing else points to it, the list does. Lua cannot know that this reference should not prevent the reclamation of the object, unless we tell Lua about this fact.

Weak tables are the mechanism that we use to tell Lua that a reference should not prevent the reclamation of an object. 
A weak reference is a reference to an object that is not considered by the garbage collector. 
If all references pointing to an object are weak, the collector will collect the object and delete these weak references. 
Lua implements weak references through weak tables: a weak table is a table whose entries are weak. This means that, if an object is held only in weak tables, Lua will eventually collect the object.

Tables have keys and values, and both can contain any kind of object. Under normal circumstances, the garbage collector does not collect objects that appear as keys or as values of an accessible table. 
That is, both keys and values are strong references, as they prevent the reclamation of objects they refer to. In a weak table, both keys and values can be weak. 
This means that there are three kinds of weak tables: tables with weak keys, tables with weak values, and tables where both keys and values are weak. 
Irrespective of the kind of table, when a key or a value is collected the whole entry disappears from the table.

The weakness of a table is given by the field __mode of its metatable. The value of this field, when  present, should be a string: 
if this string is "k", the keys in the table are weak; if this string is "v", the values in the table are weak; if this string is "kv", both keys and values are weak. 
The following example, although artificial, illustrates the basic behavior of weak tables:

a = {}
mt = { __mode = "k"}
setmetatable(a, mt)	-- now 'a' has weak keys
key = {}	-- creates first key
a[key] = 1
key = {}	-- creates second key
a[key] = 2
collectgarbage()	-- forces a garbage collection cycle
for k, v in pairs(a) do
    print(v)
end
--> 2
In this example, the second assignment key = {} overwrites the reference to the first key. The call to collectgarbage forces the garbage collector to do a full collection. 
As there is no other reference to the first key, Lua collects this key and removes the corresponding entry in the table. 
The second key, however, is still anchored in the variable key, so Lua does not collect it.
Notice that only objects can be removed from a weak table. Values, such as numbers and Booleans, are not collectible. 
For instance, if we insert a numeric key in the table a (from our previous example), the collector will never remove it. 
Of course, if the value corresponding to a numeric key is collected in a table with weak values, then the whole entry is removed from the table.
Strings present a subtlety here: although strings are collectible from an implementation point of view, they are not like other collectible objects. 
Other objects, such as tables and closures, are created explicitly. For instance, whenever Lua evaluates the expression {}, it creates a new table. 
However, does Lua create a new string when it evaluates "a".."b"? What if there is already a string "ab" in the system? Does Lua create a new one? Can the compiler create this string before running the program? 
It does not matter: these are implementation details. From the programmer's point of view, strings are values, not objects. 
Therefore, like a number or a Boolean, a string key is not removed from a weak table unless its associated value is collected.
Memorize Functions
A common programming technique is to trade space for time. We can speed up a function by memorizing its results so that, later, when we call the function with the same argument, the function can reuse that result.
Imagine a generic server that takes requests in the form of strings with Lua code. Each time it gets a request, it runs load on the string, and then calls the resulting function. 
However, load is an expensive function, and some commands to the server may be quite frequent. Instead of calling load repeatedly each time it receives a common command like "closeconnection()", 
the server can memorize the results from load using an auxiliary table. Before calling load, the server checks in the table whether the given string already has a translation. 
If it cannot find a match, then (and only then) the server calls load and stores the result into the table. We can pack this behavior in a new function:

local results = {}
function mem_loadstring(s)
    local res = results[s]
    if res == nil then
        res = assert(load(s))
　    results[s] = res
    end
　return res
end

The savings with this scheme can be huge. However, it may also cause unsuspected waste. Although some commands repeat over and over, 
many other commands happen only once. Gradually, the table results accumulates all commands the server has ever received plus their respective codes; 
after enough time, this behavior will exhaust the server's memory.

A weak table provides a simple solution to this problem. If the results table has weak values, each garbage-collection cycle will remove all translations not in use at that moment (which means virtually all of them):

local results = {}
setmetatable(results, { __mode = "v"})	-- make values weak
function mem_loadstring(s)
    local res = results[s]
    if res == nil then
        res = assert(load(s))
　    results[s] = res
    end
　return res
end

Actually, because the indices are always strings, we can make this table fully weak, if we want:

setmetatable(results, { mode = "kv"})
The net result is the same.

The memorization technique is useful also to ensure the uniqueness of some kind of object. For instance, assume a system that represents colors as tables, 
with fields red, green, and blue in some range. A naive color factory generates a new color for each new request:

function createRGB (r, g, b)
    return {red = r, green = g, blue = b}
end
Using memorization, we can reuse the same table for the same color. To create a unique key for each color, we simply concatenate the color indices with a separator in between:

local results = {}
setmetatable(results, { __mode = "v"})	-- make values weak 
function createRGB(r, g, b)
    local key = string.format("%d-%d-%d", r, g, b)
    local color = results[key]
    if color == nil then
        color = {red = r, green = g, blue = b}
        results[key] = color
    end
　return color
end
An interesting consequence of this implementation is that the user can compare colors using the primitive equality operator, because two coexistent equal colors are always represented by the same table. 
Any given color can be represented by different tables at different times, because from time to time the garbage collector clears the results table. 
However, as long as a given color is in use, it is not removed from results. So, whenever a color survives long enough to be compared with a new one, its representation also has survived long enough to be reused by the new color.
Object Attributes
Another important use of weak tables is to associate attributes with objects. There are endless situations where we need to attach some attribute to an object: 
names to functions, default values to tables, sizes  to arrays, and so on.
When the object is a table, we can store the attribute in the table itself, with an appropriate unique key. (As we saw before, a simple and error-proof way to create a unique key is to create a new table and use it as the key.) 
However, if the object is not a table, it cannot keep its own attributes. Even for tables, sometimes we may not want to store the attribute in the original object. 
For instance, we may want to keep the attribute private, or we do not want the attribute to disturb a table traversal. In all these cases, we need an alternative way to map attributes to objects.
Of course, an external table provides an ideal way to map attributes to objects. It is what we called a dual representation in the section called “Dual Representation”. 
We use the objects as keys, and their attributes as values. An external table can keep attributes of any type of object, as Lua allows us to use any type  of object as a key. 
Moreover, attributes kept in an external table do not interfere with other objects, and can be as private as the table itself.
However, this seemingly perfect solution has a huge drawback: once we use an object as a key in a table, we lock the object into existence. 
Lua cannot collect an object that is being used as a key. For instance, if we use a regular table to map functions to its names, none of these functions will ever be collected.  
As you might expect, we can avoid this drawback by using a weak table. This time, however, we need weak keys. The use of weak keys does not prevent any key from being collected, 
once there are no other references to it. On the other hand, the table cannot have weak values; otherwise, attributes of live objects could be collected.
Revisiting Tables with Default Values
In the section called “Tables with default values”, we discussed how to implement tables with non-nil default values. 
We saw one particular technique and commented that two other techniques needed weak tables, so we postponed them. 
Now it is time to revisit the subject. As we will see, these two techniques for default values are actually particular applications of the two general techniques that we have just discussed: dual representation and memorization.
In the first solution, we use a weak table to map each table to its default value:

local defaults = {}
setmetatable(defaults, { __mode = "k"})
local mt = { __index = function (t) return defaults[t] end}
function setDefault(t, d)
    defaults[t] = d
    setmetatable(t, mt)
end
This is a typical use of a dual representation, where we use defaults[t] to represent t.default. If the table defaults did not have weak keys, it would anchor all tables with default values into permanent existence.
In the second solution, we use distinct metatables for distinct default values, but we reuse the same metatable whenever we repeat a default value. 
This is a typical use of memorization:

local metas = {}
setmetatable(metas, { __mode = "v"})
function setDefault(t, d)
    local mt = metas[d]
    if mt == nil then
        mt = { __index = function () return d end}
        metas[d] = mt	-- memorize
    end
    setmetatable(t, mt)
end
In this case, we use weak values to allow the collection of metatables that are not being used anymore.
Given these two implementations for default values, which is best? As usual, it depends. Both have similar complexity and similar performance. 
The first implementation needs a few memory words for each table with a default value (an entry in defaults). 
The second implementation needs a few dozen memory words for each distinct default value (a new table, a new closure, plus an entry in the table metas). 
So, if your application has thousands of tables with a few distinct default values, the second implementation is clearly superior. 
On the other hand, if few tables share common defaults, then you should favor the first implementation.
Ephemeron Tables
A tricky situation occurs when, in a table with weak keys, a value refers to its own key.
This scenario is more common than it may seem. As a typical example, consider a constant-function factory. Such a factory takes an object and returns a function that, whenever called, returns that object:

function factory(o)
    return (function () return o end)
end
This factory is a good candidate for memorization, to avoid the creation of a new closure when there is one already available. 

do
    local mem = {}	-- memorization table
    setmetatable(mem, { __mode = "k"})
    function factory(o)
        local res = mem[o]
        if not res then
            res = (function () return o end)
            mem[o] = res
        end
　    return res
    end
end
There is a catch, however. Note that the value (the constant function) associated with an object in mem refers back to its own key (the object itself). 
Although the keys in that table are weak, the values are not. From a standard interpretation of weak tables, nothing would ever be removed from that memorizing table. 
Because values are not weak, there is always a strong reference to each function. Each function refers to its corresponding object, so there is always a strong reference to each key. 
Therefore, these objects would not be collected, despite the weak keys.
This strict interpretation, however, is not very useful. Most people expect that a value in a table is only accessible through its respective key. 
We can think of the above scenario as a kind of cycle, where the closure refers to the object that refers back (through the memorizing table) to the closure.
Lua solves the above problem with the concept of ephemeron tables. In Lua, a table with weak keys  and strong values is an ephemeron table. 
In an ephemeron table, the accessibility of a key controls the accessibility of its corresponding value. More specifically, consider an entry (k,v) in an ephemeron table. 
The reference to v is only strong if there is some other external reference to k. Otherwise, the collector will eventually collect k and remove the entry from the table, 
even if v refers (directly or indirectly) to k.
Finalizers
Although the goal of the garbage collector is to collect Lua objects, it can also help programs to release external resources. 
For that purpose, several programming languages offer finalizers. A finalizer is a function associated with an object that is called when that object is about to be collected.

Lua implements finalizers through the metamethod __gc, as the following example illustrates:
o = {x = "hi"}
setmetatable(o, { __gc = function (o) print(o.x) end})
o = nil
collectgarbage()	--> hi

In this example, we first create a table and give it a metatable that has a __gc metamethod. Then we  erase the only link to the table (the global variable o) and force a complete garbage collection. 
During the collection, Lua detects that the table is no longer accessible, and therefore calls its finalizer —the gc metamethod.

A subtlety of finalizers in Lua is the concept of marking an object for finalization. We mark an object for finalization by setting a metatable for it with a non-null   gc metamethod. 
If we do not mark the object, it will not be finalized. Most code we write works naturally, but some strange cases can occur, like here:

o = {x = "hi"}
mt = {}
setmetatable(o, mt)
mt.__gc = function (o)
    print(o.x)
end
o = nil
collectgarbage()	--> (prints nothing)

Here, the metatable we set for o does not have a __gc metamethod, so the object is not marked for finalization. 
Even if we later add a gc field to the metatable, Lua does not detect that assignment as something special, so it will not mark the object.

As we said, this is seldom a problem; it is not usual to change metamethods after setting a metatable. If you really need to set the metamethod later, 
you can provide any value for the __gc field, as a placeholder:
o = {x = "hi"}
mt = { __gc = true}
setmetatable(o, mt)
mt.__gc = function (o)
    print(o.x)
end
o = nil
collectgarbage()	--> hi

Now, because the metatable has a __gc field, o is properly marked for finalization. There is no problem if you do not set a metamethod later; 
Lua only calls the finalizer if it is a proper function.

When the collector finalizes several objects in the same cycle, it calls their finalizers in the reverse order that the objects were marked for finalization. 
Consider the next example, which creates a linked list of objects with finalizers:

mt = { __gc = function (o) print(o[1]) end}

list = nil
for i = 1, 3 do
    list = setmetatable({i, link = list}, mt)
end
list = nil
collectgarbage()
--> 3
--> 2
--> 1
The first object to be finalized is object 3, which was the last to be marked.

A common misconception is to think that links among objects being collected can affect the order that they are finalized. 
For instance, one can think that object 2 in the previous example must be finalized before object 1 because there is a link from 2 to 1. 
However, links can form cycles. Therefore, they do not impose any order to finalizers.
Another tricky point about finalizers is resurrection. When a finalizer is called, it gets the object being finalized as a parameter. 
So, the object becomes alive again, at least during the finalization. I call this a transient resurrection. 
While the finalizer runs, nothing stops it from storing the object in a global variable, for instance, so that it remains accessible after the finalizer returns. I call this a permanent resurrection.
Resurrection must be transitive. Consider the following piece of code:

A = {x = "this is A"}
B = {f = A}
setmetatable(B, { __gc = function (o) print(o.f.x) end})
A, B = nil
collectgarbage()	--> this is A
The finalizer for B accesses A, so A cannot be collected before the finalization of B. Lua must resurrect both B and A before running that finalizer.
Because of resurrection, Lua collects objects with finalizers in two phases. The first time the collector detects that an object with a finalizer is not reachable, 
the collector resurrects the object and queues it to be finalized. Once its finalizer runs, Lua marks the object as finalized. 
The next time the collector detects that the object is not reachable, it deletes the object. If we want to ensure that all garbage in our program has been actually released, 
we must call collectgarbage twice; the second call will delete the objects that were finalized during the first call.
The finalizer for each object runs exactly once, due to the mark that Lua puts on finalized objects. If an object is not collected until the end of a program, 
Lua will call its finalizer when the entire  Lua state     is closed. This last feature allows a form of atexit functions in Lua, that is, functions that will run immediately before the program terminates. 
All we have to do is to create a table with a finalizer and anchor it somewhere, for instance in a global variable:

local t = { __gc = function ()
    -- your 'atexit' code comes here
    print("finishing Lua program")
    end}
setmetatable(t, t)
_G["*AA*"] = t
Another interesting technique allows a program to call a given function every time Lua completes a collection cycle. 
As a finalizer runs only once, the trick here is to make each finalization create a new object to run the next finalizer.

do
    local mt = { __gc = function (o)
        -- whatever you want to do
        print("new cycle")
        -- creates new object for next cycle
        setmetatable({}, getmetatable(o))
    end}
    -- creates first object
    setmetatable({}, mt)
end

collectgarbage() --> new cycle
collectgarbage() --> new cycle
collectgarbage() --> new cycle
The interaction of objects with finalizers and weak tables also has a subtlety. At each cycle, the collector clears the values in weak tables before calling the finalizers, 
but it clears the keys after it. The rationale for this behavior is that frequently we use tables with weak keys to hold properties of an object 
(as we discussed in the section called “Object Attributes”), and therefore finalizers may need to access those attributes. 
However, we use tables with weak values to reuse live objects; in this case, objects being finalized are not useful anymore.
The Garbage Collector
Up to version 5.0, Lua used a simple mark-and-sweep garbage collector (GC). This kind of collector is sometimes called a “stop-the-world” collector. 
This means that, from time to time, Lua would stop running the main program to perform a whole garbage-collection cycle. 
Each cycle comprises four phases: mark, cleaning, sweep, and finalization.
The collector starts the mark phase by marking as alive its root set, which comprises the objects that Lua has direct access to. 
In Lua, this set is only the C registry. (As we will see in the section called “The registry”, both the main thread and the global environment are predefined entries in this registry.)
Any object stored in a live object is reachable by the program, and therefore is marked as alive too. (Of course, entries in weak tables do not follow this rule.) 
The mark phase ends when all reachable objects are marked as alive.
Before starting the sweep phase, Lua performs the cleaning phase, where it handles finalizers and weak tables. 
First, it traverses all objects marked for finalization looking for non-marked objects. Those objects are marked as alive (resurrected) and put in a separate list, to be used in the finalization phase. 
Then, Lua traverses its weak tables and removes from them all entries wherein either the key or the value is not marked.
The sweep phase traverses all Lua objects. (To allow this traversal, Lua keeps all objects it creates in a linked list.) If an object is not marked as alive, Lua collects it. 
Otherwise, Lua clears its mark, in preparation for the next cycle.
Finally, in the finalization phase, Lua calls the finalizers of the objects that were separated in the cleaning phase.
The use of a real garbage collector means that Lua has no problems with cycles among object references. We do not need to take any special action when using cyclic data structures; they are collected like any other data.

In version 5.1, Lua got an incremental collector. This collector performs the same steps as the old one, but it does not need to stop the world while it runs. Instead, it runs interleaved with the interpreter. 
Every time the interpreter allocates some amount of memory, the collector runs a small step. (This means that, while the collector is working, the interpreter may change an object's reachability. 
To ensure the correctness of the collector, some operations in the interpreter have barriers that detect dangerous changes and correct the marks of the objects involved.)

Lua 5.2 introduced emergency collection. When a memory allocation fails, Lua forces a full collection cycle and tries again the allocation. 
These emergencies can occur any time Lua allocates memory, including points where Lua is not in a consistent state to run code; so, these collections are unable to run finalizers.

Controlling the Pace of Collection
The function collectgarbage allows us to exert some control over the garbage collector. It is actually several functions in one: 
its optional first argument, a string, specifies what to do. Some options have an integer as a second argument, which we call data.
The options for the first argument are:

"stop":		stops the collector until another call to collectgarbage with the option "restart". 
"restart":	restarts the collector.
"collect":	performs a complete garbage-collection cycle, so that all unreachable objects are collected and finalized. This is the default option.
"step":		performs some garbage-collection work. The second argument, data, specifies the amount of work, 
		which is equivalent to what the collector would do after allocating data bytes.
"count":		returns the number of kilobytes of memory currently in use by Lua. This result is a floating-point number that multiplied by 1024 gives the exact total number of bytes. 
		The count includes dead objects that have not yet been collected.
"setpause": 	sets the collector's pause parameter. The data parameter gives the new value in percentage points: when data is 100, the parameter is set to 1 (100%).
"setstepmul":  	sets the collector's step multiplier (stepmul) parameter. The new value is given   by data, also in percentage points.
The two parameters pause and stepmul control the collector's character. Any garbage collector trades memory for CPU time. 
At one extreme, the collector might not run at all. It would spend zero CPU time, at the price of a huge memory consumption. 
At the other extreme, the collector might run a complete cycle after every single assignment. 
The program would use the minimum memory necessary, at the price of   a huge CPU consumption. 
The default values for pause and stepmul try to find a balance between those two extremes and are good enough for most applications. 
In some scenarios, however, it is worth trying to optimize them.

The pause parameter controls how long the collector waits between finishing a collection and starting a new one. 
A pause of zero makes Lua start a new collection as soon as the previous one ends. A pause of 200% waits for memory usage to double before restarting the collector. 
We can set a lower pause if we want to trade more CPU time for lower memory usage. Typically, we should keep this value between 0 and 200%.

The step-multiplier parameter (stepmul) controls how much work the collector does for each kilobyte of memory allocated. 
The higher this value the less incremental the collector. A huge value like 100000000% makes the collector work like a non-incremental collector. 
The default value is 200%. Values lower than 100% make the collector so slow that it may never finish a collection.
The other options of collectgarbage give us control over when the collector runs. Again, the default control is good enough for most programs, 
but some specific applications may benefit from a manual  control. Games often need this kind of control. 
For instance, if we do not want any garbage-collection work during some periods, we can stop it with a call collectgarbage("stop") and then restart it with collectgarbage("restart"). 
In systems where we have periodic idle phases, we can keep the collector stopped and call collectgarbage("step", n) during the idle time. 
To set how much work to do at each idle period, we can either choose experimentally an appropriate value for n or call collectgarbage in a loop, with n set to zero (meaning minimal steps), until the idle period expires.

Chapter 24. Coroutines

A coroutine is similar to a thread (in the sense of multithreading): it is a line of execution, with its own stack, its own local variables, and its own instruction pointer; 
it shares global variables and mostly anything else with other coroutines. The main difference between threads and coroutines is that a multithreaded program runs several threads in parallel, 
while coroutines are collaborative: at any given time, a program with coroutines is running only one of its coroutines, and this running coroutine suspends its execution only when it explicitly requests to be suspended.

In this chapter we will cover how coroutines work in Lua and how we can use them to solve a diverse set of problems.

Coroutine Basics
Lua packs all its coroutine-related functions in the table coroutine. The function create creates new coroutines. 
It has a single argument, a function with the code that the coroutine will run (the coroutine body). It returns a value of type "thread", which represents the new coroutine. 
Often, the argument to create is an anonymous function, like here:

co = coroutine.create(function () print("hi") end)
print(type(co))	--> thread

A coroutine can be in one of four states: suspended, running, normal, and dead. We can check the state of a coroutine with the function coroutine.status:

print(coroutine.status(co))	--> suspended

When we create a coroutine, it starts in the suspended state; a coroutine does not run its body automatically when we create it. 
The function coroutine.resume (re)starts the execution of a coroutine, changing its state from suspended to running:

coroutine.resume(co)	--> hi

(If you run this code in interactive mode, you may want to finish the previous line with a semicolon, to suppress the display of the result from resume.) 
In this first example, the coroutine body simply prints "hi" and terminates, leaving the coroutine in the dead state:

print(coroutine.status(co))	--> dead

Until now, coroutines look like nothing more than a complicated way to call functions. The real power of coroutines stems from the function yield, 
which allows a running coroutine to suspend its own execution so that it can be resumed later. Let us see a simple example:

co = coroutine.create(function () 
    for i = 1, 10 do
        print("co", i)
        coroutine.yield()
　end
end)

Now, the coroutine body does a loop, printing numbers and yielding after each print. When we resume this coroutine, it starts its execution and runs until the first yield:

coroutine.resume(co)	--> co	1

If we check its status, we can see that the coroutine is suspended and, therefore, can be resumed:

print(coroutine.status(co))	--> suspended

From the coroutine's point of view, all activity that happens while it is suspended is happening inside   its call to yield. 
When we resume the coroutine, this call to yield finally returns and the coroutine continues its execution until the next yield or until its end:

coroutine.resume(co) --> co 2
coroutine.resume(co) --> co 3
...
coroutine.resume(co)	--> co	10
coroutine.resume(co)	
-- prints nothing

During the last call to resume, the coroutine body finishes the loop and then returns, without printing anything. 
If we try to resume it again, resume returns false plus an error message:

print(coroutine.resume(co))
--> false	cannot resume dead coroutine

Note that resume runs in protected mode, like pcall. Therefore, if there is any error inside a coroutine, Lua will not show the error message, 
but instead will return it to the resume call.

When a coroutine resumes another, it is not suspended; after all, we cannot resume it. However, it is not running either, because the running coroutine is the other one. 
So, its own status is what we call the normal state.

A useful facility in Lua is that a pair resume–yield can exchange data. The first resume, which has no corresponding yield waiting for it, passes its extra arguments to the coroutine main function:

co = coroutine.create(function (a, b, c) print("co", a, b, c + 2) end)
coroutine.resume(co, 1, 2, 3)	--> co	1	2	5

A call to coroutine.resume returns, after the true that signals no errors, any arguments passed to the corresponding yield:

co = coroutine.create(function (a,b) coroutine.yield(a + b, a - b) end)
print(coroutine.resume(co, 20, 10))	--> true	30	10

Symmetrically, coroutine.yield returns any extra arguments passed to the corresponding resume:


co = coroutine.create (function (x)
        print("co1", x)
        print("co2", coroutine.yield()
    end)
coroutine.resume(co, "hi")	--> co1	hi
coroutine.resume(co, 4, 5)	--> co2	4	5
Finally, when a coroutine ends, any values returned by its main function go to the corresponding resume:
co = coroutine.create(function ()
        return 6, 7
    end)
print(coroutine.resume(co))	--> true	6	7

We seldom use all these facilities in the same coroutine, but all of them have their uses.

Although the general concept of coroutines is well understood, the details vary considerably. So, for those that already know something about coroutines, 
it is important to clarify these details before we go on. Lua offers what we call asymmetric coroutines. 
This means that it has a function to suspend the execution of a coroutine and a different function to resume a suspended coroutine. 
Some other languages offer symmetric coroutines, where there is only one function to transfer control from one coroutine to another.

Some people call asymmetric coroutines semi-coroutines. However, other people use the same term semi-coroutine to denote a restricted implementation of coroutines, 
where a coroutine can suspend its execution only when it is not calling any function, that is, when it has no pending calls in its control stack. 
In other words, only the main body of such semi-coroutines can yield. (A generator in Python is an example of this meaning of semi-coroutines.)

Unlike the difference between symmetric and asymmetric coroutines, the difference between coroutines and generators (as presented in Python) is a deep one; 
generators are simply not powerful enough to implement some of the most interesting constructions that we can write with full coroutines. Lua offers full, asymmetric coroutines. 
Those that prefer symmetric coroutines can implement them on top of the asymmetric facilities of Lua (see Exercise 24.6).

Who Is the Boss?
One of the most paradigmatic examples of coroutines is the producer–consumer problem. Let us suppose that we have a function that continually produces values (e.g., reading them from a file) and another function that continually consumes these values (e.g., writing them to another file). 
These two functions could look like this:

function producer()
    while true do
        local x = io.read()	-- produce new value
        send(x)	-- send it to consumer
    end
end

function consumer()
    while true do
        local x = receive()	-- receive value from producer
        io.write(x, "\n")	-- consume it
    end
end

(To simplify this example, both the producer and the consumer run forever. It is not hard to change them to stop when there is no more data to handle.) 
The problem here is how to match send with receive. It is a typical instance of the “who-has-the-main-loop” problem. 
Both the producer and the consumer are active, both have their own main loops, and both assume that the other is a callable service. 
For this particular example, it is easy to change the structure of one of the functions, unrolling its loop and making it a passive agent. 
However, this change of structure may be far from easy in other real scenarios.

Coroutines provide an ideal tool to match producers and consumers without changing their structure, because a resume–yield pair turns upside-down the typical relationship between the caller and its callee. 
When a coroutine calls yield, it does not enter into a new function; instead, it returns a pending call (to resume). Similarly, a call to resume does not start a new function, but returns a call to yield. This property is exactly what we need to match a send with a receive in such a way that each one acts as if it were the master and the other the slave. (That is why I called this the "who-is-the-boss" problem.) 
So, receive resumes the producer, so that it can produce a new value; and send yields the new value back to the consumer:

function receive()
    local status, value = coroutine.resume(producer)
    return value
end

function send (x)
    coroutine.yield(x)
end

Of course, the producer must now run inside a coroutine:

producer = coroutine.create(producer)

In this design, the program starts by calling the consumer. When the consumer needs an item, it resumes the producer, which runs until it has an item to give to the consumer, 
and then stops until the consumer resumes it again. Therefore, we have what we call a consumer-driven design. Another way to write the program is to use a producer-driven design, where the consumer is the coroutine. 
Although the details seem reversed, the overall idea of both designs is the same.

We can extend this design with filters, which are tasks that sit between the producer and the consumer doing some kind of transformation in the data. 
A filter is a consumer and a producer at the same time,  so it resumes a producer to get new values and yields the transformed values to a consumer. 
As a trivial example, we can add to our previous code a filter that inserts a line number at the beginning of each line. T

function receive (prod)
    local status, value = coroutine.resume(prod)
    return value
end

function send (x)
    coroutine.yield(x)
end

function producer()
    return coroutine.create(function ()
        while true do
            local x = io.read()	-- produce new value
            send(x)
　    end
    end)
end

function filter(prod)
    return coroutine.create(function ()
        for line = 1, math.huge do
            local x = receive(prod)	-- get new value
            x = string.format("%5d %s", line, x)
            send(x)	-- send it to consumer
　    end
    end)
end

function consumer(prod)
    while true do
        local x = receive(prod)	-- get new value
        io.write(x, "\n")	-- consume new value
    end
end

consumer(filter(producer()))
Its last line simply creates the components it needs, connects them, and starts the final consumer.
If you thought about POSIX pipes after reading the previous example, you are not alone. After all, coroutines are a kind of (non-preemptive) multithreading. 
With pipes, each task runs in a separate process; with coroutines, each task runs in a separate coroutine. 
Pipes provide a buffer between the writer (producer) and the reader (consumer) so there is some freedom in their relative speeds. 
This is important in the context of pipes, because the cost of switching between processes is high. With coroutines, the cost of switching between tasks is much smaller (roughly equivalent to a function call), so the writer and the reader can run hand in hand.
Coroutines as Iterators
We can see loop iterators as a particular example of the producer–consumer pattern: an iterator produces items to be consumed by the loop body. 
Therefore, it seems appropriate to use coroutines to write iterators. Indeed, coroutines provide a powerful tool for this task. 
Again, the key feature is their ability to turn inside out the relationship between caller and callee. 
With this feature, we can write iterators without worrying about how to keep state between successive calls.
To illustrate this kind of use, let us write an iterator to traverse all permutations of a given array. It is not an easy task to write directly such an iterator, but it is not so difficult to write a recursive function that generates all these permutations. 
The idea is simple: put each array element in the last position, in turn, and recursively generate all permutations of the remaining elements. 

function permgen(a, n)
    n = n or #a	-- default for 'n' is size of 'a'
    if n <= 1 then	-- nothing to change?
　    printResult(a)
    else
        for i = 1, n do
            a[n], a[i] = a[i], a[n]
            permgen(a, n - 1)
            a[n], a[i] = a[i], a[n]
　    end
    end
end
To put it to work, we must define an appropriate printResult function and call permgen with proper arguments:

function printResult(a)
    for i = 1, #a do
        io.write(a[i], " ")
    end
    io.write("\n")
end

permgen ({1,2,3,4})
--> 2 3 4 1
--> 3 2 4 1
--> 3 4 2 1
...
--> 2 1 3 4
--> 1 2 3 4
After we have the generator ready, it is an automatic task to convert it to an iterator. First, we change printResult to yield:
function permgen(a, n)
    n = n or #a
    if n <= 1 then
　    coroutine.yield(a)
    else
        for i = 1, n do
            a[n], a[i] = a[i], a[n]
            permgen(a, n - 1)
            a[n], a[i] = a[i], a[n]
　    end
    end
end
Then, we define a factory that arranges for the generator to run inside a coroutine and creates the iterator function. The iterator simply resumes the coroutine to produce the next permutation:

function permutations(a)
    local co = coroutine.create(function () permgen(a) end)
    return function ()	-- iterator
        local code, res = coroutine.resume(co)
        return res
　end
end
With this machinery in place, it is trivial to iterate over all permutations of an array with a for statement:

for p in permutations{"a", "b", "c"} do
    printResult(p)
end
--> b c a
--> c b a
--> c a b
--> a c b
--> b a c
--> a b c

The function permutations uses a common pattern in Lua, which packs a call to resume with its corresponding coroutine inside a function. 
This pattern is so common that Lua provides a special function for it: coroutine.wrap. Like create, wrap creates a new coroutine. 
Unlike create, wrap does not return the coroutine itself; instead, it returns a function that, when called, resumes the coroutine. 
Unlike the original resume, that function does not return an error code as its first result; instead, it raises the error in case of error. 
Using wrap, we can write permutations as follows:

function permutations(a)
    return coroutine.wrap(function () permgen(a) end)
end
Usually, coroutine.wrap is simpler to use than coroutine.create. It gives us exactly what we need from a coroutine: a function to resume it. 
However, it is also less flexible. There is no way to check the status of a coroutine created with wrap. Moreover, we cannot check for runtime errors.
Event-Driven Programming
It may not be obvious at first sight, but the typical entanglement created by conventional event-driven programming is another consequence of the who-is-the-boss problem.

In a typical event-driven platform, an external entity generates events to our program in a so-called event loop (or run loop). It is clear who is the boss there, and it is not our code. 
Our program becomes a slave of the event loop, and that makes it a collection of individual event handlers without any apparent connection.

To make things a little more concrete, let us assume that we have an asynchronous I/O library similar to libuv. The library has four functions that concern our small example:

lib.runloop();
lib.readline(stream, callback);
lib.writeline(stream, line, callback);
lib.stop();


The first function runs the event loop, which will process the incoming events and call the associated callbacks. 
A typical event-driven program initializes some stuff and then calls this function, which becomes the main loop of the application. 
The second function instructs the library to read a line of the given stream and, when it is done, to call the given callback function with the result. 
The third function is similar to the second, but for writing a line. The last function breaks the event loop, usually to finish the program.

local cmdQueue = {}	-- queue of pending operations
local lib = {}
function lib.readline(stream, callback)
    local nextCmd = function ()
　    callback(stream:read())
    end
　table.insert(cmdQueue, nextCmd)
end

function lib.writeline (stream, line, callback)
    local nextCmd = function ()
　    callback(stream:write(line))
    end
　table.insert(cmdQueue, nextCmd)
end

function lib.stop ()
    table.insert(cmdQueue, "stop")
end

function lib.runloop ()
    while true do
        local nextCmd = table.remove(cmdQueue, 1)
        if nextCmd == "stop" then
            break
        else
　        nextCmd()	-- perform next operation
        end
　end
end

return lib
It is a very ugly implementation. Its “event queue” is in fact a list of pending operations that, when performed (synchronously!), will generate the events. 
Despite its uglyness, it fulfills the previous specification and, therefore, allows us to test the following examples without the need for a real asynchronous library.
Let us now write a trivial program with that library, which reads all lines from its input stream into a table and writes them to the output stream in reverse order. 
With traditional I/O, the program would be like this:

local t = {}
local inp = io.input()	-- input stream
local out = io.output()	-- output stream

for line in inp:lines() do
    t[#t + 1] = line
end

for i = #t, 1, -1 do
    out:write(t[i], "\n")
end
Now we rewrite that program in an event-driven style on top of the asynchronous I/O library.

local lib = require "async-lib"

local t = {}
local inp = io.input()
local out = io.output()

local i

-- write-line handler
local function putline()
    i = i - 1
    if i == 0 then
        lib.stop()
    else
        lib.writeline(out, t[i] .. "\n", putline)
　end
end

-- read-line handler
local function getline(line)
    if line then
        t[#t + 1] = line
        lib.readline(inp, getline)
    else
        i = #t + 1
        putline()
    end
end

lib.readline(inp, getline)	-- ask to read first line
lib.runloop()	-- run the main loop
As is typical in an event-driven scenario, all our loops are gone, because the main loop is in the library. They got replaced by recursive calls disguised as events. 
We could improve things by using closures in  a continuation-passing style, but we still could not write our own loops; we would have to rewrite them through recursion.
Coroutines allow us to reconcile our loops with the event loop. The key idea is to run our main code as a coroutine that, at each request to the library, sets the callback as a function to resume itself and then yields. 
Figure 24.5, “Running synchronous code on top of the asynchronous library” uses this idea to implement a library that runs conventional, synchronous code on top of the asynchronous I/O library.


Figure 24.5. Running synchronous code on top of the asynchronous library
local lib = require "async-lib"
function run (code)
    local co = coroutine.wrap(function ()
        code()
　    lib.stop()	-- finish event loop when done
    end)
    co()	-- start coroutine
    lib.runloop()	-- start event loop
end

function putline (stream, line)
    local co = coroutine.running() -- calling coroutine
    local callback = (function () coroutine.resume(co) end)
    lib.writeline(stream, line, callback)
　coroutine.yield()
end

function getline (stream, line)
    local co = coroutine.running()	-- calling coroutine
    local callback = (function (l) coroutine.resume(co, l) end)
    lib.readline(stream, callback)
    local line = coroutine.yield()
    return line
end
As its name implies, the run function runs the synchronous code, which it takes as a parameter. It first creates a coroutine to run the given code and finish the event loop when it is done. 
Then, it resumes this coroutine (which will yield at its first I/O call) and then enters the event loop.
The functions getline and putline simulate synchronous I/O. As outlined, both call an appropriate asynchronous function passing as the callback a function that resumes the calling coroutine. 
(Note the use of the coroutine.running function to access the calling coroutine.) After that, they yield, and the control goes back to the event loop. 
Once the operation completes, the event loop calls the callback, resuming the coroutine that triggered the operation.
With that library in place, we are ready to run synchronous code on the top of the asynchronous library. As an example, the following fragment implements once more our reverse-lines example:

run(function ()
    local t = {}
    local inp = io.input()
    local out = io.output()

    while true do
        local line = getline(inp)
        if not line then
            break
        end
        t[#t + 1] = line
    end

    for i = #t, 1, -1 do
        putline(out, t[i] .. "\n")
    end
end)
The code is equal to the original synchronous one, except that it uses get/putline for I/O and runs inside a call to run. Underneath its synchronous structure, 
it actually runs in an event-driven fashion, and it is fully compatible with other parts of the program written in a more typical event-driven style.

Chapter 25. Reflection
Reflection is the ability of a program to inspect and modify some aspects of its own execution. Dynamic languages like Lua naturally support several reflective features: 
environments allow run-time inspection of global variables; functions like type and pairs allow run-time inspection and traversal of unknown data structures; 
functions like load and require allow a program to add code to itself or update its own code. However, many things are still missing: 
programs cannot introspect on their local variables, programs cannot trace their execution, functions cannot know their callers, etc. The debug library fills many of these gaps.

The debug library comprises two kinds of functions: introspective functions and hooks. Introspective functions allow us to inspect several aspects of the running program, 
such as its stack of active functions, current line of execution, and values and names of local variables. Hooks allow us to trace the execution of a program.

Despite its name, the debug library does not give us a debugger for Lua. Nevertheless, it provides all the primitives that we need to write our own debuggers, with varying levels of sophistication.
Unlike the other libraries, we should use the debug library with parsimony. First, some of its functionality is not exactly famous for performance. 
Second, it breaks some sacred truths of the language, such as that we cannot access a local variable from outside its lexical scope. 
Although the library is readily available as a standard library, I prefer to require it explicitly in any chunk that uses it.
Introspective Facilities
The main introspective function in the debug library is getinfo. Its first parameter can be a function or a stack level. 
When we call debug.getinfo(foo) for a function foo, it returns a table with some data about this function. The table can have the following fields:

source:		This field tells where the function was defined. If the function was defined in a string (through a call to load), source is that string. 
		If the function was defined in a file, source is the file name prefixed with an at-sign.
short_src:	This field gives a short version of source (up to 60 characters). It is useful for error messages.
linedefined:	This field gives the number of the first line in the source where the function was defined.
lastlinedefined: 	This field gives the number of the last line in the source where the function was defined.
what:		This field tells what this function is. Options are "Lua" if foo is a regular Lua function, "C" if it is a C function, or "main" if it is the main part of a Lua chunk.
name:		This field gives a reasonable name for the function, such as the name of a global variable that stores this function.
namewhat:	This field tells what the previous field means. This field can be "global", "local", "method", "field", or "" (the empty string). 
		The empty string means that Lua did not find a name for the function.
nups:		This is the number of upvalues of that function.
nparams:	This is the number of parameters of that function.
isvararg:		This tells whether the function is variadic (a Boolean).
activelines:	This field is a table representing the set of active lines of the function. An active line is a line with some code, 
		as opposed to empty lines or lines containing only comments. 
		(A typical use of this information is for setting breakpoints. Most debuggers do not allow us to set a breakpoint outside an active line, as it would be unreachable.)
func:		This field has the function itself.
When foo is a C function, Lua does not have much data about it. For such functions, only the fields what, name, namewhat, nups, and func are meaningful.
When we call debug.getinfo(n) for some number n, we get data about the function active at that stack level. 
A stack level is a number that refers to a particular function that is active at that moment. The function calling getinfo has level one, the function that called it has level two, and so on. 
(At level zero, we get data about getinfo itself, a C function.) If n is larger than the number of active functions on the stack, debug.getinfo returns nil. 
When we query an active function, by calling debug.getinfo with a stack level, the resulting table has two extra fields: 
currentline, the line where the function is at that moment; and istailcall (a Boolean), true if this function was called by a tail call. 
(In this case, the real caller of this function is not on the stack anymore.)

The field name is tricky. Remember that, because functions are first-class values in Lua, a function may not have a name, or may have several names. 
Lua tries to find a name for a function by looking into the code that called the function, to see how it was called. This method works only when we call getinfo with a number, 
that is, when we ask information about a particular invocation.
The function getinfo is not efficient. Lua keeps debug information in a form that does not impair program execution; efficient retrieval is a secondary goal here. 
To achieve better performance, getinfo has an optional second parameter that selects what information to get. 
In this way, the function does not waste time collecting data that the user does not need. 
The format of this parameter is a string, where each letter selects a group of fields, according to the following table:

n	selects name and namewhat
f	selects func
S	selects source, short_src, what, linede- fined, and lastlinedefined
l	selects currentline
L	selects activelines
u	selects nup, nparams, and isvararg
The following function illustrates the use of debug.getinfo by printing a primitive traceback of the active stack:

function traceback ()
    for level = 1, math.huge do
        local info = debug.getinfo(level, "Sl")
        if not info then
            break
        end
        if info.what == "C" then
            print(string.format("%d\tC function", level))
        else
            print(string.format("%d\t[%s]:%d", level, info.short_src, info.currentline))
        end
    end
end

It  is  not  difficult  to  improve  this  function,  by  including  more  data  from  getinfo.  Actually,  the debug library offers such an improved version, the function traceback. 
Unlike our version, debug.traceback does not print its result; instead, it returns a (potentially long) string containing the traceback:

> print(debug.traceback())
stack traceback:
stdin:1: in main chunk [C]: in ?
Accessing local variables
We can inspect the local variables of any active function with debug.getlocal. This function has two parameters: the stack level of the function we are querying and a variable index. 
It returns two values: the name and the current value of the variable. If the variable index is larger than the number of active variables, getlocal returns nil. 
If the stack level is invalid, it raises an error. (We can use debug.getinfo to check the validity of the stack level.)

Lua numbers local variables in the order that they appear in a function, counting only the variables that are active in the current scope of the function. 
For instance, consider the following function:

function foo(a, b)
    local x
    do
        local c = a - b
    end
    local a = 1
    while true do
        local name, value = debug.getlocal(1, a)
        if not name then
            break
        end
        print(name, value)
        a = a + 1
　end
end
The call foo(10, 20) will print this:
a	10
b	20
x	nil
a	4

The variable with index 1 is a (the first parameter), 2 is b, 3 is x, and 4 is the inner a. At the point where getlocal is called, c is already out of scope, 
while name and value are not yet in scope. (Remember that local variables are only visible after their initialization code.)

Starting with Lua 5.2, negative indices get information about the extra arguments of a variadic function: index -1 refers to the first extra argument. 
The name of the variable in this case is always "(*vararg)".
We can also change the values of local variables, with debug.setlocal. Its first two parameters are a stack level and a variable index, like in getlocal. 
Its third parameter is the new value for the variable. It returns the variable name or nil if the variable index is out of scope.


Accessing non-local variables
The debug library also allows us to access the non-local variables used by a Lua function, with getupvalue. 
Unlike local variables, the non-local variables referred by a function exist even when the function is not active (this is what closures are about, after all). 
Therefore, the first argument for getupvalue is not a stack level, but a function (a closure, more precisely). The second argument is the variable index. 
Lua numbers non-local variables in the order in which they are first referred in a function, but this order is not relevant, 
because a function cannot access two non-local variables with the same name.

We can also update non-local variables, with debug.setupvalue. As you might expect, it has three parameters: a closure, a variable index, and the new value. 
Like setlocal, it returns the name of the variable, or nil if the variable index is out of range.

Figure 25.1, “Getting the value of a variable” shows how we can access the value of a variable from a calling function, given the variable's name.

Figure 25.1. Getting the value of a variable

function getvarvalue(name, level, isenv)
    local value
    local found = false
    level = (level or 1) + 1
    for i = 1, math.huge do
        local n, v = debug.getlocal(level, i)
        if not n then
            break
        end
        if n == name then
            value = v
　        found = true
        end
    end
    if found then
        return "local", value
    end

    local func = debug.getinfo(level, "f").func
    for i = 1, math.huge do
        local n, v = debug.getupvalue(func, i)
        if not n then
           break
        end
　     if n == name then
           return "upvalue", v
        end
    end

    if isenv then
        return "noenv"
    end

    local _, env = getvarvalue("_ENV", level, true)
    if env then
　    return "global", env[name]
    else
　    return "noenv"
    end
end


It can be used like here:

> local a = 4; print(getvarvalue("a")) --> local 4
> a = "xx"; print(getvarvalue("a")) --> global xx

The parameter level tells where on the stack the function should look; one (the default) means the immediate caller. 
The plus one in the code corrects the level to include the call to getvarvalue itself. I will explain the parameter isenv in a moment.

The function first looks for a local variable. If there is more than one local with the given name, it must get the one with the highest index; 
thus, it must always go through the whole loop. If it cannot find any local variable with that name, then it tries the non-local variables. 
For that, it gets the calling closure, with debug.getinfo, and then it traverses its non-local variables. 
Finally, if it cannot find a non-local variable with that name, then it goes for a global variable: it calls itself recursively to access the proper _ENV variable and then looks up the name in that environment.

The parameter isenv avoids a tricky problem. It tells when we are in a recursive call, looking for the variable _ENV to query a global name. 
A function that uses no global variables may not have an upvalue _ENV. In that case, if we tried to consult _ENV as a global, we would enter a recursive loop, 
because we would need _ENV to get its own value. So, when isenv is true and the function cannot find a local or an upvalue, it does not try the global variables.

Accessing other coroutines
All introspective functions from the debug library accept an optional coroutine as their first argument, so that we can inspect the coroutine from the outside. 
For instance, consider the next example:

co = coroutine.create(function ()
    local x = 10
    coroutine.yield()
    error("some error")
end)

coroutine.resume(co)
print(debug.traceback(co))

The call to traceback will work on the coroutine co, resulting in something like this:

stack traceback:
[C]: in function 'yield'
temp:3: in function <temp:1>

The trace does not go through the call to resume, because the coroutine and the main program run in different stacks.

When a coroutine raises an error, it does not unwind its stack. This means that we can inspect it after the error. 
Continuing our example, the coroutine hits the error if we resume it again:

print(coroutine.resume(co))	--> false	temp:4: some error

Now, if we print its traceback, we get something like this:

stack traceback:
[C]: in function 'error'
temp:4: in function <temp:1>

We can also inspect local variables from a coroutine, even after an error:

print(debug.getlocal(co, 1, 1))	--> x	10

Hooks

The hook mechanism of the debug library allows us to register a function to be called at specific events as a program runs. There are four kinds of events that can trigger a hook:

• call events happen every time Lua calls a function;

• return events happen every time a function returns;

• line events happen when Lua starts executing a new line of code;

• count events happen after a given number of instructions. (Instructions here mean internal opcodes, which we visited briefly in the section called “Precompiled Code”.)

Lua calls all hooks with a string argument that describes the event that generated the call: "call" (or "tail call"), "return", "line", or "count". 
For line events, it also passes a second argument, the new line number. To get more information inside a hook, we have to call debug.getinfo.

To register a hook, we call debug.sethook with two or three arguments: the first argument is the hook function; 
the second argument is a mask string, which describes the events we want to monitor; and the optional third argument is a number that describes at what frequency we want to get count events. 
To monitor the call, return, and line events, we add their first letters (c, r, or l) into the mask string. To monitor the count event, we simply supply a counter as the third argument. 
To turn off hooks, we call sethook with no arguments.
As a simple example, the following code installs a primitive tracer, which prints each line the interpreter executes:

debug.sethook(print, "l")

This call simply installs print as the hook function and instructs Lua to call it only at line events. A more elaborated tracer can use getinfo to add the current file name to the trace:

function trace (event, line)
    local s = debug.getinfo(2).short_src
    print(s .. ":" .. line)
end

debug.sethook(trace, "l")

A useful function to use with hooks is debug.debug. This simple function gives us a prompt that executes arbitrary Lua commands. It is roughly equivalent to the following code:

function debug1()
    while true do
        io.write("debug> ")
        local line = io.read()
        if line == "cont" then
            break
        end
        assert(load(line))()
    end
end

When the user enters the “command” cont, the function returns. The standard implementation is very simple and runs the commands in the global environment, outside the scope of the code being debugged. Exercise 25.4 discusses a better implementation.

Profiles
Besides debugging, another common application for reflection is profiling, that is, an analysis of the behavior of a program regarding its use of resources. 
For a timing profile, it is better to use the C interface: the overhead of a Lua call for each hook is too high and may invalidate any measurement. 
However, for counting profiles, Lua code does a decent job. In this section, we will develop a rudimentary profiler that lists the number of times each function in a program is called during a run.

The main data structures of our program are two tables: one maps functions to their call counters, and the other maps functions to their names. 
The indices to both tables are the functions themselves.

local Counters = {}
local Names = {}

We could retrieve the function names after the profiling, but remember that we get better results if we get the name of a function while it is active, 
because then Lua can look at the code that is calling the function to find its name.

Now we define the hook function. Its job is to get the function being called, increment the corresponding counter, and collect the function name. 
The code is in Figure 25.2, “Hook for counting number of calls”.

Figure 25.2. Hook for counting number of calls

local function hook ()
    local f = debug.getinfo(2, "f").func
    local count = Counters[f]
    if count == nil then
        Counters[f] = 1
　    Names[f] = debug.getinfo(2, "Sn")
    else
        Counters[f] = count + 1
    end
end

The next step is to run the program with that hook. We will assume that the program we want to analyze is in a file and that the user gives this file name as an argument to the profiler, like this:

lua profiler main-prog

With this scheme, the profiler can get the file name in arg[1], turn on the hook, and run the file:

local f = assert(loadfile(arg[1]))
debug.sethook(hook, "c")	-- turn on the hook for calls
f()	-- run the main program
debug.sethook()	-- turn off the hook


The last step is to show the results. The function getname, in Figure 25.3, “Getting the name of a function”, produces a name for a function.

Figure 25.3. Getting the name of a function

function getname (func)
    local n = Names[func]
    if n.what == "C" then
　    return n.name
    end
    local lc = string.format("[%s]:%d", n.short_src, n.linedefined)
    if n.what ~= "main" and n.namewhat ~= "" then
　    return string.format("%s (%s)", lc, n.name)
    else
　    return lc
    end
end

Because function names in Lua are so uncertain, we add to each function its location, given as a pair file:line. If a function has no name, then we use just its location. 
For a C function, we use only its name (as it has no location). After that definition, we print each function with its counter:

for func, count in pairs(Counters) do
    print(getname(func), count)
end

If we apply our profiler to the Markov example that we developed in Chapter 19, Interlude: Markov Chain Algorithm, we get a result like this:

[markov.lua]:4 884723
write	10000
[markov.lua]:0 1
read	31103
sub	884722
...

This result means that the anonymous function at line 4 (which is the iterator function defined inside allwords) was called 884723 times, write (io.write) was called 10000 times, and so on.
There are several improvements that we can make to this profiler, such as to sort the output, to print better function names, and to embellish the output format. 
Nevertheless, this basic profiler is already useful as it is.

Sandboxing
In the section called “_ENV and load”, we saw how easy it is to use load to run a Lua chunk in a restricted environment. 
Because Lua does all communication with the external world through library functions, once we remove these functions, we also remove the possibility of a script to have any effect on the external world. 
Nevertheless, we are still susceptible to denial of service (DoS) attacks, with a script wasting large amounts of CPU time or memory. 
Reflection, in the form of debug hooks, provides an interesting approach to curb such attacks.

A first step is to use a count hook to limit the number of instructions that a chunk can execute. 

local debug = require "debug"

-- maximum "steps" that can be performed
local steplimit = 1000
local count = 0	-- counter for steps
local function step()
    count = count + 1
    if count > steplimit then
        error("script uses too much CPU")
　end
end

-- load file
local f = assert(loadfile(arg[1], "t", {}))
debug.sethook(step, "", 100)
f()
The program loads the given file, sets the hook, and runs the file. It sets the hook as a count hook, so that
Lua calls the hook every 100 instructions. The hook (the function step) only increments a counter and checks it against a fixed limit. What can possibly go wrong?

Of course, we must restrict the size of the chunks that we load: a huge chunk can exhaust memory only by being loaded. 
Another problem is that a program can consume huge amounts of memory with surprisingly few instructions, as the next fragment shows:

local s = "123456789012345"
for i = 1, 36 do
    s = s .. s
end

With less than 150 instructions, this tiny fragment will try to create a string with one terabyte. Clearly, restricting only steps and program size is not enough.

One improvement is to check and limit memory use in the step function, as we show in Figure 25.5, “Controlling memory use”.


Figure 25.5. Controlling memory use

local debug = require "debug"

-- maximum memory (in KB) that can be used
local memlimit = 1000

-- maximum "steps" that can be performed
local steplimit = 1000

local function checkmem ()
    if collectgarbage("count") > memlimit then
        error("script uses too much memory")
    end
end

local count = 0
local function step()
    checkmem()
    count = count + 1
    if count > steplimit then
        error("script uses too much CPU")
　end
end

-- load file
local f = assert(loadfile(arg[1], "t", {}))
debug.sethook(step, "", 100)
f()

Because memory can grow so fast with so few instructions, we should set a very low limit or call the hook in small steps. 
More concretely, a program can do a thousandfold increase in the size of a string in 40 instructions. 
So, either we call the hook with a higher frequency than every 40 steps or we set the memory limit to one thousandth of what we can really afford. I would probably choose both.

A subtler problem is the string library. We can call any function from this library as a method on a string. 
Therefore, we can call these functions even if they are not in the environment; literal strings smuggle them into our sandbox. 
No function in the string library affects the external world, but they bypass our step counter. (A call to a C function counts as one instruction in Lua.) 
Some functions in the string library can be quite dangerous for DoS attacks. For instance, the call ("x"):rep(2^30) swallows 1 GB of memory in a single step. 
As another example, Lua 5.2 takes 13 minutes to run the following call in my new machine:

s = "01234567890123456789012345678901234567890123456789"
s:find(".*.*.*.*.*.*.*.*.*x")

An interesting way to restrict the access to the string library is to use call hooks. Every time a function is called, we check whether it is authorized. 
Figure 25.6, “Using hooks to bar calls to unauthorized functions” implements this idea.


Figure 25.6. Using hooks to bar calls to unauthorized functions

local debug = require "debug"

-- maximum "steps" that can be performed
local steplimit = 1000

local count = 0	-- counter for steps

-- set of authorized functions
local validfunc = {
    [string.upper] = true, [string.lower] = true,
    ...	-- other authorized functions
}

local function hook(event)
    if event == "call" then
        local info = debug.getinfo(2, "fn")
        if not validfunc[info.func] then
　        error("calling bad function: " .. (info.name or "?"))
        end
    end
    count = count + 1
    if count > steplimit then
        error("script uses too much CPU")
　end
end

-- load chunk
local f = assert(loadfile(arg[1], "t", {}))
debug.sethook(hook, "", 100)
f()
In that code, the table validfunc represents a set with the functions that the program can call. 
The function hook uses the debug library to access the function being called and then checks whether that function is in the validfunc set.

An important point in any sandbox implementation is what functions we allow inside the sandbox. Sandboxes for data description can restrict all or most functions. 
Other sandboxes must be more forgiving, maybe offering their own restricted implementations for some functions (e.g., load restricted to small text chunks, file access restricted to a fixed directory, or pattern matching restricted to small subjects).

We should never think in terms of what functions to remove, but what functions to add. For each candidate, we must carefully consider its possible weaknesses, which may be subtle. 
As a rule of thumb, all functions from the mathematical library are safe. Most functions from the string library are safe; just be careful with resource-consuming ones. 
The debug and package libraries are off-limits; almost everything there can be dangerous. The functions setmetatable and getmetatable are also tricky: 
first, they can allow access to otherwise inaccessible values; moreover, they allow the creation of tables with finalizers, where someone can install all sorts of “time bombs” (code that can be executed outside the sandbox, when the table is collected).

Chapter 26. Interlude: Multithreading with Coroutines
In this interlude, we will see an implementation of a multithreading system on top of coroutines.

As we saw earlier, coroutines allow a kind of collaborative multithreading. Each coroutine is equivalent to a thread. 
A pair yield–resume switches control from one thread to another. However, unlike regular multithreading, coroutines are non preemptive. 
While a coroutine is running, we cannot stop it from the outside. It suspends execution only when it explicitly requests so, through a call to yield. 
For several applications, this is not a problem, quite the opposite. Programming is much easier in the absence of preemption. 
We do not need to be paranoid about synchronization bugs, because all synchronization among threads is explicit in the program. 
We just need to ensure that a coroutine yields only when it is outside  a critical region.

However, with non-preemptive multithreading, whenever any thread calls a blocking operation, the whole program blocks until the operation completes. 
For many applications, this behavior is unacceptable, which leads many programmers to disregard coroutines as a real alternative to conventional multithreading. 
As we will see here, this problem has an interesting (and obvious, with hindsight) solution.

Let us assume a typical multithreading situation: we want to download several remote files through HTTP. 
To download several remote files, first we must learn how to download one remote file. In this example, we will use the LuaSocket library. 
To download a file, we must open a connection to its site, send a request to the file, receive the file (in blocks), and close the connection. 
In Lua, we can write this task as follows. First, we load the LuaSocket library:

local socket = require "socket"

Then, we define the host and the file we want to download. In this example, we will download the Lua 5.3 manual from the Lua site:

host = "www.lua.org"
file = "/manual/5.3/manual.html"

Then, we open a TCP connection to port 80 (the standard port for HTTP connections) of that site:

c = assert(socket.connect(host, 80))

This operation returns a connection object, which we use to send the file request:

local request = string.format("GET %s HTTP/1.0\r\nhost: %s\r\n\r\n", file, host)
c:send(request)
Next, we read the file in blocks of 1 kB, writing each block to the standard output:

repeat
    local s, status, partial = c:receive(2^10)
    io.write(s or partial)
until status == "closed"

The method receive returns either a string with what it read or nil in case of error; in the latter case, it also returns an error code (status) and what it read until the error (partial). 
When the host closes the connection, we print that remaining input and break the receive loop.


After downloading the file, we close the connection:

c:close()

Now that we know how to download one file, let us return to the problem of downloading several files. The trivial approach is to download one at a time. 
However, this sequential approach, where we start reading a file only after finishing the previous one, is too slow. 
When reading a remote file, a program spends most of its time waiting for data to arrive. More specifically, it spends most of its time blocked  in the call to receive. 
So, the program could run much faster if it downloaded all files concurrently. Then, while a connection has no data available, the program can read from another connection. 
Clearly, coroutines offer a convenient way to structure these simultaneous downloads. We create a new thread for each download task. 
When a thread has no data available, it yields control to a simple dispatcher, which invokes another thread.

To rewrite the program with coroutines, we first rewrite the previous download code as a function. The result is in Figure 26.1, “Function to download a Web page”.

Figure 26.1. Function to download a Web page

function download(host, file)
    local c = assert(socket.connect(host, 80))
    local count = 0	-- counts number of bytes read
    local request = string.format("GET %s HTTP/1.0\r\nhost: %s\r\n\r\n", file, host)
    c:send(request)
    while true do
        local s, status = receive(c)
        count = count + #s
　    if status == "closed" then
            break
        end
    end
    c:close()
    print(file, count)
end

Because we are not interested in the remote file contents, this function counts and prints the file size, instead of writing the file to the standard output. 
(With several threads reading several files, the output would shuffle all files.)

In this new code, we use an auxiliary function (receive) to receive data from the connection. In the sequential approach, its code would be like this:

function receive (connection)
    local s, status, partial = connection:receive(2^10)
    return s or partial, status
end

For the concurrent implementation, this function must receive data without blocking. Instead, if there is not enough data available, it yields. The new code is like this:

function receive (connection)
    connection:settimeout(0)	-- do not block
    local s, status, partial = connection:receive(2^10)
    if status == "timeout" then
　    coroutine.yield(connection)
    end
　return s or partial, status
end
The call to settimeout(0) makes any operation over the connection a non-blocking operation. When the resulting status is "timeout", it means that the operation returned without completion. 
In this case, the thread yields. The non-false argument passed to yield signals to the dispatcher that the thread is still performing its task. 
Note that, even in case of a timeout, the connection returns what it read until the timeout, which is in the variable partial.
Figure 26.2, “The dispatcher” shows the dispatcher plus some auxiliary code.

Figure 26.2. The dispatcher
tasks = {}	-- list of all live tasks
function get(host, file)
    -- create coroutine for a task
    local co = coroutine.wrap(function () download(host, file) end)
    -- insert it in the list
    table.insert(tasks, co)
end

function dispatch ()
    local i = 1
    while true do
        if tasks[i] == nil then	-- no other tasks?
            if tasks[1] == nil then		-- list is empty?
　            break	-- break the loop
            end
            i = 1	-- else restart the loop
        end
        local res = tasks[i]()	-- run a task
        if not res then	-- task finished?
　        table.remove(tasks, i)
        else
　        i = i + 1	-- go to next task end
　    end
end
The table tasks keeps a list of all live tasks for the dispatcher. The function get ensures that each download task runs in an individual thread. 
The dispatcher itself is mainly a loop that goes through all tasks, resuming them one by one. It must also remove from the list the tasks that have finished. 
It stops the loop when there are no more tasks to run.

Finally, the main program creates the tasks it needs and calls the dispatcher. To download some distributions from the Lua site, the main program could be like this:

get("www.lua.org", "/ftp/lua-5.3.2.tar.gz")
get("www.lua.org", "/ftp/lua-5.3.1.tar.gz")
get("www.lua.org", "/ftp/lua-5.3.0.tar.gz")
get("www.lua.org", "/ftp/lua-5.2.4.tar.gz")
get("www.lua.org", "/ftp/lua-5.2.3.tar.gz")

dispatch()	-- main loop
The sequential implementation takes fifteen seconds to download these files, in my machine. This implementation with coroutines runs more than three times faster.

Despite the speedup, this last implementation is far from optimal. Everything goes fine while at least  one thread has something to read. 
However, when no thread has data to read, the dispatcher does a busy wait, going from thread to thread only to check that they still have no data. 
As a result, this coroutine implementation uses three orders of magnitude more CPU than the sequential solution.

To avoid this behavior, we can use the function select from LuaSocket: it allows a program to block while waiting for a status change in a group of sockets. 
The changes in our implementation are small: we have to change only the dispatcher, as shown in Figure 26.3, “Dispatcher using select”.

Figure 26.3. Dispatcher using select
function dispatch ()
    local i = 1
    local timedout = {}
    while true do
        if tasks[i] == nil then	-- no other tasks?
            if tasks[1] == nil then		-- list is empty?
　            break	-- break the loop
            end
            i = 1	-- else restart the loop
            timedout = {}
        end
        local res = tasks[i]()	-- run a task
        if not res then	-- task finished?
            table.remove(tasks, i)
        else	-- time out
            i = i + 1
            timedout[#timedout + 1] = res
            if #timedout == #tasks then    -- all tasks blocked?
                socket.select(timedout)	-- wait
　        end
        end
    end
end
Along the loop, this new dispatcher collects the timed-out connections in the table timedout. (Remember that receive passes such connections to yield, thus resume returns them.) 
If all connections time out, the dispatcher calls select to wait for any of these connections to change status. This final implementation runs as fast as the previous implementation, with coroutines. 
Moreover, as it does not do busy waits, it uses just as much CPU as the sequential implementation.
